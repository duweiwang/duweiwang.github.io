<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android的maven插件和maven-publish插件</title>
    <url>/Android%E7%9A%84maven%E6%8F%92%E4%BB%B6%E5%92%8Cmaven-publish%E6%8F%92%E4%BB%B6.html</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>由于maven插件已经废弃，被maven-publish插件替代了，有些老项目还在使用maven插件，所以需要知道如何升级，这里做一个对比。</p>
<h4 id="maven插件"><a href="#maven插件" class="headerlink" title="maven插件"></a>maven插件</h4><p>以下是总体配置，具体还会涉及：是否上传源码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">//release 还是snapshot打包</span></span><br><span class="line">            <span class="keyword">def</span> isRelease = project.AAR_BUILD_TYPE == <span class="string">&quot;release&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (isRelease) &#123;</span><br><span class="line">                repository(<span class="attr">url:</span> project.RELEASE_URL) &#123; <span class="comment">//正式仓库地址</span></span><br><span class="line">                    authentication(<span class="attr">userName:</span> project.MAVEN_USERNAME, <span class="attr">password:</span> project.MAVEN_PASSWORD)</span><br><span class="line">                &#125;</span><br><span class="line">                pom.version = project.AAR_VERSION<span class="comment">//eg: 1.0.0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                repository(<span class="attr">url:</span> project.SNAPSHOT_URL) &#123;<span class="comment">//测试仓库地址</span></span><br><span class="line">                    authentication(<span class="attr">userName:</span> project.MAVEN_USERNAME, <span class="attr">password:</span> project.MAVEN_PASSWORD)</span><br><span class="line">                &#125;</span><br><span class="line">                pom.version = project.AAR_SNAPSHOT_VERSION<span class="comment">//eg: 1.0.0-shapshot</span></span><br><span class="line">            &#125;</span><br><span class="line">            pom.groupId = project.POM_GROUPID<span class="comment">//eg：com.github.bumptech.glide</span></span><br><span class="line">            pom.artifactId = project.POM_ARTIFACTID<span class="comment">//eg: glide</span></span><br><span class="line">            pom.name = project.POM_NAME<span class="comment">// eg: glide</span></span><br><span class="line">            pom.packaging = project.POM_PACKAGING<span class="comment">//eg: aar/jar</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="maven-publish插件"><a href="#maven-publish插件" class="headerlink" title="maven-publish插件"></a>maven-publish插件</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    repositories &#123;<span class="comment">//仓库</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url = <span class="string">&quot;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span></span><br><span class="line">            credentials &#123;</span><br><span class="line">                username = <span class="string">&quot;sonatypeUsername&quot;</span></span><br><span class="line">                password = <span class="string">&quot;sonatypePassword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    publications &#123;<span class="comment">//发布产物</span></span><br><span class="line">        <span class="comment">//下面这个名字可以自己定义如：debug、release</span></span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//配置产物，三种方式</span></span><br><span class="line">            <span class="comment">//1、依赖bundleReleaseAar任务，并上传产物</span></span><br><span class="line">            afterEvaluate&#123;</span><br><span class="line">                artifact(tasks.getByName(<span class="string">&quot;bundleReleaseAar&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2、直接指定路径</span></span><br><span class="line">            artifact <span class="string">&quot;$buildDir/outputs/aar/$&#123;project.name&#125;-release.aar&quot;</span></span><br><span class="line">            <span class="comment">//3、结合agp插件</span></span><br><span class="line">            </span><br><span class="line">            groupId = <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">            artifactId = <span class="string">&#x27;my-library&#x27;</span></span><br><span class="line">            version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line">            pom &#123;</span><br><span class="line">                name = <span class="string">&#x27;My Library&#x27;</span></span><br><span class="line">                description = <span class="string">&#x27;A description of my library&#x27;</span></span><br><span class="line">                url = <span class="string">&#x27;https://github.com/example/my-library&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>结合agp插件，指定产物：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    publishing &#123;</span><br><span class="line">        repositories &#123;<span class="comment">//仓库</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publications &#123;<span class="comment">//发布产物</span></span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            from components.release<span class="comment">//发布内容</span></span><br><span class="line">            artifact sourcejar<span class="comment">//上传源码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/h_bpdwn/article/details/122479437">maven插件 和 maven-publish 插件的区别</a><br><a href="https://www.bytezonex.com/archives/R8trm3Wz.html">Maven 插件与 Maven-Publish 插件的差异</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android消息机制</title>
    <url>/android-aosp-event-loop.html</url>
    <content><![CDATA[<hr>
<h4 id="一、相关类和结构"><a href="#一、相关类和结构" class="headerlink" title="一、相关类和结构"></a>一、相关类和结构</h4><center>
    <img src="../images/android-basic-eventloop.png" width="100%"/>
</center>

<h4 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h4><h5 id="2-1-主线程的事件循环"><a href="#2-1-主线程的事件循环" class="headerlink" title="2.1 主线程的事件循环"></a>2.1 主线程的事件循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ActivityThreadInternal</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">         Looper.prepareMainLooper();</span><br><span class="line">         </span><br><span class="line">         Looper.loop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-2-构建自己的事件循环"><a href="#2-2-构建自己的事件循环" class="headerlink" title="2.2 构建自己的事件循环"></a>2.2 构建自己的事件循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、原理剖析"><a href="#三、原理剖析" class="headerlink" title="三、原理剖析"></a>三、原理剖析</h4><h5 id="3-1-构建事件循环"><a href="#3-1-构建事件循环" class="headerlink" title="3.1 构建事件循环"></a>3.1 构建事件循环</h5><center>
    <img src="../images/android-basic-eventloop-start.png" width="70%"/>
</center>


<h5 id="3-2-发送消息"><a href="#3-2-发送消息" class="headerlink" title="3.2 发送消息"></a>3.2 发送消息</h5><center>
    <img src="../images/android-basic-eventloop-send.png" width="70%"/>
</center>


<h5 id="3-3-消息执行"><a href="#3-3-消息执行" class="headerlink" title="3.3 消息执行"></a>3.3 消息执行</h5><center>
    <img src="../images/android-basic-eventloop-callback.png" width="50%"/>
</center>

<h5 id="3-4-同步屏障"><a href="#3-4-同步屏障" class="headerlink" title="3.4 同步屏障"></a>3.4 同步屏障</h5><h6 id="3-4-1-消息的分类"><a href="#3-4-1-消息的分类" class="headerlink" title="3.4.1 消息的分类"></a>3.4.1 消息的分类</h6><ul>
<li>同步消息</li>
<li>异步消息</li>
<li>屏障消息</li>
</ul>
<h6 id="3-4-2-同步屏障是什么"><a href="#3-4-2-同步屏障是什么" class="headerlink" title="3.4.2 同步屏障是什么"></a>3.4.2 同步屏障是什么</h6><p>一种特殊的Message，其target=null</p>
<h6 id="3-4-3-同步屏障工作原理"><a href="#3-4-3-同步屏障工作原理" class="headerlink" title="3.4.3 同步屏障工作原理"></a>3.4.3 同步屏障工作原理</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//碰到同步屏障</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="comment">// do while循环遍历消息链表</span></span><br><span class="line">                <span class="comment">// 跳出循环时，msg指向离表头最近的一个异步消息</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将msg从消息链表中移除</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="comment">//返回异步消息</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当设置了同步屏障之后，next函数将会忽略所有的同步消息，返回异步消息。换句话说就是，设置了同步屏障之后，Handler只会处理异步消息。再换句话说，同步屏障为Handler消息机制增加了一种简单的优先级机制，异步消息的优先级要高于同步消息。</p>
<h6 id="3-4-4-实际应用"><a href="#3-4-4-实际应用" class="headerlink" title="3.4.4 实际应用"></a>3.4.4 实际应用</h6><p>Android应用框架中为了更快的响应UI刷新事件在ViewRootImpl.scheduleTraversals中使用了同步屏障</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//设置同步障碍，确保mTraversalRunnable优先被执行</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//内部通过Handler发送了一个异步消息</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><p><a href="https://www.jxhs.me/2021/04/08/linux%E5%86%85%E6%A0%B8Epoll-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Epoll 实现原理</a></p>
<p><a href="https://www.cnblogs.com/LoyenWang/p/12622904.html">Linux select/poll机制原理分析</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的约束布局</title>
    <url>/android-basic-constraintlayout.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>&ensp;&ensp;&ensp;&ensp;Android中的视图是以树的形式组织起来的，它是一种层次结构。在代码中体现为组合模式，一个ViewGroup可以包含一个或多个View，同时ViewGroup又是一个View。在布局文件中体现为xml的结点和缩进。<br>&ensp;&ensp;&ensp;&ensp;同时视图的渲染少不了对其进行遍历，这就涉及数据结构中树的深度优先遍历和广度优先遍历。有时候一些复杂的布局一次遍历还无法完全确定View的信息。如何通过算法方式降低树的层次呢？也许这就是约束布局存在的意义吧。<br>&ensp;&ensp;&ensp;&ensp;在Android中，灵活运用ConstraintLayout包括以下几个点：</p>
<ul>
<li>主属性<ul>
<li>通过相对位置约束View</li>
<li>控制约束之间的距离</li>
<li>居中和偏移百分比</li>
<li>通过圆定位📌View</li>
<li>通过可见性控制View</li>
<li>通过分辨率约束View</li>
<li>通过链⛓约束View</li>
</ul>
</li>
<li>辅助工具<ul>
<li>Barrier屏障约束</li>
<li>Group分组约束</li>
<li>Placeholder占位约束</li>
<li>Guideline引导线约束</li>
</ul>
</li>
</ul>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><h5 id="2-1-通过相对位置约束View"><a href="#2-1-通过相对位置约束View" class="headerlink" title="2.1 通过相对位置约束View"></a>2.1 通过相对位置约束View</h5><center>
    <img src="../images/constraint/constraint_relative_position.png" width="500"/>
</center>

<table>
<thead>
<tr>
<th>约束属性</th>
<th>描述</th>
<th>约束属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout_constraintLeft_toLeftOf</td>
<td></td>
<td>layout_constraintLeft_toRightOf</td>
<td></td>
</tr>
<tr>
<td>layout_constraintRight_toLeftOf</td>
<td></td>
<td>layout_constraintRight_toRightOf</td>
<td></td>
</tr>
<tr>
<td>layout_constraintTop_toTopOf</td>
<td></td>
<td>layout_constraintTop_toBottomOf</td>
<td></td>
</tr>
<tr>
<td>layout_constraintBottom_toTopOf</td>
<td></td>
<td>layout_constraintBottom_toBottomOf</td>
<td></td>
</tr>
<tr>
<td>layout_constraintStart_toEndOf</td>
<td></td>
<td>layout_constraintStart_toStartOf</td>
<td></td>
</tr>
<tr>
<td>layout_constraintEnd_toStartOf</td>
<td></td>
<td>layout_constraintEnd_toEndOf</td>
<td></td>
</tr>
<tr>
<td>layout_constraintBaseline_toBaselineOf</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-2-控制约束之间的距离"><a href="#2-2-控制约束之间的距离" class="headerlink" title="2.2 控制约束之间的距离"></a>2.2 控制约束之间的距离</h5><center>
    <img src="../images/constraint/constraint_margin.png" width="500"/>
</center> 

<table>
<thead>
<tr>
<th>约束属性</th>
<th>描述</th>
<th>约束属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:layout_marginStart</td>
<td></td>
<td>layout_goneMarginStart</td>
<td></td>
</tr>
<tr>
<td>android:layout_marginEnd</td>
<td></td>
<td>layout_goneMarginEnd</td>
<td></td>
</tr>
<tr>
<td>android:layout_marginLeft</td>
<td></td>
<td>layout_goneMarginLeft</td>
<td></td>
</tr>
<tr>
<td>android:layout_marginTop</td>
<td></td>
<td>layout_goneMarginTop</td>
<td></td>
</tr>
<tr>
<td>android:layout_marginRight</td>
<td></td>
<td>layout_goneMarginRight</td>
<td></td>
</tr>
<tr>
<td>android:layout_marginBottom</td>
<td></td>
<td>layout_goneMarginBottom</td>
<td></td>
</tr>
<tr>
<td>android:layout_marginBaseline</td>
<td></td>
<td>layout_goneMarginBaseline</td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-3-居中和偏移百分比"><a href="#2-3-居中和偏移百分比" class="headerlink" title="2.3 居中和偏移百分比"></a>2.3 居中和偏移百分比</h5><table>
    <tr>
        <td><img src="../images/constraint/constraint_center_position.png" width="300"/></td>
        <td><img src="../images/constraint/constraint_center_position_bias.png" width="300"/></td>
    </tr>
</table>

<table>
<thead>
<tr>
<th>约束属性</th>
<th>描述</th>
<th>约束属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout_constraintHorizontal_bias</td>
<td></td>
<td>layout_constraintVertical_bias</td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-4-通过圆定位📌View"><a href="#2-4-通过圆定位📌View" class="headerlink" title="2.4 通过圆定位📌View"></a>2.4 通过圆定位📌View</h5><center>
    <img src="../images/constraint/constraint_circular_position.jpeg" width="400"/>
</center>

<table>
<thead>
<tr>
<th>约束属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout_constraintCircle</td>
<td>另一个widget的id</td>
</tr>
<tr>
<td>layout_constraintCircleRadius</td>
<td>圆的半径</td>
</tr>
<tr>
<td>layout_constraintCircleAngle</td>
<td>角度</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/buttonB&quot;</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintCircle</span>=<span class="string">&quot;@+id/buttonA&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintCircleRadius</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintCircleAngle</span>=<span class="string">&quot;45&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-通过可见性控制View"><a href="#2-5-通过可见性控制View" class="headerlink" title="2.5 通过可见性控制View"></a>2.5 通过可见性控制View</h5><center>
    <img src="../images/constraint/constraint_visibility_behavior.jpeg" width="400"/>
</center>

<h5 id="2-6-通过分辨率约束View"><a href="#2-6-通过分辨率约束View" class="headerlink" title="2.6 通过分辨率约束View"></a>2.6 通过分辨率约束View</h5><table>
<thead>
<tr>
<th>约束属性</th>
<th>描述</th>
<th>约束属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:minWidth</td>
<td></td>
<td>android:minHeight</td>
<td></td>
</tr>
<tr>
<td>android:maxWidth</td>
<td></td>
<td>android:maxHeight</td>
<td></td>
</tr>
</tbody></table>
<p>2.6.1 百分比</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/buttonA&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_default</span>=<span class="string">&quot;percent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintWidth_percent</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>app:layout_constraintWidth_default</code>可以取的值包括：</p>
<ul>
<li>spread</li>
<li>percent</li>
<li>wrap</li>
</ul>
<p>在ConstraintLayout-1.1之后，使用<code>app:layout_constrainedWidth=&quot;true&quot;</code>替代<code>app:layout_constraintWidth_default=&quot;wrap&quot;</code></p>
<p>2.6.2 比率<br>宽高一比一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/buttonA&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">&quot;1:1&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定一条边符合约束比率：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintDimensionRatio</span>=<span class="string">&quot;H,16:9&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7-通过链⛓约束View"><a href="#2-7-通过链⛓约束View" class="headerlink" title="2.7 通过链⛓约束View"></a>2.7 通过链⛓约束View</h5><table>
    <tr>
        <td><img src="../images/constraint/constraint_chain.png" width="300"/></td>
        <td><img src="../images/constraint/constraint_chain_head.png" width="300"/></td>
    </tr>
</table>

<table>
    <tr>
        <td>图示</td>
        <td>Style</td>
    </tr>
    <tr>
        <td><img src="../images/constraint/constraint_chain_spread.png" width="250"/></td>
        <td> _chainStyle="spread" </td>
    </tr>
     <tr>
      <td><img src="../images/constraint/constraint_chain_spread_inside.png" width="250"/></td>
      <td> _chainStyle="spread_inside" </td>
     </tr>
     <tr>
     <td><img src="../images/constraint/constraint_chain_weight.png" width="250"/></td>
     <td> _chainStyle="spread" <br> _weight="1" </td>
     </tr>
     <tr>
     <td><img src="../images/constraint/constraint_chain_packed.png" width="250"/></td>
     <td> _chainStyle="packed" </td>
     </tr>
     <tr>
     <td><img src="../images/constraint/constraint_chain_bias.png" width="250"/></td>
     <td> _chainStyle="packed" <br> _bias="0.3"</td>
     </tr>
</table>

<h5 id="2-8-Barrier"><a href="#2-8-Barrier" class="headerlink" title="2.8 Barrier"></a>2.8 Barrier</h5><p>将多个View的某一边的极端值作为约束：</p>
<table>
    <tr>
        <td><img src="../images/constraint/constraint_barrier_start.png" width="300"/></td>
        <td><img src="../images/constraint/constraint_barrier_end.png" width="300"/></td>
    </tr>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Barrier</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/barrier&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:barrierDirection</span>=<span class="string">&quot;start/end&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:constraint_referenced_ids</span>=<span class="string">&quot;button1,button2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-9-Group分组约束"><a href="#2-9-Group分组约束" class="headerlink" title="2.9 Group分组约束"></a>2.9 Group分组约束</h5><p>将多个View作为一个组一起控制：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Group</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/group&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:visibility</span>=<span class="string">&quot;visible&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:constraint_referenced_ids</span>=<span class="string">&quot;button4,button9&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>无法通过group设置点击事件<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">group.referencedIds.forEach &#123; id -&gt;</span><br><span class="line">     view.findViewById(id).setOnClickListener &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-10-Placeholder占位约束"><a href="#2-10-Placeholder占位约束" class="headerlink" title="2.10 Placeholder占位约束"></a>2.10 Placeholder占位约束</h5><p>&ensp;&ensp;&ensp;&ensp;Placeholder是一个虚拟的占位符View，界面上其他存在的View可以通过<code>placeholder.setContentId(R.id.xxx)</code>将自己的位置设置到placeholder的位置，原位置视图将不可见。<br>&ensp;&ensp;&ensp;&ensp;我们可以使用Placeholder搭建一个布局模板，include到其他布局当中，来填充模板中的视图，这将使所有的界面有一个通用的模板。</p>
<h5 id="2-11-Guideline引导线约束"><a href="#2-11-Guideline引导线约束" class="headerlink" title="2.11 Guideline引导线约束"></a>2.11 Guideline引导线约束</h5><p>Guideline只能在ConstraintLayout中使用，在水平或垂直方向设置辅助布局的不可见线条。</p>
<table>
<thead>
<tr>
<th>约束属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout_constraintGuide_begin</td>
<td>距布局的左边或者上边x处设置引导线</td>
</tr>
<tr>
<td>layout_constraintGuide_end</td>
<td>距布局右边或下面x处设置引导线</td>
</tr>
<tr>
<td>layout_constraintGuide_percent</td>
<td>宽或高的百分之x处设置引导线</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/guideline&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintGuide_begin</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;@+id/guideline&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h4><h5 id="3-1-解决约束问题"><a href="#3-1-解决约束问题" class="headerlink" title="3.1 解决约束问题"></a>3.1 解决约束问题</h5><p>3.1.1 定义变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x[1], x[2], ... x[n]</span><br></pre></td></tr></table></figure>
<p>3.1.2 定义约束问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[1]x[1] + ... + a[n]x[n] = b</span><br><span class="line">a[1]x[1] + ... + a[n]x[n] &lt;= b</span><br><span class="line">a[1]x[1] + ... + a[n]x[n] &gt;= b</span><br></pre></td></tr></table></figure>
<p>3.2.3 计算约束方程<br>食火鸡算法：食火鸡是一种生活在新几内亚热带雨林中的鸟类，以水果为食。同时它也是一种解决线性方程和线性不等式的算法。1990年在华盛顿大学被证明和发现。线性方程非常适合用于表示用户界面中视图的位置、大小、与其他视图的关系。</p>
<h5 id="3-2-个人理解："><a href="#3-2-个人理解：" class="headerlink" title="3.2 个人理解："></a>3.2 个人理解：</h5><p>定义变量 -&gt; 声明View对象<br>定义约束问题 -&gt; 建立View之间的约束关系<br>计算约束方程 -&gt; 计算视图的大小、坐标  </p>
<h4 id="四、参考文档"><a href="#四、参考文档" class="headerlink" title="四、参考文档"></a>四、参考文档</h4><p><a href="https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout">1.官方文档</a><br><a href="https://constraintlayout.com/layouts/">2.基本使用</a><br><a href="https://biaomingzhong.github.io/2017/constraintlayout-basics-chains-2/">3.基本使用-译文</a><br><a href="https://wiresareobsolete.com/2016/07/constraintlayout-part-1/">4.ConstraintLayout, Inside and Out: Part 1</a><br><a href="https://wiresareobsolete.com/2016/07/constraintlayout-part-2/">5.ConstraintLayout, Inside and Out: Part 2</a><br><a href="https://constraints.cs.washington.edu/cassowary/cassowary-tr.pdf">6.线性约束解决算法</a><br><a href="https://cassowary.readthedocs.io/en/latest/topics/theory.html">7.解决约束</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Admob的初始化过程</title>
    <url>/admob-init-performance-test.html</url>
    <content><![CDATA[<p>在接入Google Admob时，依据官方文档 或 依据开发习惯，我们一般先对Admob SDK进行初始化，然后进行广告加载：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first init the admob sdk</span></span><br><span class="line">MobileAds.initialize(context) &#123;</span><br><span class="line">    <span class="comment">//init successful</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//second load Ad</span></span><br><span class="line"><span class="keyword">val</span> adRequest = AdRequest.Builder().build()</span><br><span class="line">adView.loadAd(adRequest)</span><br></pre></td></tr></table></figure>

<p>那么，多思考一下，我们有个疑问：</p>
<h4 id="1、一定要先初始化，才能加载广告吗❓"><a href="#1、一定要先初始化，才能加载广告吗❓" class="headerlink" title="1、一定要先初始化，才能加载广告吗❓"></a>1、一定要先初始化，才能加载广告吗❓</h4><p>实验设计：不执行初始化操作，直接请求广告。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adRequest = AdRequest.Builder().build()</span><br><span class="line">adView.loadAd(adRequest)</span><br></pre></td></tr></table></figure>

<p>实验结论：不初始化SDK也能成功加载到广告。</p>
<h4 id="2、为什么不初始化也能加载广告呢❓"><a href="#2、为什么不初始化也能加载广告呢❓" class="headerlink" title="2、为什么不初始化也能加载广告呢❓"></a>2、为什么不初始化也能加载广告呢❓</h4><p>猜想：<br>1、初始化和加载有关联性：加载广告时，发现没有初始化，先进行了初始化，再执行广告加载操作。<br>2、初始化和加载无关联系：加载广告不需要SDK初始化，两者无关联。</p>
<p>设：广告初始化耗时m毫秒，广告加载耗时n毫秒，总耗时m+n毫秒。</p>
<p>实验设计：<br>A组：执行初始化，同时执行广告加载。<br>若初始化和加载有关联性，广告加载时长约等于m+n。<br>若初始化和加载无关联性，广告加载时长约等于n。</p>
<p>日志输出示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2024-07-06 10:10:06.061 23555-23555 InitAndLoad     com...oid.gms.example.bannerexample  D  call init....</span><br><span class="line">2024-07-06 10:10:06.224 23555-23555 InitAndLoad     com...oid.gms.example.bannerexample  D  start load....</span><br><span class="line">2024-07-06 10:10:07.401 23555-23555 InitAndLoad     com...oid.gms.example.bannerexample  D  after init = 1340</span><br><span class="line">2024-07-06 10:10:08.416 23555-23555 InitAndLoad     com...oid.gms.example.bannerexample  D  onAdLoaded...cost = 2192</span><br></pre></td></tr></table></figure>

<p>初始化耗时 m=1340ms<br>加载耗时 n=2192ms</p>
<p>B组：延迟10s执行初始化。立即执行广告加载。</p>
<p>日志输出示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2024-07-06 13:23:42.675 27481-27481 DelayInitAndLoad    com...oid.gms.example.bannerexample  D  start load....</span><br><span class="line">2024-07-06 13:23:43.453 27481-27481 DelayInitAndLoad    com...oid.gms.example.bannerexample  D  call init....</span><br><span class="line">2024-07-06 13:23:46.208 27481-27481 DelayInitAndLoad    com...oid.gms.example.bannerexample  D  onAdLoaded...cost = 3532</span><br><span class="line">2024-07-06 13:23:53.486 27481-27481 DelayInitAndLoad    com...oid.gms.example.bannerexample  D  after init = 24</span><br></pre></td></tr></table></figure>

<p>初始化耗时 m=24ms<br>加载耗时 n=3532ms</p>
<p>结论：由于广告加载成功后，才调用初始化逻辑，因此初始化时长大幅降低。故：初始化和加载有关联性。</p>
<h4 id="3、聚合的SDK初始化了吗❓"><a href="#3、聚合的SDK初始化了吗❓" class="headerlink" title="3、聚合的SDK初始化了吗❓"></a>3、聚合的SDK初始化了吗❓</h4><p>实验设计：<br>A：不初始化SDK，加载广告后，打开AdInspector。<br>B：初始化SDK，加载广告后，打开AdInspector。</p>
<table>
    <tr>
        <td><img src="../images/ad/mediator_failure.png" width="70%"/></td>
        <td><img src="../images/ad/mediator_success.png" width="70%"/></td>
    </tr>
</table>

<p>实验结论：不初始化只能加载Admob自身的广告，初始化后可以加载聚合源的广告。</p>
<h4 id="3、初始化成功后再加载广告-VS-直接加载广告-加载速度的对比"><a href="#3、初始化成功后再加载广告-VS-直接加载广告-加载速度的对比" class="headerlink" title="3、初始化成功后再加载广告 VS 直接加载广告 加载速度的对比"></a>3、初始化成功后再加载广告 VS 直接加载广告 加载速度的对比</h4><p>直接加载：</p>
<table>
<thead>
<tr>
<th>第一组</th>
<th>第二组</th>
<th>第三组</th>
<th>第四组</th>
<th>第五组</th>
</tr>
</thead>
<tbody><tr>
<td>2915ms</td>
<td>1581ms</td>
<td>1435ms</td>
<td>1621ms</td>
<td>1581ms</td>
</tr>
</tbody></table>
<p>初始化后加载：</p>
<table>
<thead>
<tr>
<th></th>
<th>第一组</th>
<th>第二组</th>
<th>第三组</th>
<th>第四组</th>
<th>第五组</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>2373ms</td>
<td>2374</td>
<td>2463</td>
<td>2427</td>
<td>2298</td>
</tr>
<tr>
<td>加载</td>
<td>1468ms</td>
<td>1386</td>
<td>1505</td>
<td>2498</td>
<td>1250</td>
</tr>
<tr>
<td>日志总耗时</td>
<td>3843</td>
<td>3762</td>
<td>3970</td>
<td>4927</td>
<td>3550</td>
</tr>
</tbody></table>
<p>结论：初始化后才加载广告慢于直接加载广告。</p>
<h4 id="4、一种开屏广告的优化方案"><a href="#4、一种开屏广告的优化方案" class="headerlink" title="4、一种开屏广告的优化方案"></a>4、一种开屏广告的优化方案</h4><p>不初始化SDK也能加载到Admob广告，且加载速度较快，但是没有参与bidding，价格较低。<br>初始化之后，加载聚合源广告，速度较慢，但经过bidding后，价格会高一点。</p>
<p>结合两个加载方式，闪屏时段内加载广告，闪屏n秒时长内，加载到bidding类型则展示bidding类型。没加载到，则展示Admob类型。</p>
]]></content>
  </entry>
  <entry>
    <title>源码分析-网络框架之Retrofit</title>
    <url>/android-github-source-retrofit.html</url>
    <content><![CDATA[<h4 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h4><h5 id="1-1-定义API方法"><a href="#1-1-定义API方法" class="headerlink" title="1.1 定义API方法"></a>1.1 定义API方法</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RemoteApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">&quot;timeline&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">timeline</span><span class="params">()</span></span>: RemoteLaunchesResponse </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-2-获取服务"><a href="#1-2-获取服务" class="headerlink" title="1.2 获取服务"></a>1.2 获取服务</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">             .addInterceptor(loggingInterceptor)</span><br><span class="line">             .build()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">             .client(client)</span><br><span class="line">             .baseUrl(<span class="string">&quot;http://10.0.0.2:8080/&quot;</span>)</span><br><span class="line">             .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">             .build()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">val</span> api = retrofit.create(RemoteApi::<span class="keyword">class</span>.java) <span class="comment">//1、create做了什么？</span></span><br></pre></td></tr></table></figure>

<h5 id="1-3-发起请求"><a href="#1-3-发起请求" class="headerlink" title="1.3 发起请求"></a>1.3 发起请求</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">api.timeline() <span class="comment">//2、调用接口方法怎么发起请求?</span></span><br></pre></td></tr></table></figure>


<h4 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h4><center>
    <img src="../images/android-source-retrofit.jpeg" width="100%"/>
</center>

<h5 id="2-1-create做了什么"><a href="#2-1-create做了什么" class="headerlink" title="2.1 create做了什么"></a>2.1 create做了什么</h5><p>Retrofit的网络请求方法都是定义在接口中的，它会在运行时利用Java的动态代理产生代理对象，所以<code>create()</code>就是创建代理对象的方法。</p>
<h5 id="2-2-调用接口方法怎么发起请求"><a href="#2-2-调用接口方法怎么发起请求" class="headerlink" title="2.2 调用接口方法怎么发起请求"></a>2.2 调用接口方法怎么发起请求</h5><p>当调用接口方法时，实际上是调用了代理对象的方法。它会去Retrofit中找该方法对应的<code>ServiceMethod</code>，如果找到缓存直接使用，否则解析后再使用。</p>
<p>解析的结果是<code>ServiceMethod</code>的子类<code>CallAdapted</code>、<code>SuspendForResponse</code>、<code>SuspendForBody</code>三者之一。</p>
<p>解析结束后调用返回对象的<code>invoke</code>方法初始化OkHttpCall对象发起真正的请求。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>阅读源码的过程当中，画了详细的代码执行流程图供后续回顾。另外源码中还有两个重要的对外拓展接口<code>CallAdapter</code>和<code>Converter</code>没有详细分析。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安卓框架</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析-项目架构之SpaceX</title>
    <url>/android-github-source-spacex.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>此文是对Github开源项目<a href="https://github.com/ferPrieto/SpaceX-prepare-for-Clean-Architecture-liftoff">SpaceX-prepare-for-Clean-Architecture-liftoff</a> 的源码阅读记录。它是一个为了阐述对<strong>Clean Architecture</strong>的理解而作的Demo项目，是一个值得学习的项目。</p>
<h4 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h4><h5 id="2-1-模块之间的依赖关系"><a href="#2-1-模块之间的依赖关系" class="headerlink" title="2.1 模块之间的依赖关系"></a>2.1 模块之间的依赖关系</h5><p>项目包含以下library：</p>
<ul>
<li>app</li>
<li>buildSrc</li>
<li>core</li>
<li>core-android-test</li>
<li>data</li>
<li>data-api</li>
<li>domain</li>
<li>navigation</li>
<li>presentation</li>
</ul>
<p>模块之间的依赖关系可用下图简述：</p>
<center>
    <img src="../images/android-source-spacex.jpeg" width="500"/>
</center>

<h5 id="2-2-类和模块之间的关系"><a href="#2-2-类和模块之间的关系" class="headerlink" title="2.2 类和模块之间的关系"></a>2.2 类和模块之间的关系</h5><center>
    <img src="../images/android-source-spacex-overview.jpeg" width="600"/>
</center>


<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>项目重在阐述架构思想所以比较简单，其中很多东西值得我们在项目中借鉴。数据层的架构模式参看<a href="https://martinfowler.com/bliki/PresentationDomainDataLayering.html">martin fowler</a> 的文章。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose Side Effects</title>
    <url>/android-jetpack-compose-sideeffect.html</url>
    <content><![CDATA[<h4 id="一、什么是Side-Effect"><a href="#一、什么是Side-Effect" class="headerlink" title="一、什么是Side-Effect"></a>一、什么是Side-Effect</h4><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">wiki</a>:在计算机科学中，当函数、表达式、操作会修改它作用域之外的状态变量值时，我们就说它具有副作用。也就是说除返回值之外其他的对外修改都叫副作用。<br>常见的例子包括：修改非本地变量、修改参数传进来的可变引用、执行I/O等。</p>
</blockquote>
<h4 id="二、Compose中的Side-Effect"><a href="#二、Compose中的Side-Effect" class="headerlink" title="二、Compose中的Side-Effect"></a>二、Compose中的Side-Effect</h4><p>因为Jetpack Compose是由一系列的<code>@Composable</code>函数组成的，<code>@Composable</code>函数在执行时可能会被跳过（出于优化的角度）或执行多次（recomposition）。<br>那对于函数内部的网络请求、对外部状态的修改怎么办？有可能执行多次？有可能不执行？这就产生了某种不可预期的错误状态，或者泄露。<br>为了解决此类问题，Compose提供了相应的API，这些API主要聚焦于对这些副作用的生命周期进行管理。</p>
<p>这些API可以分成两大类：</p>
<ul>
<li>SuspendedEffect<ul>
<li>rememberCoroutineScope</li>
<li>launchedEffect</li>
</ul>
</li>
<li>Non-Suspended Side Effects<ul>
<li>DisposableEffect</li>
<li>SideEffect</li>
</ul>
</li>
</ul>
<h4 id="三、SuspendedEffect"><a href="#三、SuspendedEffect" class="headerlink" title="三、SuspendedEffect"></a>三、SuspendedEffect</h4><h5 id="3-1-LaunchedEffect"><a href="#3-1-LaunchedEffect" class="headerlink" title="3.1 LaunchedEffect"></a>3.1 LaunchedEffect</h5><p>在首次composition的时候被调用。recomposition时不会再次调用。可以通过改变Key让其重新调用。<br>它是一个协程作用域，我们可以执行一些挂起函数，当composable函数退出时，协程会被取消。</p>
<p>下面的例子中，启动即执行循环逻辑，每秒修改一次状态值并触发recomposition，但recomposition并不影响LaunchedEffect内的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LaunchedEffect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timer <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    Box(modifier = Modifier.fillMaxSize(), </span><br><span class="line">        contentAlignment = Alignment.Center) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Time <span class="variable">$timer</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LaunchedEffect(key1 = <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            timer++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-RememberCoroutineScope"><a href="#3-2-RememberCoroutineScope" class="headerlink" title="3.2 RememberCoroutineScope"></a>3.2 RememberCoroutineScope</h5><p><code>LaunchedEffect</code>的启动和取消跟随Composable函数的生命周期。如果想自己控制生命周期可以使用<code>RememberCoroutineScope</code></p>
<p>下面的例子中，协程的控制权转移到我们自己手中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">JustRememberCoroutineScope</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line">    <span class="keyword">var</span> timer <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> timerStartStop <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> job: Job? <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">null</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Box(modifier = Modifier.fillMaxSize(),</span><br><span class="line">        contentAlignment = Alignment.Center) &#123;</span><br><span class="line">        Column(horizontalAlignment = Alignment.CenterHorizontally) &#123;</span><br><span class="line">            Text(<span class="string">&quot;Time <span class="variable">$timer</span>&quot;</span>)</span><br><span class="line">            Button(onClick = &#123;</span><br><span class="line">                timerStartStop = !timerStartStop</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timerStartStop) &#123;</span><br><span class="line">                    job?.cancel()</span><br><span class="line">                    job = scope.launch &#123;</span><br><span class="line">                        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                            delay(<span class="number">1000</span>)</span><br><span class="line">                            timer++</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    job?.cancel()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;) &#123;</span><br><span class="line">                Text(<span class="keyword">if</span> (timerStartStop) <span class="string">&quot;Stop&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Start&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、Non-Suspended-Side-Effects"><a href="#四、Non-Suspended-Side-Effects" class="headerlink" title="四、Non-Suspended Side Effects"></a>四、Non-Suspended Side Effects</h4><h5 id="4-1-DisposableEffect"><a href="#4-1-DisposableEffect" class="headerlink" title="4.1 DisposableEffect"></a>4.1 DisposableEffect</h5><p>与<code>LaunchedEffect</code>一样，立即启动，通过修改key可以再次启动。它提供了一个销毁时的回调，当再次启动时，前一个的<code>onDispose</code>方法会被回调。</p>
<p>下面的例子每次点击按钮改变状态进行recompose，同时会改变<code>DisposableEffect</code>的key，销毁上一个Effect并收到回调。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">JustDisposableEffect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timerStartStop <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    Box(modifier = Modifier.fillMaxSize(),</span><br><span class="line">        contentAlignment = Alignment.Center) &#123;</span><br><span class="line">        Column(horizontalAlignment = Alignment.CenterHorizontally) &#123;</span><br><span class="line">            Button(onClick = &#123;</span><br><span class="line">                timerStartStop = !timerStartStop</span><br><span class="line">            &#125;) &#123;</span><br><span class="line">                Text(<span class="keyword">if</span> (timerStartStop) <span class="string">&quot;Stop&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Start&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line"></span><br><span class="line">    DisposableEffect(key1 = timerStartStop) &#123;</span><br><span class="line">        <span class="keyword">val</span> x = (<span class="number">1.</span><span class="number">.10</span>).random()</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;Start <span class="variable">$x</span>&quot;</span>, LENGTH_SHORT).show()</span><br><span class="line"></span><br><span class="line">        onDispose &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;Stop <span class="variable">$x</span>&quot;</span>, LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-SideEffect"><a href="#4-2-SideEffect" class="headerlink" title="4.2 SideEffect"></a>4.2 SideEffect</h5><p>使用场景：</p>
<ul>
<li>每次composition / recomposition成功后被调用</li>
<li>用于对外部状态的更新</li>
<li>无需做清理回收操作时</li>
</ul>
<p>例1：对外部状态的更新</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyScreen</span><span class="params">(drawerTouchHandler: <span class="type">TouchHandler</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> drawerState = rememberDrawerState(DrawerValue.Closed)</span><br><span class="line"></span><br><span class="line">  SideEffect &#123;</span><br><span class="line">    drawerTouchHandler.enabled = drawerState.isOpen</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyComposable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SideEffect &#123; <span class="comment">//this will handle the side effect that may occur</span></span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    Button(onClick = &#123;&#125;)&#123;</span><br><span class="line">        Text(text = <span class="string">&quot;Click&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h4><p><a href="https://jorgecastillo.dev/jetpack-compose-effect-handlers">Jetpack Compose Effect Handlers</a><br><a href="https://www.section.io/engineering-education/side-effects-and-effects-handling-in-jetpack-compose/">SideEffects and Effects Handling in Jetpack Compose</a><br><a href="https://medium.com/mobile-app-development-publication/jetpack-compose-side-effects-made-easy-a4867f876928">Jetpack Compose Side Effects Made Easy</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Compose</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析-WorkManager</title>
    <url>/android-github-source-workmanager.html</url>
    <content><![CDATA[<h4 id="一、初始化流程"><a href="#一、初始化流程" class="headerlink" title="一、初始化流程"></a>一、初始化流程</h4><p>1、WorkManager集成了<code>androidx.startup</code> 库，通过<code>startup</code>库的<code>ContentProvider</code>在应用启动时进行初始化。<br>见<code>work-runtime</code>的Manifest文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;androidx.work.WorkManagerInitializer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其初始化类为<code>WorkManagerInitializer</code>，其中调用了<code>WorkManager#initialize</code>，然后调用<code>WorkManager</code>的构造函数。<br>整个流程初始化了如下一些对象：</p>
<center>
    <img src="../images/android-workmanager_init.jpg" width="100%"/>
</center>


<h4 id="二、任务"><a href="#二、任务" class="headerlink" title="二、任务"></a>二、任务</h4><h5 id="2-1-定义任务"><a href="#2-1-定义任务" class="headerlink" title="2.1 定义任务"></a>2.1 定义任务</h5><p>当我们自定义任务时，需要继承<code>Work</code>类，WorkManager内部对<code>Work</code>的结构定义如下：</p>
<center>
    <img src="../images/android-workmanager-work.jpg" width="40%"/>
</center>

<p>其中<code>DiagnosticsWorker</code>和<code>CombineContinueationsWorker</code>是内部使用的两个任务。</p>
<h5 id="2-2-提交任务"><a href="#2-2-提交任务" class="headerlink" title="2.2 提交任务"></a>2.2 提交任务</h5><p>我们将任务以请求（WorkRequest）的形式提交（enqueue）给WorkManager。WorkManager会将请求装换成内部的WorkContinuation对象。</p>
<center>
    <img src="../images/android-workmanager-request.jpg" width="70%"/>
</center>

<p>WorkContinuation可以将多个<code>OneTimeWorkrequest</code>构建成任意依赖关系的无环图。而WorkContinuation的<code>enqueue</code>方法则是任务被执行调度的入口。</p>
<h5 id="2-3-执行任务"><a href="#2-3-执行任务" class="headerlink" title="2.3 执行任务"></a>2.3 执行任务</h5><p>对任务进行不同的操作，如：取消、结束、开始等。WorkManager内部会将这些行为转换成对应的Runnable交给调度系统进行执行。</p>
<center>
    <img src="../images/android-workmanager-action.jpg" width="70%"/>
</center>


<h4 id="三、任务的调度"><a href="#三、任务的调度" class="headerlink" title="三、任务的调度"></a>三、任务的调度</h4><p>提交给WorkManager的任务，会封装成<code>EnqueueRunnable</code>交给默认的<code>SerialExecutor</code>去执行。<br><code>EnqueueRunnable</code>的run方法会先将任务加入数据库中保存。然后进行任务调度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWorkContinuation.hasCycles()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    String.format(<span class="string">&quot;WorkContinuation has cycles (%s)&quot;</span>, mWorkContinuation));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入数据库</span></span><br><span class="line">        <span class="keyword">boolean</span> needsScheduling = addToDatabase();</span><br><span class="line">        <span class="keyword">if</span> (needsScheduling) &#123;</span><br><span class="line">            <span class="comment">// Enable RescheduleReceiver, only when there are Worker&#x27;s that need scheduling.</span></span><br><span class="line">            <span class="keyword">final</span> Context context =</span><br><span class="line">                    mWorkContinuation.getWorkManagerImpl().getApplicationContext();</span><br><span class="line">            PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.class, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//进行任务调度</span></span><br><span class="line">            scheduleWorkInBackground();</span><br><span class="line">        &#125;</span><br><span class="line">        mOperation.setState(Operation.SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable exception) &#123;</span><br><span class="line">        mOperation.setState(<span class="keyword">new</span> Operation.State.FAILURE(exception));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><h5 id="4-1-任务的约束"><a href="#4-1-任务的约束" class="headerlink" title="4.1 任务的约束"></a>4.1 任务的约束</h5><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>WorkManager库并不算复杂。这种对任务的管理和调度框架的源码，我们可以多看，学习一下里面的设计思路。有个大概的印象，后续写相关逻辑时可以借鉴。</p>
<ul>
<li>借助<code>startup</code>初始化你的框架</li>
<li>构建有依赖关系的任务</li>
<li>通过Runnable解耦任务的请求和执行。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>android jetpack startup</title>
    <url>/android-jetpack-startup.html</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:startup/">源码</a></p>
<p>startup库是一个极简启动优化库，可以解决启动中的依赖顺序问题。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>1.1 实现Initializer接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggerInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Logger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(context: <span class="type">Context</span>)</span></span>: Logger &#123;</span><br><span class="line">        Logger.<span class="keyword">init</span>(context)</span><br><span class="line">        <span class="keyword">return</span> Logger</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 AndroidManifest.xml中声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span>&gt;</span></span><br><span class="line">    android:name=&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    tools:node=&quot;merge&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;me.xxx.demo.LoggerInitializer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>1、默认由ContentProvider onCreate中获取AppInitializer<strong>单例</strong><br>2、调用AppInitializer单例的discoverAndInitialize，<strong>解析Manifest</strong>里面的mate<br>3、解析完后放入Set&lt;Class<? extends Initializer<?>&gt;&gt;中<br>4、遍历Set，调用doInitialize进行初始化<br>    4.1 检查循环依赖问题<br>    4.2 找到此项的所有依赖项，递归调用doInitialize<br>    4.3 此项依赖初始化完成</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不支持线程控制和等待</li>
</ul>
<h4 id="其他相关库"><a href="#其他相关库" class="headerlink" title="其他相关库"></a>其他相关库</h4><p><a href="https://github.com/idisfkj/android-startup">android-startup</a></p>
]]></content>
  </entry>
  <entry>
    <title>Jetpack Compose State Management</title>
    <url>/android-jetpack-compose-state-management.html</url>
    <content><![CDATA[<p>–</p>
<center>
    <img src="../images/ui-equals-function-of-state.png" width="100%"/>
</center>

<h4 id="一、什么是状态"><a href="#一、什么是状态" class="headerlink" title="一、什么是状态"></a>一、什么是状态</h4><blockquote>
<p>状态是一些被View、Widget订阅或观察的对象，它包含数据。任何状态（数据）的变化都会通知给观察它的View、Widget。</p>
</blockquote>
<ul>
<li>网络断开时展示的Toast</li>
<li>发布的博客及其评论</li>
<li>点击按钮时的水波纹动画</li>
</ul>
<h4 id="二、Compose中的状态"><a href="#二、Compose中的状态" class="headerlink" title="二、Compose中的状态"></a>二、Compose中的状态</h4><h5 id="2-1-记住状态"><a href="#2-1-记住状态" class="headerlink" title="2.1 记住状态"></a>2.1 记住状态</h5><p>Composable函数可以使用<code>remember</code>在初始化时存储一个对象到内存中。每次recomposition时这个对象都会被返回。</p>
<h5 id="2-2-可观察状态"><a href="#2-2-可观察状态" class="headerlink" title="2.2 可观察状态"></a>2.2 可观察状态</h5><p><code>mutableStateOf</code>函数可以创建一个可观察的可变数据，此数据的变化将触发recomposition</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MySwitch</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// I have a State in Compose&#x27;s MutableState</span></span><br><span class="line">   <span class="keyword">val</span> checked = remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">   Switch(</span><br><span class="line">       <span class="comment">// Observe the State by accessing the value property</span></span><br><span class="line">       checked = checked.value,</span><br><span class="line">       onCheckedChange = &#123;</span><br><span class="line">           checked.value = it</span><br><span class="line">       &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-其他状态类型"><a href="#2-3-其他状态类型" class="headerlink" title="2.3 其他状态类型"></a>2.3 其他状态类型</h5><p>除了使用<code>MutableState&lt;T&gt;</code>持有状态外，你还可以使用以下这些可观察数据类型来维护状态。</p>
<ul>
<li>LiveData</li>
<li>Flow</li>
<li>RxJava2</li>
</ul>
<p>但是，在使用时需要将其转成<code>State&lt;T&gt;</code>类型</p>
<ul>
<li><code>LiveData&lt;T&gt;.observeAsState()</code></li>
<li><code>Flow&lt;T&gt;.collectAsState()</code></li>
</ul>
<h5 id="2-4-stateless"><a href="#2-4-stateless" class="headerlink" title="2.4 stateless"></a>2.4 stateless</h5><p>在Composable函数中保存状态将降低它的可复用性，通过将状态向外抽离来增加其复用性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    HelloContent(name = name, onNameChange = &#123; name = it &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">(name: <span class="type">String</span>, onNameChange: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>,</span><br><span class="line">            modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">            style = MaterialTheme.typography.h5</span><br><span class="line">        )</span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = onNameChange,</span><br><span class="line">            label = &#123; Text(<span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-状态恢复"><a href="#2-5-状态恢复" class="headerlink" title="2.5 状态恢复"></a>2.5 状态恢复</h5><p>当Activity重建时，想要保留状态，并在重建后恢复状态，可以使用<code>rememberSaveable</code>将状态保存到Bundle中。</p>
<ul>
<li>Parcelize</li>
<li>MapSaver</li>
<li>ListSaver</li>
</ul>
<h4 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h4><p><a href="https://developer.android.com/jetpack/compose/state#state-in-composables">State and Jetpack Compose</a><br><a href="https://medium.com/@takahirom/jetpack-compose-state-guideline-494d467b6e76">Jetpack Compose State Guideline</a><br><a href="https://levelup.gitconnected.com/managing-state-in-android-f4d042646521">Managing State in Android</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的日志库</title>
    <url>/android-library-log.html</url>
    <content><![CDATA[<p>日志库是一个项目的基础功能之一，它应该包括但不限于以下功能：</p>
<ul>
<li>扩展性：支持把日志记录到多个地方，如：本地文件、控制台、崩溃系统。</li>
<li>高性能：日志记录较为频繁时，如何写文件，提高性能。</li>
<li>稳定性：崩溃前一刻的日志不丢失。</li>
</ul>
<p>以下是一些开源的日志库，做一个记录：</p>
<ul>
<li><a href="https://github.com/pqpo/Log4a">Log4a</a> 0.9k star</li>
</ul>
<p>基于 mmap, 高性能、高可用的 Android 日志收集框架</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Log4a.i(TAG, &quot;Hello，Log4a!&quot;);</span><br><span class="line">Log4a.flush();</span><br><span class="line">Log4a.release();</span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://github.com/elvishew/xLog">xLog</a> 3.1k star</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    LogConfiguration config = <span class="keyword">new</span> LogConfiguration.Builder()</span><br><span class="line">        .logLevel(BuildConfig.DEBUG ? LogLevel.ALL             <span class="comment">// Specify log level, logs below this level won&#x27;t be printed, default: LogLevel.ALL</span></span><br><span class="line">            : LogLevel.NONE)</span><br><span class="line">        .tag(<span class="string">&quot;MY_TAG&quot;</span>)                                         <span class="comment">// Specify TAG, default: &quot;X-LOG&quot;</span></span><br><span class="line">        .enableThreadInfo()                                    <span class="comment">// Enable thread info, disabled by default</span></span><br><span class="line">        .enableStackTrace(<span class="number">2</span>)                                   <span class="comment">// Enable stack trace info with depth 2, disabled by default</span></span><br><span class="line">        .enableBorder()                                        <span class="comment">// Enable border, disabled by default</span></span><br><span class="line">        .jsonFormatter(<span class="keyword">new</span> MyJsonFormatter())                  <span class="comment">// Default: DefaultJsonFormatter</span></span><br><span class="line">        .xmlFormatter(<span class="keyword">new</span> MyXmlFormatter())                    <span class="comment">// Default: DefaultXmlFormatter</span></span><br><span class="line">        .throwableFormatter(<span class="keyword">new</span> MyThrowableFormatter())        <span class="comment">// Default: DefaultThrowableFormatter</span></span><br><span class="line">        .threadFormatter(<span class="keyword">new</span> MyThreadFormatter())              <span class="comment">// Default: DefaultThreadFormatter</span></span><br><span class="line">        .stackTraceFormatter(<span class="keyword">new</span> MyStackTraceFormatter())      <span class="comment">// Default: DefaultStackTraceFormatter</span></span><br><span class="line">        .borderFormatter(<span class="keyword">new</span> MyBoardFormatter())               <span class="comment">// Default: DefaultBorderFormatter</span></span><br><span class="line">        .addObjectFormatter(AnyClass.class,                    <span class="comment">// Add formatter for specific class of object</span></span><br><span class="line">            <span class="keyword">new</span> AnyClassObjectFormatter())                     <span class="comment">// Use Object.toString() by default</span></span><br><span class="line">        .addInterceptor(<span class="keyword">new</span> BlacklistTagsFilterInterceptor(    <span class="comment">// Add blacklist tags filter</span></span><br><span class="line">            <span class="string">&quot;blacklist1&quot;</span>, <span class="string">&quot;blacklist2&quot;</span>, <span class="string">&quot;blacklist3&quot;</span>))</span><br><span class="line">        .addInterceptor(<span class="keyword">new</span> MyInterceptor())                   <span class="comment">// Add other log interceptor</span></span><br><span class="line">        .build();</span><br><span class="line">    </span><br><span class="line">    Printer androidPrinter = <span class="keyword">new</span> AndroidPrinter(<span class="keyword">true</span>);         <span class="comment">// Printer that print the log using android.util.Log</span></span><br><span class="line">    Printer consolePrinter = <span class="keyword">new</span> ConsolePrinter();             <span class="comment">// Printer that print the log to console using System.out</span></span><br><span class="line">    Printer filePrinter = <span class="keyword">new</span> FilePrinter                      <span class="comment">// Printer that print(save) the log to file</span></span><br><span class="line">        .Builder(<span class="string">&quot;&lt;path-to-logs-dir&gt;&quot;</span>)                         <span class="comment">// Specify the directory path of log file(s)</span></span><br><span class="line">        .fileNameGenerator(<span class="keyword">new</span> DateFileNameGenerator())        <span class="comment">// Default: ChangelessFileNameGenerator(&quot;log&quot;)</span></span><br><span class="line">        .backupStrategy(<span class="keyword">new</span> NeverBackupStrategy())             <span class="comment">// Default: FileSizeBackupStrategy(1024 * 1024)</span></span><br><span class="line">        .cleanStrategy(<span class="keyword">new</span> FileLastModifiedCleanStrategy(MAX_TIME))     <span class="comment">// Default: NeverCleanStrategy()</span></span><br><span class="line">        .flattener(<span class="keyword">new</span> MyFlattener())                          <span class="comment">// Default: DefaultFlattener</span></span><br><span class="line">        .writer(<span class="keyword">new</span> MyWriter())                                <span class="comment">// Default: SimpleWriter</span></span><br><span class="line">        .build();</span><br><span class="line">    </span><br><span class="line">    XLog.init(                                                 <span class="comment">// Initialize XLog</span></span><br><span class="line">        config,                                                <span class="comment">// Specify the log configuration, if not specified, will use new LogConfiguration.Builder().build()</span></span><br><span class="line">        androidPrinter,                                        <span class="comment">// Specify printers, if no printer is specified, AndroidPrinter(for Android)/ConsolePrinter(for java) will be used.</span></span><br><span class="line">        consolePrinter,</span><br><span class="line">        filePrinter);</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">+ [logger](https:<span class="comment">//github.com/orhanobut/logger) 13.7k star</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder()</span><br><span class="line">      .showThreadInfo(<span class="keyword">false</span>)  <span class="comment">// (Optional) Whether to show thread info or not. Default true</span></span><br><span class="line">      .methodCount(<span class="number">0</span>)         <span class="comment">// (Optional) How many method line to show. Default 2</span></span><br><span class="line">      .methodOffset(<span class="number">7</span>)        <span class="comment">// (Optional) Hides internal method calls up to offset. Default 5</span></span><br><span class="line">      .logStrategy(customLog) <span class="comment">// (Optional) Changes the log strategy to print out. Default LogCat</span></span><br><span class="line">      .tag(<span class="string">&quot;My custom tag&quot;</span>)   <span class="comment">// (Optional) Global tag for every log. Default PRETTY_LOGGER</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">    Logger.addLogAdapter(<span class="keyword">new</span> AndroidLogAdapter(formatStrategy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Room数据库酷七条</title>
    <url>/android-library-room-7-tips.html</url>
    <content><![CDATA[<h4 id="一、通过RoomDatabase-Callback预填充数据"><a href="#一、通过RoomDatabase-Callback预填充数据" class="headerlink" title="一、通过RoomDatabase#Callback预填充数据"></a>一、通过<code>RoomDatabase#Callback</code>预填充数据</h4><p>如果需要在数据库创建或数据库打开的时候添加一些默认数据，可以使用<code>RoomDatabase#Callback</code>接口并复写它的<code>onCreate</code>或<code>onOpen</code>方法。由于DAO对象只能在这两个方法返回后使用，所以我们创建一个新线程来插入数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Room.databaseBuilder(context.applicationContext,</span><br><span class="line">        DataDatabase::<span class="keyword">class</span>.java, <span class="string">&quot;Sample.db&quot;</span>)</span><br><span class="line">        <span class="comment">// prepopulate the database after onCreate was called</span></span><br><span class="line">        .addCallback(<span class="keyword">object</span> : Callback() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onCreate(db)</span><br><span class="line">                <span class="comment">// moving to a new thread</span></span><br><span class="line">                ioThread &#123;</span><br><span class="line">                    getInstance(context).dataDao()</span><br><span class="line">                                        .insert(PREPOPULATE_DATA)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：当app首次启动时，在create和insert之间崩溃的话，数据将永远不会被插入。</p>
<h4 id="二、使用DAO的继承能力"><a href="#二、使用DAO的继承能力" class="headerlink" title="二、使用DAO的继承能力"></a>二、使用DAO的继承能力</h4><p>很多DAO里存在一样的<code>Insert</code>、<code>Update</code>、<code>Delete</code>方法。我们可以使用继承来避免这些重复的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseDao</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(<span class="keyword">vararg</span> obj: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataDao</span> : <span class="type">BaseDao</span>&lt;<span class="type">Data</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM Data&quot;</span>)</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: List&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="三、通过-Transaction减少事务查询的模板代码"><a href="#三、通过-Transaction减少事务查询的模板代码" class="headerlink" title="三、通过@Transaction减少事务查询的模板代码"></a>三、通过<code>@Transaction</code>减少事务查询的模板代码</h4><p>用<code>@Transaction</code>注解的方法会在一个事务里面执行。当这些方法执行异常时，事务也会失败。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateData</span><span class="params">(users: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span> &#123;</span><br><span class="line">        deleteAllUsers()</span><br><span class="line">        insertAll(users)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertAll</span><span class="params">(users: <span class="type">List</span>&lt;<span class="type">User</span>&gt;)</span></span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;DELETE FROM Users&quot;</span>)</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteAllUsers</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>@Query</code>方法带有select语句时，在下列情况下你可能会使用<code>@Transation</code>注解</p>
<ul>
<li>当查询的结果集很大时，让查询在一次事务里完成能够保证：如果查询结果不满足单个游标窗口，它不会因为在游标窗口交换之间的数据库更改而中断。</li>
<li>如果查询结果是一个带<code>@Relation</code>字段的POJO，此字段会单独查询，所以让他们运行在一个事务中可以确保结果一致。</li>
</ul>
<p><code>Delete</code>、<code>Update</code>、<code>Insert</code>方法包含多个参数时会自动在事务里执行。</p>
<h4 id="四、只读需要的数据"><a href="#四、只读需要的数据" class="headerlink" title="四、只读需要的数据"></a>四、只读需要的数据</h4><p>关注App的内存消耗，只加载需要使用的字段，这能提高查询速度减少IO消耗。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">&quot;users&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="meta">@PrimaryKey</span></span><br><span class="line">                <span class="keyword">val</span> id: String,</span><br><span class="line">                <span class="keyword">val</span> userName: String,</span><br><span class="line">                <span class="keyword">val</span> firstName: String, </span><br><span class="line">                <span class="keyword">val</span> lastName: String,</span><br><span class="line">                <span class="keyword">val</span> email: String,</span><br><span class="line">                <span class="keyword">val</span> dateOfBirth: Date, </span><br><span class="line">                <span class="keyword">val</span> registrationDate: Date)</span><br></pre></td></tr></table></figure>

<p>上面的类中，很多字段我们用不到，定义一个类，只包含我们需要的字段：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMinimal</span></span>(<span class="keyword">val</span> userId: String,</span><br><span class="line">                       <span class="keyword">val</span> firstName: String, </span><br><span class="line">                       <span class="keyword">val</span> lastName: String)</span><br></pre></td></tr></table></figure>

<p>在DAO中，定义方法只查询所需字段：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query(“SELECT userId, firstName, lastName FROM Users)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUsersMinimal</span><span class="params">()</span></span>: List&lt;UserMinimal&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、使用外键"><a href="#五、使用外键" class="headerlink" title="五、使用外键"></a>五、使用外键</h4><p>即使Room不直接支持关系，但它允许你定义外键来约束实体之间的关系。</p>
<p>Room的<code>@ForeignKey</code>是<code>@Entity</code>注解的一部分，用来支持Sqlite的外键特性。它强制表之间的约束，当你修改表时，保证关系一致性。</p>
<p>看一下<code>User</code>和<code>Pet</code>类，<code>Pet</code>有主人，以userId关联。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">&quot;pets&quot;</span>,</span></span><br><span class="line"><span class="meta">        foreignKeys = arrayOf(</span></span><br><span class="line"><span class="meta">            ForeignKey(entity = User::class,</span></span><br><span class="line"><span class="meta">                       parentColumns = arrayOf(<span class="meta-string">&quot;userId&quot;</span>)</span>,</span><br><span class="line">                       childColumns = arrayOf(<span class="string">&quot;owner&quot;</span>))))</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>(<span class="meta">@PrimaryKey</span> <span class="keyword">val</span> petId: String,</span><br><span class="line">              <span class="keyword">val</span> name: String,</span><br><span class="line">              <span class="keyword">val</span> owner: String)</span><br></pre></td></tr></table></figure>

<p>你可以定义一些行为，当例子中的<code>User</code>在数据库中被删除或修改。你可以做以下一些操作：<code>NO_ACTION</code>、<code>RESTRICT</code>、<code>SET_NULL</code>、<code>SET_DEFAULT</code>或<code>CASCADE</code>，这些操作和Sqlite保持一致。</p>
<p><strong>注意：</strong> 在Room中<code>SET_DEFAULT</code>和<code>SET_NULL</code>效果一致，因为Room还不允许为数据列设置默认值。</p>
<h4 id="六、使用-Relation简化一对多查询"><a href="#六、使用-Relation简化一对多查询" class="headerlink" title="六、使用@Relation简化一对多查询"></a>六、使用<code>@Relation</code>简化一对多查询</h4><p>在前面<code>User-Pet</code>的例子中，我们有个一对多的关系，一个人可以有多个宠物。当我们想获取主人和宠物集合时：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAndAllPets</span> </span>(<span class="keyword">val</span> user: User,</span><br><span class="line">                           <span class="keyword">val</span> pets: List&lt;Pet&gt; = ArrayList())</span><br></pre></td></tr></table></figure>

<p>需要两个查询：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(“SELECT * FROM Users”)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; getUsers();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(“SELECT * FROM Pets where owner = :userId”)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Pet&gt; getPetsForUser(String userId);</span><br></pre></td></tr></table></figure>

<p>我们需要遍历用户来查宠物。</p>
<p>为了简化此过程，Room的<code>@Relation</code>注解自动关联实体。此注解只能用于<code>List</code>和<code>Set</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAndAllPets</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Embedded</span></span><br><span class="line">   <span class="keyword">var</span> user: User? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Relation(parentColumn = “userId”,</span></span><br><span class="line"><span class="meta">             entityColumn = “owner”)</span></span><br><span class="line">   <span class="keyword">var</span> pets: List&lt;Pet&gt; = ArrayList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DAO中，我们定义一次查询：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="meta">@Query(“SELECT * FROM Users”)</span></span><br><span class="line">List&lt;UserAndAllPets&gt; getUsers();</span><br></pre></td></tr></table></figure>


<h4 id="七、避免可观察查询的假通知"><a href="#七、避免可观察查询的假通知" class="headerlink" title="七、避免可观察查询的假通知"></a>七、避免可观察查询的假通知</h4><p>可观察查询，只关心对应ID的对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(“SELECT * FROM Users WHERE userId = :id)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserById</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(“SELECT * FROM Users WHERE userId = :id)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserById</span><span class="params">(id: <span class="type">String</span>)</span></span>: Flowable&lt;User&gt;</span><br></pre></td></tr></table></figure>

<p>每次此用户更新的时候你都得到一个新通知。但是其他的一些不影响此ID的修改（delete、update、insert）会发送通知。</p>
<p>这种场景背后的原因是什么：<br>1、Sqlite支持触发器，<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>发生时或触发。<br>2、Room创建了一个<code>InvalidationTracker</code>来跟踪观察表的变化。<br>3、<code>LiveData</code>和<code>Flowable</code>查询依赖<code>InvalidationTracker.Observer#onInvalidated</code>通知，收到通知就做一次再查询操作。</p>
<p>Room只知道表被修改了，不知道为什么修改也不知道什么被修改。因此，再查询操作会重新通知。由于Room不在内存保存数据也不能保证object的equals方法所以他不知道对象是否变化了。</p>
<p>你需要自己保证DAO过滤收到的事件，只对关心的数据做出响应。</p>
<p>如果观察的是<code>Flowable</code>，使用<code>Flowable#distinctUntilChanged</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> : <span class="type">BaseDao</span>&lt;<span class="type">User</span>&gt;</span>() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Get a user by id.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the user from the table with a specific id.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Query(“SELECT * FROM Users WHERE userid = :id”)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserById</span><span class="params">(id: <span class="type">String</span>)</span></span>: Flowable&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getDistinctUserById</span><span class="params">(id: <span class="type">String</span>)</span></span>: </span><br><span class="line">    Flowable&lt;User&gt; = getUserById(id).distinctUntilChanged()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果观察的是<code>LiveData</code>，可以用<code>MediatorLiveData</code>处理只让有变化的数据发送事件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> LiveData<span class="type">&lt;T&gt;</span>.<span class="title">getDistinct</span><span class="params">()</span></span>: LiveData&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> distinctLiveData = MediatorLiveData&lt;T&gt;()</span><br><span class="line">    distinctLiveData.addSource(<span class="keyword">this</span>, <span class="keyword">object</span> : Observer&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> initialized = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> lastObj: T? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(obj: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                initialized = <span class="literal">true</span></span><br><span class="line">                lastObj = obj</span><br><span class="line">                distinctLiveData.postValue(lastObj)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((obj == <span class="literal">null</span> &amp;&amp; lastObj != <span class="literal">null</span>) </span><br><span class="line">                       || obj != lastObj) &#123;</span><br><span class="line">                lastObj = obj</span><br><span class="line">                distinctLiveData.postValue(lastObj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> distinctLiveData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DAO中，让真正关心变化的方法使用<code>public</code>修饰，查询方法用<code>protected</code>修饰</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> : <span class="type">BaseDao</span>&lt;<span class="type">User</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="meta">@Query(“SELECT * FROM Users WHERE userid = :id”)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserById</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getDistinctUserById</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt; = getUserById(id).getDistinct()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果你返回列表用于展示，考虑使用<code>Paging</code>库，它能帮你处理数据的变化。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Android分区存储</title>
    <url>/android-scoped-storage.html</url>
    <content><![CDATA[<h3 id="一、What、Why（是什么、为什么）"><a href="#一、What、Why（是什么、为什么）" class="headerlink" title="一、What、Why（是什么、为什么）"></a>一、What、Why（是什么、为什么）</h3><p>1.1 什么是分区存储<br>了解传统的共享存储 (Shared Storage):</p>
<ul>
<li>每个app有独立的存储空间Android/data/pkg其他应用不可见（Context.getExternalFileDir）</li>
<li>访问外部空间需要额外权限READ/WRITE_EXTERNAL_STORAGE、获取存储权限的应用可以访问整个外部存储空间</li>
<li>应用卸载时，保存在外部存储空间文件不会被删除。</li>
</ul>
<span id="more"></span>

<p>共享存储带来的问题</p>
<ul>
<li>数据安全</li>
<li>存储空间浪费，难以管理</li>
</ul>
<p>分区存储解决方案(Scoped Storage):</p>
<ul>
<li>必须通过Media Store API和Storage Access FrameWork访问文件系统。=&gt;对传统共享存储系统的一种强制约束</li>
<li>文件归属：操作自己创建的文件无需任何权限（自己创建的文件系统会记录此文件的归属app，应用卸载后清除该归属字段，重装后读取该文件仍需权限申请），非共享文件存入私有目录。=&gt;文件和应用挂钩，便于操作系统进行管理</li>
</ul>
<p>By The Way:<br>在Android-Q （API-29）中通过android:requestLegacyExternalStorage=”true”可以禁用分区存储<br>在Android-R （API-30）中必须使用分区存储<br>在Android-Q中完全禁用了File API，Android-R重新启用</p>
<h3 id="二、How（分区存储实践-数据的增、删、改、查）"><a href="#二、How（分区存储实践-数据的增、删、改、查）" class="headerlink" title="二、How（分区存储实践-数据的增、删、改、查）"></a>二、How（分区存储实践-数据的增、删、改、查）</h3><p>2.1 对媒体文件的增删改查：</p>
<ul>
<li>增查：新增操作无需任何权限。查询其他应用的媒体资源需要READ_EXTERNAL_STORAGE权限。查询自己应用创建的媒体资源无需权限，当应用卸载重装后，自己创建的资源也需要申请权限。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveImageToAlbum</span><span class="params">(context: <span class="type">Context</span>, imageFile: <span class="type">File</span>, imageName: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">val</span> contentValues = ContentValues().apply &#123;</span><br><span class="line">            put(MediaStore.Images.Media.DISPLAY_NAME, imageName)</span><br><span class="line">            put(MediaStore.Images.Media.DESCRIPTION, <span class="string">&quot;图片描述&quot;</span>)</span><br><span class="line">            put(MediaStore.Images.Media.MIME_TYPE, <span class="string">&quot;image/jpg&quot;</span>)</span><br><span class="line">            <span class="comment">// 文件待处理状态，本应用独占，其他应用暂时无法访问</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">                put(MediaStore.Images.Media.IS_PENDING, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入数据库，获得uri</span></span><br><span class="line">        <span class="keyword">val</span> uri = context.contentResolver</span><br><span class="line">            .insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)</span><br><span class="line">            ?: <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 根据uri打开输出流，写入imageFile文件</span></span><br><span class="line">        context.contentResolver.openOutputStream(uri)?.use &#123; it.write(imageFile.readBytes()) &#125;</span><br><span class="line">        <span class="comment">// 切换文件待处理状态</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">            contentValues.clear()</span><br><span class="line">            contentValues.put(MediaStore.Images.Media.IS_PENDING, <span class="number">0</span>)</span><br><span class="line">            context.contentResolver.update(uri, contentValues, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>删改：删改自己创建的媒体资源无需权限。删改其他应用创建的资源需要捕获RecoverableSecurityException异常后，向用户申请删除权限。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performDeleteImage</span><span class="params">(image: <span class="type">MediaStoreModel</span>)</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getApplication&lt;Application&gt;().contentResolver.delete(</span><br><span class="line">                image.contentUri,</span><br><span class="line">                <span class="string">&quot;<span class="subst">$&#123;MediaStore.Images.Media._ID&#125;</span> = ?&quot;</span>,</span><br><span class="line">                arrayOf(image.id.toString())</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">catch</span> (securityException: SecurityException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">               <span class="keyword">val</span> recoverableSecurityException = securityException <span class="keyword">as</span>? RecoverableSecurityException</span><br><span class="line">                        ?: <span class="keyword">throw</span> securityException</span><br><span class="line">               startIntentSenderForResult(</span><br><span class="line">                   recoverableSecurityException.userAction.actionIntent.intentSender,</span><br><span class="line">                   DELETE_PERMISSION_REQUEST,</span><br><span class="line">                   <span class="literal">null</span>,</span><br><span class="line">                   <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>,</span><br><span class="line">                   <span class="literal">null</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> securityException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.2 对文档的增删改查：<br>对外部文档的读写操作需要使用Storage Access FrameWork，通过各种Intent交由系统处理。更多实例见<a href="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/">参考资料2</a></p>
<p>SAF存储的限制：</p>
<ul>
<li>Intent.ACTION_OPEN_DOCUMENT_TREE访问限制<ul>
<li>内部存储根目录</li>
<li>Download目录</li>
<li>Android/data/  和  Android/obb/</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建文档-返回Uri再进行写入</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply &#123;</span><br><span class="line">    addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    type = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">    putExtra(Intent.EXTRA_TITLE, <span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取&amp;删改</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply &#123;</span><br><span class="line">    addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    type = <span class="string">&quot;*/*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目录操作</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply &#123;</span><br><span class="line">    flags = Intent.FLAG_GRANT_WRITE_URI_PERMISSION</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>2.3 批量操作<br>通过MediaStore静态方法创建修改请求，征求用户同意后进行操作。Android-R后新增的API，旧版需走回contentResolver.delete()操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>createWriteRequest</td>
<td>向用户请求媒体文件组写入权限</td>
</tr>
<tr>
<td>createFavoriteRequest</td>
<td>用户将设备上指定的媒体文件标记为“收藏”的请求</td>
</tr>
<tr>
<td>createTrashRequest</td>
<td>用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容会在系统定义的时间段后被永久删除。</td>
</tr>
<tr>
<td>createDeleteRequest</td>
<td>用户立即永久删除指定的媒体文件</td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> uriList = [] <span class="comment">//A collection of content URIs to modify. </span></span><br><span class="line"><span class="keyword">val</span> pendingIntent = MediaStore.createWriteRequest(contentResolver,urisToModify)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Launch a system prompt requesting user permission for the operation.</span></span><br><span class="line">startIntentSenderForResult(editPendingIntent.intentSender,</span><br><span class="line">                           EDIT_REQUEST_CODE, </span><br><span class="line">                           <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="三、直接文件读写"><a href="#三、直接文件读写" class="headerlink" title="三、直接文件读写"></a>三、直接文件读写</h3><p>Android-11重新支持File对象访问文件的直接路径。<br>1、针对媒体文件<br>    - 归属于你应用的文件 和 你的私有目录 的文件 可以直接使用File API访问<br>    - 如果直接用File API访问没有权限的文件，抛出 FileNotFoundException<br>2、Media Store DATA 属性<br>DATA属性存储了媒体文件的绝对路径，在Android-10的时候废弃了该属性。由于Android-11又支持File对象，所以DATA属性也可以读取直接路径，但不一定有值。但是新增和更新操作不要再使用DATA了，请使用DISPLAY_NAME 和 RELATIVE_PATH 。</p>
<h3 id="四、另外一扇窗"><a href="#四、另外一扇窗" class="headerlink" title="四、另外一扇窗"></a>四、另外一扇窗</h3><p>对于一些特殊的App，例如文件管理器，备份等。可以申请所有文件访问权限<br>1.声明 MANAGE_EXTERNAL_STORAGE 权限<br>2.使用 ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION  将用户引导至一个系统设置页面进行授权</p>
<p>授权范围</p>
<ul>
<li>读写共享存储区的所有文件<ul>
<li>Media content （MediaStore）</li>
<li>Documents and other files （SAF）</li>
<li>Datasets （BlobStoreManager）</li>
</ul>
</li>
<li>MediaStore.Files数据库表</li>
<li>USB 和 SD卡 根目录</li>
<li>除 /Android/data/ 和 /sdcard/Android 之外的其他私有目录</li>
</ul>
<h3 id="五、应用截图"><a href="#五、应用截图" class="headerlink" title="五、应用截图"></a>五、应用截图</h3><table>
    <tr>
        <td><img src="../images/scoped_storage.png" width="200"/></td>
        <td><img src="../images/scoped_storage_2.png" width="200"/></td>
    </tr>
</table>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-11适配</title>
    <url>/android-target-30.html</url>
    <content><![CDATA[<h4 id="一、变更概览"><a href="#一、变更概览" class="headerlink" title="一、变更概览"></a>一、变更概览</h4><h5 id="1、隐私"><a href="#1、隐私" class="headerlink" title="1、隐私"></a>1、隐私</h5><ul>
<li>分区存储</li>
<li>自动释放权限</li>
<li>后台定位</li>
<li>包可见性</li>
</ul>
<h5 id="2、安全"><a href="#2、安全" class="headerlink" title="2、安全"></a>2、安全</h5><ul>
<li><a href="https://source.android.com/devices/tech/debug/tagged-pointers">堆指针添加标记</a></li>
<li>Toast<ul>
<li>🚫禁止后台弹出含自定义View的Toast</li>
<li>Toast支持显示/隐藏回调</li>
<li>部分View相关API调整</li>
</ul>
</li>
</ul>
<h5 id="3、连接"><a href="#3、连接" class="headerlink" title="3、连接"></a>3、连接</h5><ul>
<li>限制对APN数据库（Access Point Names）的读写</li>
</ul>
<h5 id="4、Accessibility"><a href="#4、Accessibility" class="headerlink" title="4、Accessibility"></a>4、Accessibility</h5><ul>
<li>文本转语音（TTS）和语音识别 需要声明<queries></li>
<li>在res/raw下声明对accessibility的使用</li>
</ul>
<h5 id="5、相机"><a href="#5、相机" class="headerlink" title="5、相机"></a>5、相机</h5><ul>
<li>以下Action默认只能调起系统相机，除非指定包名<ul>
<li>android.media.action.VIDEO_CAPTURE</li>
<li>android.media.action.IMAGE_CAPTURE</li>
<li>android.media.action.IMAGE_CAPTURE_SECURE</li>
</ul>
</li>
</ul>
<h5 id="6、应用打包和安装"><a href="#6、应用打包和安装" class="headerlink" title="6、应用打包和安装"></a>6、应用打包和安装</h5><ul>
<li>🚫禁止压缩resources.arsc</li>
<li>必须使用V2及以上版本进行apk签名<h5 id="7、Firebase"><a href="#7、Firebase" class="headerlink" title="7、Firebase"></a>7、Firebase</h5></li>
<li>target-30的apk在6.0及以上设备，不能使用Firebase JobDispatcher 和 GCMNetworkManager</li>
</ul>
<h5 id="8、allowBackup属性调整"><a href="#8、allowBackup属性调整" class="headerlink" title="8、allowBackup属性调整"></a>8、allowBackup属性调整</h5><h5 id="9、修改SP的OnSharedPreferenceChangeListener回调"><a href="#9、修改SP的OnSharedPreferenceChangeListener回调" class="headerlink" title="9、修改SP的OnSharedPreferenceChangeListener回调"></a>9、修改SP的OnSharedPreferenceChangeListener回调</h5><h5 id="10、非SDK接口调用黑名单"><a href="#10、非SDK接口调用黑名单" class="headerlink" title="10、非SDK接口调用黑名单"></a>10、非SDK接口调用黑名单</h5><h4 id="二、变更详情"><a href="#二、变更详情" class="headerlink" title="二、变更详情"></a>二、变更详情</h4><h5 id="1、分区存储"><a href="#1、分区存储" class="headerlink" title="1、分区存储"></a>1、分区存储</h5><ul>
<li><p>针对特殊类型应用(文件管理器、文件备份、文件加密)<br><br>这种类型的应用需要大规模的进行文件操作，迁移成本较高，推荐使用新的存储管理权限 MANAGE_EXTERNAL_STORAGE （参考1:此权限的授权范围）</p>
<ul>
<li>优点：<br><br>  1、开启后直接拥有所有读写权限（包括拔插的SD卡，USB等）<br><br>  2、清缓存不会丢失授权<br><br>  3、处理成本较低，只需兼容旧的动态权限申请部分的逻辑。<br></li>
<li>缺点：<br><br>  1、需要跳转设置页面开启权限，有损产品数据（轮询权限，强制拉回）<br><br>  2、需要提交GP申请表单，审核通过才能上架<br></li>
<li>实践：<br><br>  1、判断权限 Environment.isExternalStorageManager() <br><br>  2、跳转设置页面引导用户开启权限的方式：注意下面两个<strong>Action</strong>的区别<br><pre><code>  Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION&lt;br&gt;
  Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li>针对普通应用<br>无法申请新的存储管理权限 MANAGE_EXTERNAL_STORAGE 。只能对旧的API进行改造兼容，将其迁移到存储访问框架SAF（Storage Access Framework）包括Document-API 或 MediaStore-API。<ul>
<li>优点： <br><br>  1、交互逻辑，和代码逻辑结构比较统一 <br><br>  2、提高隐私与安全性，避免杂乱无章的文件系统 <br></li>
<li>缺点： <br><br>  1、迁移成本较高，需要做大量的API兼容，可能影响产品逻辑 <br></li>
<li>实践： <br><br>  1、分区存储文档 <br></li>
<li>注意事项： <br><br>  1、做好数据迁移，避免升级后，原来的数据在不可访问区域 <br><br>  2、保留 [requestLegacyExternalStorage=true] 属性 <br></li>
</ul>
</li>
</ul>
<blockquote>
<p>我的应用1.0版本之前数据库存储在外部，为了适配target-30，我在1.1版本，写了数据迁移代码。1.2版本，我做了target-30升级。某用户直接跳过1.1版本升级到了1.2版本。无法运行迁移代码。怎么办！</p>
</blockquote>
<p>preserveLegacyExternalStorage 属性：针对升级用户，暂时维持兼容属性，卸载后失效。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">  	<span class="attr">android:preserveLegacyExternalStorage</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h5 id="2、电话号码"><a href="#2、电话号码" class="headerlink" title="2、电话号码 "></a>2、电话号码 <br></h5><p>以下两个方法的调用需要申请新的权限： READ_PHONE_NUMBERS <br><br>getLine1Number()<br>getMsisdn()</p>
<h5 id="3、定位"><a href="#3、定位" class="headerlink" title="3、定位 "></a>3、定位 <br></h5><ul>
<li>增加Only this time 选项</li>
<li>不能一次性申请前后台定位权限，要分两次单独申请</li>
<li>后台位置访问需要跳转设置页面</li>
</ul>
<h5 id="4、包可见性"><a href="#4、包可见性" class="headerlink" title="4、包可见性 "></a>4、包可见性 <br></h5><p>概念： <br><br>在Android-10及以前的版本通过 queryIntentActivities、getPackageInfo、getInstalledApplications可以获取所有安装的App。但是在Android-11之后只能获取到一部分已安装应用列表。<br>解决方案： <br></p>
<ul>
<li>通过 <queries> 标签指定需要交互的应用</li>
<li>申请查看所有安装列表<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">package</span>=<span class="string">&quot;com.example.game&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">queries</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要和你做交互的app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.store&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.service&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 你需要查询的Intent --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;image/jpeg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">queries</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.QUERY_ALL_PACKAGES&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h4><p>1、<a href="https://developer.android.com/about/versions/11/behavior-changes-11#change-details">官方文档-behavior-changes-11</a> <br><br>2、<a href="https://support.google.com/googleplay/android-developer/answer/10467955">GP政策-MANAGE_EXTERNAL_STORAGE</a> <br><br>3、<a href="https://developer.android.com/training/data-storage/manage-all-files">存储权限-管理所有文件</a> <br><br>4、<a href="https://support.google.com/googleplay/android-developer/answer/10158779?hl=en#zippy=%2Cpermitted-uses-of-the-query-all-packages-permission">GP政策-all-packages-permission</a> <br> </p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>估值指标</title>
    <url>/base-economic-concept.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>英文名称</th>
<th>中文名称</th>
<th>计算方式</th>
<th>理解</th>
</tr>
</thead>
<tbody><tr>
<td>PE = Price-to-Earning Ratio</td>
<td>市盈率</td>
<td>每股股价/每股盈余 = 市值/净利润</td>
<td>创造财富的能力、回收成本的时间</td>
</tr>
<tr>
<td>PS = Price-to-Sales Ratio</td>
<td>市销率</td>
<td>每股股价/每股营收 = 市值/营收</td>
<td>获得公司1元的销售收入需要投入多少钱</td>
</tr>
<tr>
<td>PCF =Price-to-Cash-Flow Ratio</td>
<td>市现率</td>
<td>每股股价/每股现金流 = 市值/12月现金流</td>
<td></td>
</tr>
<tr>
<td>PB = Price-to-Book Ratio</td>
<td>市净率</td>
<td>每股股价/每股净资产 = 市值/净资产</td>
<td>净资产的溢价程度</td>
</tr>
</tbody></table>
<h4 id="一、市盈率"><a href="#一、市盈率" class="headerlink" title="一、市盈率"></a>一、市盈率</h4><p>1.1 PE - 静态市盈率</p>
<blockquote>
<p>① 市盈率 = 当日收盘价 / 上一年度每股税后利润  </p>
</blockquote>
<blockquote>
<p>② 市盈率 = 当前总市值 / 上年度净利润</p>
</blockquote>
<p>理解：</p>
<ul>
<li>公司需要累计多少年的盈利才能达到目前的市价水平。</li>
<li>值越低说明投资回收期短，风险越小，投资价值越高。</li>
<li>值越大说明翻本期长，风险大。</li>
</ul>
<p>缺点：</p>
<ul>
<li>取的是上一年度的净利润，是一个过去的值，有点滞后。</li>
</ul>
<p>例子：<br>你花了240w买了一套二手房，打算进行出租赚点外快，已知去年平均月租2w，一年收益大概24w。以去年这些数据为参考，你预计<strong>十年后</strong>才能赚回成本240w，所以市盈率 = 10。</p>
<p>1.2 动态市盈率<br>为了弥补静态市盈率的滞后性，增加动态市盈率作为参考指标。</p>
<blockquote>
<p>市盈率 = 当前总市值 / X</p>
</blockquote>
<p>根据当前的时间节点不同计算X的值：<br>X = 当年最近一个季度的净利润 * 4<br>X = 最近半年净利润 * 2<br>X = 最近三季度净利润 * 1.5 </p>
<p>1.3 静态市盈率 vs 动态市盈率</p>
<ul>
<li>静态市盈率反映的是过去的数据，动态市盈率反映的是未来的预估</li>
<li>动态市盈率 &gt; 静态市盈率，说明最近（一个季度、半年、三个季度）公司的利润下降了。</li>
</ul>
<p>1.4 TTM-Trailing Twelve Months</p>
<ul>
<li>最近十二个月市盈率，也叫滚动市盈率。</li>
<li>它也是一个对过去情况的分析说明。</li>
</ul>
<h4 id="二、每股净值产"><a href="#二、每股净值产" class="headerlink" title="二、每股净值产"></a>二、每股净值产</h4><blockquote>
<p>每股净值产 = （总资产 - 总负债） / 总股数</p>
</blockquote>
<center>
    <img src="../images/a_b_c.jpeg" width="300"/>
</center>


<h4 id="三、市净率"><a href="#三、市净率" class="headerlink" title="三、市净率"></a>三、市净率</h4><p>3.1 PB-市净率</p>
<blockquote>
<p>市净率 = 每股市价 / 每股净值产<br>每股净资产 = 股东权益 / 总股本</p>
</blockquote>
<p>市净率越低那么它的投资价值就越高，这也就意味着它的风险越低。</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>Economics</tag>
      </tags>
  </entry>
  <entry>
    <title>对称/非对称加密和数字签名</title>
    <url>/basic-encryption-algorithm.html</url>
    <content><![CDATA[<h4 id="1-对称加解密的过程："><a href="#1-对称加解密的过程：" class="headerlink" title="1.对称加解密的过程："></a>1.对称加解密的过程：</h4><p>（大家用相同的钥匙来进行加解密）<br><del>发送端和接收端首先要共享相同的密钥k(即通信前双方都需要知道对应的密钥)才能进行通信。发送端用共享密钥k对明文p进行加密，得到密文c，并将得到的密文发送给接收端，接收端收到密文后，并用其相同的共享密钥k对密文进行解密，得出明文p。</del></p>
<p>一般加密和解密的算法是公开的，需要保持隐秘的是密钥k<br>流行的对称加密算法有：DES，Triple-DES，RC2和RC4，AES</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>发送方和接收方首先需要共享相同的密钥，即存在密钥k的分发问题，如何安全的把共享密钥在双方进行分享，这本身也是一个如何安全通信的问题，一种方法是提前双方约定好，不通过具体的通信进行协商，避免被监听和截获。另外一种方式，将是下面我们介绍的通过非对称加密信道进行对称密码的分发和共享，即混合加密系统。</li>
<li>密钥管理的复杂度问题。由于对称加密的密钥是一对一的使用方式，若一方要跟n方通信，则需要维护n对密钥。</li>
</ul>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>加密和解密的速度要比非对称加密快很多，因此常用非对称加密建立的安全信道进行共享密钥的分享，完成后，具体的加解密则使用对称加密。即混合加密系统。</li>
</ul>
<p>另外一个点需要重点说明的是，密钥k的长度对解密破解的难度有很重大的影响，k的长度越长，对应的密码空间就越大，遭到暴力破解或者词典破解的难度就更大，就更加安全。</p>
<center>
    <img src="../images/dcjm.png" width="400"/>
</center>

<h4 id="2-数字签名的过程："><a href="#2-数字签名的过程：" class="headerlink" title="2.数字签名的过程："></a>2.数字签名的过程：</h4><ul>
<li>发送方A首先对变长的报文提取成一个定长的摘要，一般是md5等</li>
<li>A对摘要应用了一个签名函数，并且用A自己的私钥作为参数，因为只有A才知道私钥，所以正确的签名会说明签名者就是其所有者。</li>
<li>一旦计算出签名，节点A就将其附加到报文的末尾，并将报文和签名一起都发送给B</li>
<li>在接收端B，首先会按照同样的算法计算出报文的摘要，然后对签名用A的公钥进行解码，得出解码后的摘要，两个摘要进行比较，则可以判断是否是A发送的且内容没被篡改过。</li>
</ul>
<center>
    <img src="../images/szqm.png" width="400"/>
</center>


<h4 id="3-非对称加解密的过程："><a href="#3-非对称加解密的过程：" class="headerlink" title="3.非对称加解密的过程："></a>3.非对称加解密的过程：</h4><p>加密一方找到接收方的公钥e (如何找到呢？大部分的公钥查找工作实际上都是通过数字证书来实现的)，然后用公钥e对明文p进行加密后得到密文c，并将得到的密文发送给接收方，接收方收到密文后，用自己保留的私钥d进行解密，得到明文p，需要注意的是：用公钥加密的密文，只有拥有私钥的一方才能解密，这样就可以解决加密的各方可以统一使用一个公钥即可。</p>
<p>常用的非对称加密算法有：RSA</p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>不存在密钥分发的问题，解码方可以自己生成密钥对，一个做私钥存起来，另外一个作为公钥进行发布。</li>
<li>解决了密钥管理的复杂度问题，多个加密方都可以使用一个已知的公钥进行加密，但只有拥有私钥的一方才能解密。</li>
</ul>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>非对称加密不足的地方是加解密的速度没有对称加密快。</li>
</ul>
<p>综上，分析了对称加密和非对称加密各自的优缺点后，有没有一种办法是可以利用两者的优点但避开对应的缺点呢？答应是有的，实际上用得最多的是混合加密系统，比如在两个节点间通过便捷的公开密码加密技术建立起安全通信，然后再用安全的通信产生并发送临时的随机对称密钥，通过更快的对称加密技术对剩余的数据进行加密。</p>
<center>
    <img src="../images/fdcjm.png" width="400"/>
</center>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU的缓存</title>
    <url>/cpu-cache-overview.html</url>
    <content><![CDATA[<h4 id="一、性能"><a href="#一、性能" class="headerlink" title="一、性能"></a>一、性能</h4><p>1.1 在分层存储结构中，随着存储容量的增加，延迟也随之增加。<a href="https://gist.github.com/jboner/2841832">参考</a></p>
<p>从数据可以看出，L1缓存和主存访问速度相差200倍。</p>
<center>
    <img src="../images/cpu_cache_speed.png" width="500"/>
</center>


<h4 id="二、缓存行"><a href="#二、缓存行" class="headerlink" title="二、缓存行"></a>二、缓存行</h4><p>CPU缓存的基本单位是缓存行，主存数据和缓存的映射存在下列关系：</p>
<h5 id="2-1-直接映射缓存"><a href="#2-1-直接映射缓存" class="headerlink" title="2.1 直接映射缓存"></a>2.1 直接映射缓存</h5><center>
    <img src="../images/cpu_cache_direct_map.jpeg" width="600"/>
</center>

<p>1、 index用于计算在哪一个缓存行<br>2、 offset用于计算在缓存行的哪个字节<br>3、 tag用于判断缓存是否命中（假设0x7f6601 和 0x8f6602两个地址，低位都一样，缓存行和字节偏移都命中了，tag不命中）</p>
<p>缺点：<br>图中，cache缓存8行数据，当访问第0行、第8行、第16行时，缓存无法命中，每次都要去主存加载，发生<strong>缓存颠簸</strong></p>
<h5 id="2-2-多路组相连"><a href="#2-2-多路组相连" class="headerlink" title="2.2 多路组相连"></a>2.2 多路组相连</h5><p>这是一个两路组相连的示意图：</p>
<center>
    <img src="../images/cpu_cache_n_way.png" width="500"/>
</center>

<p>1、index定位组<br>2、组内依次对tag进行对比（可以通过硬件并行比较增加性能）</p>
<h4 id="三、缓存一致性"><a href="#三、缓存一致性" class="headerlink" title="三、缓存一致性"></a>三、缓存一致性</h4><h5 id="3-1-问题描述："><a href="#3-1-问题描述：" class="headerlink" title="3.1 问题描述："></a>3.1 问题描述：</h5><center>
    <img src="../images/cpu_cache_problem.jpeg" width="500"/>
</center>

<p>处理器 1 读 X ：从内存读取24并缓存<br>处理器 2 读 X ：从内存读取24并缓存<br>处理器 1 写 X = 32 ：更新自己的缓存<br>处理器 3 读 X = ？  </p>
<p>如何保证缓存的一致性？<a href="https://people.eecs.berkeley.edu/~pattrsn/252F96/Lecture18.pdf">参考</a></p>
<h5 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h5><p>3.1.1 嗅探-Snooping Solution(Snoopy Bus)</p>
<p>根据写操作对缓存数据的影响嗅探协议可分为：<br>Write-invalidate：<br>当处理器写入数据时，所有的独立缓存将通过总线嗅探得到通知，并标志自己的缓存失效。这保证了全局只有一份缓存是有效的。</p>
<ul>
<li>MSI</li>
<li>MESI</li>
<li>MOSI</li>
<li>MOESI</li>
<li>MESIF </li>
</ul>
<p>Write-update：<br>当处理器写入数据时，所有的独立缓存将通过总线嗅探得到通知，并更新自己的缓存。通过总线广播给所有的缓存造成了总线繁忙，所以不常见。</p>
<p>3.1.2 目录-Directory-Based Schemes</p>
<h5 id="3-2-MESI协议参考"><a href="#3-2-MESI协议参考" class="headerlink" title="3.2 MESI协议参考"></a>3.2 MESI协议<a href="https://people.cs.pitt.edu/~melhem/courses/2410p/ch5-4.pdf">参考</a></h5><p>MESI是四个状态的首字母缩写，在缓存行中用2个bit标志该缓存行的状态。</p>
<ul>
<li>M:Modified（只存在当前缓存行，已被修改，和主存不一致，需要更新回主存）</li>
<li>E:Exclusive（只存在当前缓存行，和主存一致）</li>
<li>S:Shared（其他缓存行也存在该数据，和主存一致）</li>
<li>I:Invalid（此缓存行失效）</li>
</ul>
<p>MESI的状态迁移：</p>
<center>
    <img src="../images/cpu_cache_mesi_state.jpeg" width="500"/>
</center>




<h4 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h4><p><a href="https://www.cnkirito.moe/cache-line/#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E8%A1%8C-Cache-Line-%EF%BC%9F">0.Java角度理解CPU缓存</a><br><a href="https://zhuanlan.zhihu.com/p/102293437">1.Cache的基本原理</a><br><a href="https://gist.github.com/jboner/2841832">2.每个开发者需要知道的数据</a><br><a href="https://medium.com/fcamels-notes/%E5%BE%9E%E7%A1%AC%E9%AB%94%E8%A7%80%E9%BB%9E%E4%BA%86%E8%A7%A3-memry-barrier-%E7%9A%84%E5%AF%A6%E4%BD%9C%E5%92%8C%E6%95%88%E6%9E%9C-416ff0a64fc1">3.硬件角度看内存屏障</a><br><a href="https://medium.com/fcamels-notes/%E5%BE%9E-double-checked-locking-%E4%BA%86%E8%A7%A3-memory-barrier-%E7%9A%84%E4%BD%9C%E7%94%A8-bb151a359c1b">4.软件角度内存屏障</a><br><a href="https://stackoverflow.com/questions/3928995/how-do-cache-lines-work">5.stackoverflow-How do cache lines work?</a><br><a href="https://courses.cs.duke.edu/spring09/cps104/lectures/2up-lecture17.pdf">6.courses-pdf</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU流水线工作原理</title>
    <url>/cpu-pipline-overview.html</url>
    <content><![CDATA[<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>在<a href="https://www.zhaixue.cc/weixin/weixin-cpu-pipeline.html">宅学部落</a>这个网站看到一篇讲CPU流水线的文章，写的非常好，为了便于翻阅回顾，转载之。</p>
<h5 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h5><p>现在的CPU处理器一般都是超流水线工作，动不动就是10级以上流水线，超高主频，这两者之间有什么关系呢？今天就跟大家科普下CPU流水线的工作原理，以及他们之间的关系。</p>
<p>说到流水线，很多人会想到富士康；说到富士康，很多人会想到张全蛋。作为富士康 3 号流水线资深质检员，下面就请张全蛋给大家科普下什么是流水线，大家鼓掌欢迎。</p>
<h5 id="Micheal-Jack-眼中的流水线"><a href="#Micheal-Jack-眼中的流水线" class="headerlink" title="Micheal Jack 眼中的流水线"></a>Micheal Jack 眼中的流水线</h5><blockquote>
<p>大家好，我是张全蛋，英文名叫Micheal Jack，法文名叫霍雷呆-杰Q赖，大家也可以叫我查理。作为iPhone 手机 3 号流水线的资深质检员，我很忙的，每分钟都是几百万的生意。像我们富士康这样的transnational enterprise，经常会和不同国家的客户说一些技术上的meeting啊、下班陪他们message啊，都需要英文的。像我们厂里不会说英语的啊，都会被经理 fire 掉的。在我们厂里，流水线叫法太 low了，我们都叫 pipeline，一条pipeline，每个人分工不同，从手机原材料到成品iPhone ，只需要短短几分钟。—- 《嵌入式C语言自我修养》</p>
</blockquote>
<center>
    <img src="../images/cpu-pipeline-phone.jpeg" width="90%"/>
</center>

<p>查理很忙，介绍到这里就走了，接下来我们继续了解下什么叫流水线。</p>
<p>流水线是工业大生产下的产物。在农业社会做一部手机，需要的是工匠、手艺人，就像故宫里制作钟表的那些匠人一样，是需要拜师学艺、慢慢学习的：从手机组装、质检、贴膜、包装都是一个人，什么都要学。手艺人慢工出细活，但成本很高，到了工业化社会就不一样了：大家分工合作，将做手机这个复杂过程拆分为多个简单步骤，每个人负责一个步骤，经过刻意（机械）练习和培训，就可以很快上手。每个人都做自己最擅长的，可以大大提高工作效率。</p>
<p>如果每个人都单独做一部手机，焊接电路、组装成品这一步骤一般人需要8分钟，测试检验一般需要4分钟，贴膜包装成盒一般需要4分钟，总共需要16分钟。每16分钟，如果有3个工人的话，一共可以生产3部手机。一个新员工从进厂开始，要培训学习三个月才能掌握所有的技能，才能上岗。如果引入生产流水线就不一样了，每个人只负责一个工序，比如赵铁柱只负责焊接电路、组装手机，李小花只负责贴膜，进厂培训3天就可以快速上手了，对工人的技能要求大大降低！而且随着时间积累，每个人对自己所负责的工序越来越熟练，每道工序需要的时间大大减少：赵铁柱焊接电路越来越顺手，花费时间从原来的8分钟缩减为4分钟；张全蛋的质量检验练得如火纯情，整个流程做完只需要2分钟；李小花的贴膜技术也越来越溜了，从贴膜到包装2分钟搞定。每16分钟，赵铁柱可以焊接4块电路板 ，整个流水线可以生产出4部手机，产能整整提升了33.33%！老板高兴，赵铁柱高兴，张全蛋和李小花更高兴，因为每做2分钟，他们还可以休息2分钟，刷刷微博滑个抖音，岂不乐哉！</p>
<p>看到这里可能有人抬杠了：你这么算是不对的，每道工序所用的时间都变为原来的一半，怎么可能做得到？其实要做到不难的，只要工序拆解得合理，容易上手，再加上足够时间的机械重复，很多人都可以做得到。只要奖金发到位，蛋糕店里的小姐姐夹蛋糕的速度比你眨眼的速度都快，银行柜台的小李数钞票的速度比点钞机都快，买单时饭店前台的小妹摁计算器的速度比你掏钱的速度都快。</p>
<h5 id="流水线工作原理"><a href="#流水线工作原理" class="headerlink" title="流水线工作原理"></a>流水线工作原理</h5><p>一条指令的执行一般要经过：取指令、翻译指令、执行指令三个基本流程。CPU内部的电路分为不同的单元：取指单元、译码单元、执行单元等，指令的执行也是按照流水线工序一步一步执行的。我们假设每一个步骤执行时间都是一个时钟周期，那么一条指令执行需要3个时钟周期。</p>
<center>
    <img src="../images/cpu-arm-pipeline.png" width="50%"/>
</center>


<p>CPU 执行指令的3个时钟周期里，取指单元只在第一个时钟周期里工作，其余两个时钟周期都处于空闲状态，其它两个执行单元也是如此，效率太低了，消费者无法接受，老板也不能接受。解决方法就是引入流水线，让流水线每一颗螺丝钉都马不停蹄地运转起来，最好一刻也不要停。</p>
<center>
    <img src="../images/cpu-pipeline-multi.png" width="50%"/>
</center>


<p>引入流水线工作模式后可以看到，除了刚开始第一个时钟周期大家还可以偷懒外，其余的时间都不能闲着：从第二个时钟周期开始，当译码单元在翻译指令1时，取指单元也不能闲着，要接着去取指令2。同样如此，从第三个时钟周期开始，当执行单元执行指令1时，译码单元也不能闲着，要接着去翻译指令2，而取指单元要去取指令3。从第四个时钟周期开始，每个电路单元都会进入满荷负载工作状态，像富士康工厂里的流水线一样，源源不断地执行一条条指令。</p>
<p>引入流水线后，虽然每一条指令执行流程不变，还是需要3个时钟周期，但是从整条流水线的输出看来，差不多平均每个时钟周期就能执行一条指令。原来执行一条指令需要3个时钟周期，现在平均只需要1个时钟周期，CPU 性能提升了不少。</p>
<p>流水线的本质其实就是拿空间资源换时间。将每条指令分解为多步，指令的每一步都有独立的电路来执行，并让不同指令的各步操作重叠，从而实现几条指令并行处理，从而加快程序的运行。</p>
<p>CPU内部的流水线如此，富士康工厂里的iPhone流水线也是如此，通过不断往流水线增加人手来提高流水线的生产效率，也就是吞吐率。</p>
<h5 id="超流水线技术"><a href="#超流水线技术" class="headerlink" title="超流水线技术"></a>超流水线技术</h5><p>想知道什么是超流水线，让我们再回到富士康。</p>
<p>在富士康 3 号 iPhone 流水生产线上，因为赵铁柱工作效率不高，焊接组装一步手机需要 4 分钟，导致生产一部iPhone手机也得需要 4 分钟，从而拖累了整条生产线的生产效率。老板很生气，后果很严重，赵铁柱没干到一个月就被 fire 掉了。后面几个月，陆陆续续来了不少人：小黑、皮裤哥、红姐，都想试试这份工作，可惜干得还不如赵铁柱，挑战电子厂失败，早已提桶跑路。</p>
<p>老板招不到人，感觉又错怪了赵铁柱，于是决定升级生产线，并承诺加薪重新召回了赵铁柱。</p>
<center>
    <img src="../images/cpu-pipeline-phone2.png" width="50%"/>
</center>

<p>老板找出了生产线的瓶颈：每道工序都是需要2分钟，只有赵铁柱这道工序耗时4分钟，老板错怪了这铁柱，这不是赵铁柱的原因，是因为这道工序太复杂。于是把这道工序进行了拆解为2道工序：焊接电路板和组装手机。焊接电路仍由赵铁柱负责，把电路板、显示屏、手机外壳组装成手机这道工序则由新招员工王建国负责。生产流水线优化后，赵铁柱焊接电路只需要2分钟，王建国组装也只需要 2 分钟，生产每部 iPhone 的时间由原来的 4 分钟缩减为 2 分钟，生产流水线的瓶颈解决了！</p>
<p>跟富士康流水线类似，优化CPU流水线也是提升CPU性能的有效手段。流水生产线存在木桶短板效应，我们只需要找出CPU流水线中的性能瓶颈，即耗时最长的那道工序，然后再进行细分、优化为更多的工序就可以了。每一道工序我们称为流水线的一级，流水线越深，每一道流水电路单元的执行时间就会变得越小，我们处理器的时钟周期就可以更短，从而可以通过提升CPU主频来提升CPU性能、提高工作效率。</p>
<p>在富士康流水生产线中，每道工序的最长耗时时间决定了整条生产线的吞吐率。在CPU内部也是如此，每个流水单元的执行时间（即时间延迟）决定了CPU流水线的性能。CPU流水线中的每一道电路单元由组合逻辑电路和寄存器组成，逻辑单路用来执行本道工序的逻辑运算，寄存器用来保存结果，并作为下一道工序的输入。</p>
<center>
    <img src="../images/cpu-pipeline-line.png" width="50%"/>
</center>

<p>流水生产线是通过减少每一道工序的耗费时间来提升整条流水线效率的。在CPU内部也是如此，CPU内部的数字电路是靠时钟驱动来工作的，既然每条指令的执行时钟周期数不变，即执行每条指令需要3个时钟周期，但是我们可以通过缩短时钟周期的方法来提升效率，即减少每条指令所耗费的时间。减少时钟周期，也就是提升CPU主频，一个关键的制约因素就是CPU内部每一个执行单元的耗费时间。虽然说电信号在电路中的传播时间很快，可以接近光速，但是经过成千上万的晶体管，不停地信号翻转，还是会带来一定的时间延迟，这个时间延迟我们可以看做这道工作的执行时间。以上图为例，如果每个执行单元的延迟是 1.5 纳秒，那么你的时钟周期至少也得2纳秒以上，否则电路就会工作异常。如果驱动CPU工作的时钟周期是 2 纳秒，CPU的主频就是 500 MHz。现在的CPU流水线深度可以做到10级以上，流水线的每一级时间延迟可以做到皮秒级别，驱动CPU工作的时钟周期可以做到更短，因此可以把CPU的主频飙到 5 GHz 以上。</p>
<p>我们把5级以上的流水线称为超流水线结构。高性能的处理器，为了提升CPU主频，一般都会采用这种超流水线结构。Intel的 i7 处理器有16级流水线，AMD的速龙64系列CPU流水线为20级。史上具有最长流水线的是Intel的第三代奔腾四处理器，有31级的流水线。</p>
<p>想要提升CPU的主频，根本在于减少流水线中每一级流水的执行时间，消除木桶的短板效应，才能提升流水线的整体性能。解决方法有三个：一是优化流水线中各级流水线的性能，受限于当前集成电路的设计水平，这一步最难；二是依靠集成电路的制造工艺，更先进的纳米工艺，芯片面积越小，发热越小，更容易提升主频；三是不断地增加流水线，流水线越深，流水线的各级延迟就可以做得越小，更容易提高主频。</p>
<p>流水线是否越深越好呢？非也。流水线的本质是拿空间换时间，流水线越深，电路就会越复杂，需要更多的组合逻辑电路和寄存器，芯片面积也就越大，功耗也就随之上升了。拿功耗增长换来性能提升，在PC机和服务器上还行，但对于很多靠电池供电的移动设备的处理器来说就无法接受了，CPU设计人员需要在性能和功耗之间做一个很好的平衡。</p>
<p>流水线越深，就越能提升性能吗？也不一定。流水线是靠指令的并行来提升性能的，第一条指令还没有执行完，下面的第二条指令就开始取指、译码了。执行的程序指令如果是顺序结构，没有中断或跳转，流水线确实可以提高执行效率。但是当程序指令中存在跳转、分支结构时，下面预取的指令可能就要全部丢掉了，需要到要跳转的地方重新取指令执行。如下面的分支，如果BEQ条件不满足，处理器可能就会将预期的ADD指令全部丢弃，重新到here标签处取SUB指令执行。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">BEQ R1, R2, here</span><br><span class="line">ADD R2, R1, R0</span><br><span class="line">ADD R5, R4, R3</span><br><span class="line">...</span><br><span class="line">here:</span><br><span class="line">SUB R2, R1, R0</span><br><span class="line">SUB R5, R4, R3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>流水线越深，一旦预取指令失败，浪费和损失就会越严重，因为流水线中预取的几十条指令可能都要丢弃掉，流水线发生了停顿，无法按照预期继续执行，这种情况我们一般称之为流水线冒险（hazard）。在现在很多超流水线处理器中，为了避免这种情况出现，会采取各种各样的方法去避免这种情况，以免影响处理器的性能。</p>
<p>流水线越深，一旦预取指令失败，浪费和损失就会越严重，因为流水线中预取的几十条指令可能都要丢弃掉，流水线发生了停顿，无法按照预期继续执行，这种情况我们一般称之为流水线冒险（hazard）。在现在很多超流水线处理器中，为了避免这种情况出现，会采取各种各样的方法去避免这种情况发生，以免影响处理器的性能。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之布隆过滤器</title>
    <url>/cs-data-structure-bloomfilter.html</url>
    <content><![CDATA[<hr>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>一种空间高效的概率型数据结构，用于判断一个元素是否存在于集合中。</p>
<p>空间高效：用几个比特位来标识存在与否，不占用太多内存空间。<br>概率型：有几率把一个不存在的元素判定为存在。</p>
<p>Hash表存在的问题：数据量很大时，占用内存太多了。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入操作："><a href="#插入操作：" class="headerlink" title="插入操作："></a>插入操作：</h5><p>初始bit数组A[m-1]全部置0，通过映射函数，将要插入的值随机映射到数组范围内，将该位置为1</p>
<center>
    <img src="../images/bloom-filters-insert.png" width="50%"/>
</center>


<h5 id="查找操作："><a href="#查找操作：" class="headerlink" title="查找操作："></a>查找操作：</h5><p>将要查找的元素通过映射函数，映射到数组中，判断该bit位是否为1</p>
<center>
    <img src="../images/bloom-filters_03.png" width="50%"/>
</center>



<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul>
<li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li>
</ul>
<p><a href="https://freecontent.manning.com/all-about-bloom-filters/">图片来源</a></p>
]]></content>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>投资回报率</title>
    <url>/econonmics-roa-roe-roic-roce.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul>
<li>资产回报率（ROA）</li>
<li>净资产回报率（ROE）</li>
<li>投入资本回报率（ROIC）</li>
<li>使用资本回报率（ROCE）</li>
</ul>
<p>不同的回报率，实际上是衡量公司的不同视角。</p>
<h4 id="二、资产回报率（ROA）"><a href="#二、资产回报率（ROA）" class="headerlink" title="二、资产回报率（ROA）"></a>二、资产回报率（ROA）</h4><h5 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p><strong>运用全部资金获取利润能力的集中体现</strong></p>
<center>
    <img src="../images/ec-roa.png" width="50%"/>
</center>

<p>$$<br>    ROA=\frac{净利润}{总资产}<br>$$</p>
<h5 id="2-2-概念拆分"><a href="#2-2-概念拆分" class="headerlink" title="2.2 概念拆分"></a>2.2 概念拆分</h5><p>$$<br>    ROA = 净利润率NPM * 资产利用率AU = \frac{净利润}{营业总收入} * \frac{营业总收入}{总资产} = \frac{（主营业务收入+非主营业务收入）}{总资产}<br>$$</p>
<h5 id="2-3-概念理解"><a href="#2-3-概念理解" class="headerlink" title="2.3 概念理解"></a>2.3 概念理解</h5><p>ROA这个回报率衡量的是资产的回报率。<br>但是一个公司资产负债表上的资产价值更多的是反映了历史而不是当前，<br>而且不同的行业的ROA具有不可比性。<br>最简单的例子，很多类金融企业有无息流动负债，增加了总资产，降低了ROA，<br>但是无偿使用上下游资金实际上是公司有竞争力的体现。</p>
<h4 id="三、净资产回报率（ROE）"><a href="#三、净资产回报率（ROE）" class="headerlink" title="三、净资产回报率（ROE）"></a>三、净资产回报率（ROE）</h4><h5 id="2-1-基本概念-1"><a href="#2-1-基本概念-1" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>ROE的视角是从股东的角度看问题，单纯从股权的角度衡量回报，而不考虑公司的资本结构及负债情况。衡量公司赚钱的效率。</p>
<center>
    <img src="../images/ec-roe.png" width="50%"/>
</center>

<p>$$<br>    净资产收益率 = \frac{净利润}{净资产}<br>$$</p>
<blockquote>
<p>A公司：10亿净资产赚2亿。ROE = 20%<br>B公司：50亿净资产赚5亿。ROE = 10%</p>
</blockquote>
<h5 id="2-2-概念拆分-1"><a href="#2-2-概念拆分-1" class="headerlink" title="2.2 概念拆分"></a>2.2 概念拆分</h5><p>$$<br>    净资产收益率 = \frac{净利润}{净资产} = \frac{净利润}{营业收入} * \frac{营业收入}{总资产} * \frac{总资产}{净资产}<br>$$</p>
<p>$$<br>    净资产收益率 = 净利润 * 资产周转率 * 权益乘数<br>$$</p>
<p>$$<br>    权益乘数 = \frac{总资产}{净资产}<br>$$</p>
<p>$$<br>    资产周转率 = \frac{营业收入}{总资产}<br>$$</p>
<p>影响因素：</p>
<ul>
<li>净利润：反应盈利能力</li>
<li>资产周转率：反应资产使用效率</li>
<li>权益乘数：反应负债程度</li>
</ul>
<p>提升ROE的办法：</p>
<ul>
<li>提高周转率</li>
<li>廉价的债务杠杆</li>
<li>更高的债务杠杆</li>
<li>更低的所得税</li>
<li>更高的运营利润率</li>
</ul>
<h5 id="2-3-概念理解-1"><a href="#2-3-概念理解-1" class="headerlink" title="2.3 概念理解"></a>2.3 概念理解</h5><p>ROE对股东来说意义最大，是股票复利增长的源泉。<br>ROE可以在不同行业与不同企业之间横向比较。<br>相当于股票这种“股权债券”的收益率。<br>对投资人来说无论是投资铁路还是互联网，都相当于是买了“股权债券”。<br>在同等风险情况下，当然是收益率越高越好。<br>而且，ROE还可以与政府债券、企业债券的收益率跨资产类别横向比较。</p>
<h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><p>ROE的问题在于无法反映债务杠杆对净利润的影响。<br>如果一个企业借更多的债，一般就能产生更多净利润，ROE也会提高。<br>但是这样的提高是以牺牲企业经营稳健程度为代价的。<br>因此，分析ROE一定要结合杜邦公式，并与同行业进行比较。</p>
<hr>
<h4 id="四、投入资本回报率（ROIC）"><a href="#四、投入资本回报率（ROIC）" class="headerlink" title="四、投入资本回报率（ROIC）"></a>四、投入资本回报率（ROIC）</h4><center>
    <img src="../images/ec-roic-1.png" width="50%"/>
</center>


<p>ROIC是从资本的角度看问题，综合考虑股权与债权，衡量投资的效率。与ROIC对应的是平均资金成本（WACC）。如果ROIC小于WACC，就说明投入资本的回报小于平均资本成本，公司是在浪费资本。</p>
<p>ROIC=息税前收益（EBIT）*（1-税率）/投入资本</p>
<p>$$<br>    ROIC = \frac{息税前收益（EBIT）*（1-税率）}{投入资本}<br>$$</p>
<p>$$<br>    投入资本 = 股东权益 + 有息负债<br>$$</p>
<p>$$<br>    ROIC = \frac{EBIT（1-税率）}{有息负债+权益）}<br>$$</p>
<p>公式中分子是指一家公司如果完全以权益筹资所应报告的净利润，分母是指公司所有要求回报的现金来源的总和，也就是说，尽管应付账款也是公司的一种现金来源，但因其未附带明确的成本而被排除在外。实质上，ROIC是生产经营活动中所有投入资本赚取的收益率，而不论这些投入资本是被称为债务还是权益。</p>
<center>
    <img src="../images/ec-roic-2.png" width="50%"/>
</center>


<p>投入资本回报率是EBIT（税及利息前盈利）经过税率调整比上投入的资本，也就是股东权益加负债减去非运营现金和投资。之所以用EBIT就是因为利息是由债务产生的，是对债权的回报，当计算债权加股权的总的投入资本的回报率时应该把利息加回来。</p>
<p>投入资本也可以表示为净运营资金（流动运营资产减去无息流动负债）加固定资产，加无形资产及商誉，加其他运营资产。</p>
<p>ROIC的问题在于没有考虑无息流动负债的影响。ROIC实际上是衡量投入的总资本的使用效率，与平均资金成本WACC相结合可以揭示一个企业的真正效率。ROIC &lt; WACC 是卖空大师Jim Chanos经常用来寻找卖空对象的一个重要指标。</p>
<p>但是，ROIC对于类金融企业的分析不太容易。一些类金融企业如国美、苏宁、联想、格力等，占用了大量上下游资金作为无息流动负债，因此提高了EBIT。但是，和有息负债一样，无息负债也存在风险。虽然不用付利息，但是一旦经营形式改变，这些资金很有可能像“热钱”一样撤走。国美在黄光裕被捕后就陷入了这样的危险境地，只要供应商撤资，国美就会破产。这些企业虽然ROIC很高，但是静态不稳定，动态稳定。</p>
<h4 id="五、使用资本回报率-ROCE-Return-on-Capital-Employed"><a href="#五、使用资本回报率-ROCE-Return-on-Capital-Employed" class="headerlink" title="五、使用资本回报率(ROCE = Return on Capital Employed)"></a>五、使用资本回报率(ROCE = Return on Capital Employed)</h4><center>
    <img src="../images/ec-roce.png" width="50%"/>
</center>

<p>$$<br>    ROCE資本運用報酬率 = \frac{息税前收益（EBIT）}{已動用資本(Capital Employed)}<br>$$</p>
<p>$$<br>    已動用資本 = 總資產 -流動負債<br>$$</p>
<p>ROCE实质上是从企业价值（EnterpriseValue，EV）的角度，从并购的角度看资本的回报率。ROCE中的使用资本是股东权益加有息负债再减现金。这实质上相当于1倍PB并购企业时的企业价值。因为如果你以1倍PB并购一个企业，你要付的价格就是股东权益，并且承担所有负债，但也获得所有现金。</p>
<p>ROCE实际上是从一个并购者的角度看问题，如果并购一个企业，付出企业价值EV后的回报率有多少？这与ROIC最大的不同是：ROIC从企业的拥有者的角度看问题，衡量投入资本的使用效率与回报率。而ROCE是从潜在并购者的角度看问题，衡量如果1倍PB并购付出EV后的回报率，也就是并购到底值不值的问题。这接近价值投资买股票就是买公司的原则。</p>
<p>ROCE：使用资本回报率是EBIT（税及利息前盈利）比上使用的资本，也就是所有有息负债加上股东权益。这个指标与ROIC相近，但是使用的是EBIT而没有经过税率调整，因此可以用来比较不同税率的企业。ROCE也容易忽视公司无息负债的融资效应。</p>
<p>总之，本质上是从四个不同的视角看问题，衡量不同的指标。只有全面综合考虑，才能更全面的看问题</p>
<h4 id="六、参考来源"><a href="#六、参考来源" class="headerlink" title="六、参考来源"></a>六、参考来源</h4><p><a href="https://xueqiu.com/1484348349/107966592">雪球-老韩7</a><br><a href="https://rich01.com/what-is-roce/">ROCE資本運用報酬率</a></p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之文件系统</title>
    <url>/cs-operating-systems-file-system.html</url>
    <content><![CDATA[<hr>
<h5 id="一、磁盘的结构"><a href="#一、磁盘的结构" class="headerlink" title="一、磁盘的结构"></a>一、磁盘的结构</h5><p>磁盘按照物理结构和逻辑结构区分比较好。</p>
<p>1.1 HDD物理结构(Hard Disk Drive)</p>
<ul>
<li>Platters：盘片</li>
<li>Head：读写头</li>
<li>Spindle：主轴</li>
<li>Actuator Arm：机械臂</li>
<li>Cylinder:柱面</li>
<li>Sector：扇区</li>
<li>Track：磁道：</li>
</ul>
<center>
    <img src="../images/hard-disk-structure.png" width="250"/>
    <img src="../images/hard-disk-structure-2.jpeg" width="250"/>
    <img src="../images/hard-disk-structure-3.jpeg" width="250"/>
</center>

<p>1.2 SSD的物理结构(Solid State Drive)</p>
<p>1.2.1 基本存储单元</p>
<center>
    <img src="../images/ssd-unit.jpg" width="250"/>
</center>

<p>通过向被绝缘层包围的浮栅层充放电来写入擦除数据。（非易失存储器）</p>
<p>1.3 逻辑结构</p>
<p>文件系统block -&gt; 磁盘block -&gt; n * 扇区</p>
<center>
    <img src="../images/file_system_ext2_group.jpeg" width="250"/>
</center>

<center>
    <img src="../images/file_system_ext2_block.jpeg" width="250"/>
</center>



<h5 id="二、文件系统挂载"><a href="#二、文件系统挂载" class="headerlink" title="二、文件系统挂载"></a>二、文件系统挂载</h5><p>文件系统生成后，还不能直接使用，需要借助”mount”操作，将这个文件系统加入到Linux的管理，这样用户才能看到并访问</p>
<h5 id="三、虚拟文件系统"><a href="#三、虚拟文件系统" class="headerlink" title="三、虚拟文件系统"></a>三、虚拟文件系统</h5><center>
    <img src="../images/file_system_structure.jpg" width="250"/>
</center>


<p>虚拟文件系统为各种文件系统提供一个通用的接口，其支持的文件系统可以划分为三种主要类型：</p>
<ul>
<li>磁盘文件系统（EXT3、NTFS）</li>
<li>网络文件系统</li>
<li>特殊文件系统（/proc）</li>
</ul>
<p>虚拟文件系统通过引入一套通用的文件模型来支持所有的文件系统，通用模型由四大对象组成：</p>
<ul>
<li>超级块对象</li>
<li>索引节点对象</li>
<li>目录项对象</li>
<li>文件对象</li>
</ul>
<p>3.1 超级快对象：代表一个具体的已安装文件系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">s_op</span>;</span><span class="comment">//操作对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.2 索引节点对象：代表一个具体的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">i_op</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3 目录项对象：代表一个目录项，是路径的一个组成部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.4 文件对象：代表由进程打开的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="四、相关系统调用"><a href="#四、相关系统调用" class="headerlink" title="四、相关系统调用"></a>四、相关系统调用</h5><table>
<thead>
<tr>
<th align="left">系统调用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mount() unmount() unmount2()</td>
<td align="left">安装卸载文件系统</td>
</tr>
<tr>
<td align="left">mkdir() rmdir()</td>
<td align="left">创建删除目录</td>
</tr>
<tr>
<td align="left">unlink() rename()</td>
<td align="left">对目录项进行操作</td>
</tr>
<tr>
<td align="left">mmap() mmap2() munmap()</td>
<td align="left">处理文件内存映射</td>
</tr>
<tr>
<td align="left">read() write()</td>
<td align="left">进行文件IO操作</td>
</tr>
<tr>
<td align="left">select() poll()</td>
<td align="left">等待一组文件描述符上发生事件</td>
</tr>
<tr>
<td align="left">open() close() create()</td>
<td align="left">打开关闭创建</td>
</tr>
<tr>
<td align="left">chmod() fchmod() utime()</td>
<td align="left">更改文件属性</td>
</tr>
</tbody></table>
<h5 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h5><p><a href="https://z.itpub.net/article/detail/8ABB71A5EFED33EA9D09353759A91F1C">https://z.itpub.net/article/detail/8ABB71A5EFED33EA9D09353759A91F1C</a></p>
<p><a href="http://chuquan.me/2022/05/01/understand-principle-of-filesystem/">深入理解 Linux Ext 文件系统设计原理</a></p>
<p><a href="https://www.cnblogs.com/f-ck-need-u/p/7016077.html#auto_id_4">第4章 ext文件系统机制原理剖析 </a></p>
<p><a href="https://www.eet-china.com/mp/a38145.html">Linux 虚拟文件系统四大对象：超级块、inode、dentry、file之间关系</a></p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程 </a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>开发者七条</title>
    <url>/ep-good-developer-manifesto.html</url>
    <content><![CDATA[<p>软件开发不只是API调用和基础语法，以下是应用开发的全貌：</p>
<h4 id="一、相信数据"><a href="#一、相信数据" class="headerlink" title="一、相信数据"></a>一、相信数据</h4><p>如果你觉得系统正常运转，你应该拿出数据支撑你的想法。更重要的是，当研究证明你是错的时，你应该欣然接受实事。<br>这就需要做测试来验证你的代码，也需要一些流程来生成对应的数据。<br>你做的任何事都需要数据来辅助你下一步的决策。否则你将不知道自己做的事是对还是错。</p>
<h4 id="二、软件开发不只是编码"><a href="#二、软件开发不只是编码" class="headerlink" title="二、软件开发不只是编码"></a>二、软件开发不只是编码</h4><p>除了编码，开发人员还需要协调、沟通、分析、设计、测试、项目管理等</p>
<h4 id="三、代码就是和人沟通"><a href="#三、代码就是和人沟通" class="headerlink" title="三、代码就是和人沟通"></a>三、代码就是和人沟通</h4><p>如果我们真的只是“为计算机编程”，那么我们都将编写字节码。计算机最能理解它。但我们用的是一种“折衷”语言，这种语言其他人可以理解，也可以翻译成计算机可以理解的东西。</p>
<p>好的软件开发是一个交流的过程。这是为了确保人们理解你在做什么。你的工作是与下一个阅读它的人交流。找到最好的表达方式可能需要同理心。</p>
<h4 id="四、好的流程很重要"><a href="#四、好的流程很重要" class="headerlink" title="四、好的流程很重要"></a>四、好的流程很重要</h4><p>康威定律预言，你的软件注定要反映你的团队及其沟通结构。流程是沟通的结构。</p>
<p>想象一下一架起飞的飞机:飞行员、副驾驶、机组人员和空中交通管制人员之间有一段非常有条理的对话。这确保了每个人都关注关键问题，每个人都有发言权。“机翼还在飞机上吗?””“检查。“没有别的飞机挡住我们的去路吗?”“可以起飞了。”</p>
<h4 id="五、用结果证明自己，而不是身份低位"><a href="#五、用结果证明自己，而不是身份低位" class="headerlink" title="五、用结果证明自己，而不是身份低位"></a>五、用结果证明自己，而不是身份低位</h4><p>最糟糕的开发组织要么等级森严，要么每个开发人员有太多老板。这通常反映了管理者对地位的渴望。</p>
<p>考虑“角色”，而不是“地位”。我工作过的最好的组织都首先认可那些推动事情的人，而不管他们在组织中扮演什么角色。</p>
<h4 id="六、每个人都能从别人那学到"><a href="#六、每个人都能从别人那学到" class="headerlink" title="六、每个人都能从别人那学到"></a>六、每个人都能从别人那学到</h4><p>如果您认为人们的种族、性别或其他因素是判断他们的技能或他们必须教给您的东西的好方法，那么您就限制了自己作为软件开发人员的发展。</p>
<h4 id="七、测试你所有的猜想，并随时准备改变这些猜想"><a href="#七、测试你所有的猜想，并随时准备改变这些猜想" class="headerlink" title="七、测试你所有的猜想，并随时准备改变这些猜想"></a>七、测试你所有的猜想，并随时准备改变这些猜想</h4><p>当指导年轻的开发者时，我总是强调你不应该证明自己是对的，而应该证明自己是错的。我还鼓励他们用证明自己正确的热情去做这件事。</p>
<p>逻辑理论往往有一种方法可以证明你是错的。如果没有，这可能不是一个很好的理论。如果你不能证明它是错的，那么，只有那时，也许你可以试着证明它是对的。这与“相信数据”类似，但这不仅仅是关于数据，还有你使用数据的方式。</p>
<p><a href="https://www.infoworld.com/article/3214481/the-good-software-development-manifesto.html">参考来源</a></p>
]]></content>
      <tags>
        <tag>软件哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>Class文件的存储格式</title>
    <url>/file-format-class.html</url>
    <content><![CDATA[<h4 id="一、Class文件结构概览"><a href="#一、Class文件结构概览" class="headerlink" title="一、Class文件结构概览"></a>一、Class文件结构概览</h4><h5 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h5><ul>
<li>每一个class文件包含一个类或者接口的定义</li>
<li>以大端方式存储</li>
<li>u1、u2、u4分别表示1、2、4个字节  </li>
</ul>
<h5 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-3-图形化表示"><a href="#1-3-图形化表示" class="headerlink" title="1.3 图形化表示"></a>1.3 图形化表示</h5><center>
    <img src="../images/class_file_format.jpeg" width="400"/>
</center>

<h5 id="1-4-示例"><a href="#1-4-示例" class="headerlink" title="1.4 示例"></a>1.4 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMWCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;宝马&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BMW car drive.&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Last modified 2017-11-10; size 644 bytes</span><br><span class="line">  MD5 checksum ac6d7477d45479490e4ea3f660b1dcdd</span><br><span class="line">  Compiled from &quot;BMWCar.java&quot;</span><br><span class="line">public class BMWCar implements Car</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #12.#23        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #24            // 宝马</span><br><span class="line">   #3 = Fieldref           #11.#25        // BMWCar.name:Ljava/lang/String;</span><br><span class="line">   #4 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Class              #28            // java/lang/StringBuilder</span><br><span class="line">   #6 = Methodref          #5.#23         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = String             #29            // BMW car drive.</span><br><span class="line">   #8 = Methodref          #5.#30         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">   #9 = Methodref          #5.#31         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #10 = Methodref          #32.#33        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #11 = Class              #34            // BMWCar</span><br><span class="line">  #12 = Class              #35            // java/lang/Object</span><br><span class="line">  #13 = Class              #36            // Car</span><br><span class="line">  #14 = Utf8               name</span><br><span class="line">  #15 = Utf8               Ljava/lang/String;</span><br><span class="line">  #16 = Utf8               &lt;init&gt;</span><br><span class="line">  #17 = Utf8               ()V</span><br><span class="line">  #18 = Utf8               Code</span><br><span class="line">  #19 = Utf8               LineNumberTable</span><br><span class="line">  #20 = Utf8               drive</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               BMWCar.java</span><br><span class="line">  #23 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = Utf8               宝马</span><br><span class="line">  #25 = NameAndType        #14:#15        // name:Ljava/lang/String;</span><br><span class="line">  #26 = Class              #37            // java/lang/System</span><br><span class="line">  #27 = NameAndType        #38:#39        // out:Ljava/io/PrintStream;</span><br><span class="line">  #28 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #29 = Utf8               BMW car drive.</span><br><span class="line">  #30 = NameAndType        #40:#41        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #31 = NameAndType        #42:#43        // toString:()Ljava/lang/String;</span><br><span class="line">  #32 = Class              #44            // java/io/PrintStream</span><br><span class="line">  #33 = NameAndType        #45:#46        // println:(Ljava/lang/String;)V</span><br><span class="line">  #34 = Utf8               BMWCar</span><br><span class="line">  #35 = Utf8               java/lang/Object</span><br><span class="line">  #36 = Utf8               Car</span><br><span class="line">  #37 = Utf8               java/lang/System</span><br><span class="line">  #38 = Utf8               out</span><br><span class="line">  #39 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #40 = Utf8               append</span><br><span class="line">  #41 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #42 = Utf8               toString</span><br><span class="line">  #43 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #44 = Utf8               java/io/PrintStream</span><br><span class="line">  #45 = Utf8               println</span><br><span class="line">  #46 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public BMWCar();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: ldc           #2                  // String 宝马</span><br><span class="line">         7: putfield      #3                  // Field name:Ljava/lang/String;</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 4</span><br><span class="line">        line 8: 10</span><br><span class="line"></span><br><span class="line">  public void drive();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: ldc           #7                  // String BMW car drive.</span><br><span class="line">        12: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        15: aload_0</span><br><span class="line">        16: getfield      #3                  // Field name:Ljava/lang/String;</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 28</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;BMWCar.java&quot;</span><br></pre></td></tr></table></figure>

<h4 id="二、常量池的结构"><a href="#二、常量池的结构" class="headerlink" title="二、常量池的结构"></a>二、常量池的结构</h4><p>常量池是一个cp_info的数组：通过tag定位到具体的数据结构，再通过数据结构的表示，判断下面几个字节怎么解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag; //cp-info的类型</span><br><span class="line">    u1 info[];//类型对应的数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>tag</th>
<th>info</th>
<th>数据结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CONSTANT_Utf8_info</td>
<td>CONSTANT_NameAndType_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u2 name_index;<br>    &nbsp;u2 descriptor_index;<br>}</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>3</td>
<td>CONSTANT_Integer_info</td>
<td>CONSTANT_Integer_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u4 bytes;<br>}</td>
<td>整形字面量，boolean、byte、char、short等类型都用int存放</td>
</tr>
<tr>
<td>4</td>
<td>CONSTANT_Float_info</td>
<td>CONSTANT_Float_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u4 bytes;<br>}</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>5</td>
<td>CONSTANT_Long_info</td>
<td>CONSTANT_Long_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u4 high_bytes;<br>    &nbsp;u4 low_bytes;<br>}</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>6</td>
<td>CONSTANT_Double_info</td>
<td>CONSTANT_Long_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u4 high_bytes;<br>    &nbsp;u4 low_bytes;<br>}</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>7</td>
<td>CONSTANT_Class_info</td>
<td>CONSTANT_Class_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u2 name_index;<br>}</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>8</td>
<td>CONSTANT_String_info</td>
<td>CONSTANT_String_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u2 string_index;<br>}</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>9</td>
<td>CONSTANT_Fieldref_info</td>
<td>CONSTANT_Fieldref_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u2 class_index;//索引值<br>    &nbsp;u2 name_and_type_index;<br>}</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>10</td>
<td>CONSTANT_Methodref_info</td>
<td>CONSTANT_Methodref_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u2 class_index;;//索引值<br>    &nbsp;u2 name_and_type_index;<br>}</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>11</td>
<td>CONSTANT_InterfaceMethodref</td>
<td>CONSTANT_InterfaceMethodref_info {<br>    &nbsp;u1 tag;<br>    &nbsp;u2 class_index;;//索引值<br>    &nbsp;u2 name_and_type_index;<br>}</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>12</td>
<td>CONSTANT_NameAndType_info</td>
<td>CONSTANT_NameAndType_info {<br>    &nbsp;u1 tag;<br>    &nbsp;&nbsp;u2 name_index;<br>    &nbsp;&nbsp;u2 descriptor_index;<br>}</td>
<td>接口中方法的符号引用</td>
</tr>
</tbody></table>
<h4 id="三、字段的结构"><a href="#三、字段的结构" class="headerlink" title="三、字段的结构"></a>三、字段的结构</h4><p>每一个字段用一个 field_info的结构体表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;//指向常量池的index，表示字段名</span><br><span class="line">    u2             descriptor_index;//指向常量池的inde，字段的描述符</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、方法的结构"><a href="#四、方法的结构" class="headerlink" title="四、方法的结构"></a>四、方法的结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;</span><br><span class="line">    u2             descriptor_index;</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];//Code字节码信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、属性的结构"><a href="#五、属性的结构" class="headerlink" title="五、属性的结构"></a>五、属性的结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4">Chapter 4. The class File Format</a>  </p>
<p><a href="https://www.jianshu.com/p/ae3f860499aa">Java Class文件结构解析</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>重定位</title>
    <url>/file-format-elf-relocation.html</url>
    <content><![CDATA[<h4 id="一、可重定位文件"><a href="#一、可重定位文件" class="headerlink" title="一、可重定位文件"></a>一、可重定位文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//main.c                    //x.c</span><br><span class="line"></span><br><span class="line">extern void foo(void);      |   #include &lt;stdio.h&gt;</span><br><span class="line">                            |</span><br><span class="line">int main(void)              |   void foo()</span><br><span class="line">&#123;                           |   &#123;</span><br><span class="line">    foo();                  |       printf(&quot;foo\n&quot;);</span><br><span class="line">    return 0;               |   &#125;</span><br><span class="line">&#125;                           |</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; objdump -d main.o</span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:	55                   	push   %ebp</span><br><span class="line">   1:	89 e5                	mov    %esp,%ebp</span><br><span class="line">   3:	83 e4 f0             	and    $0xfffffff0,%esp</span><br><span class="line">   6:	e8 fc ff ff ff       	call   7 &lt;main+0x7&gt;</span><br><span class="line">   b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  10:	c9                   	leave</span><br><span class="line">  11:	c3                   	ret</span><br></pre></td></tr></table></figure>

<p>在编译和汇编阶段，[main.c -&gt; main.o] 汇编器无法确定外部定义的函数和全局变量的地址，所以它只能使用一个假地址占位，并产生一条额外的记录，让后面的链接器使用这条记录帮它完成地址修正。这条记录对于代码段来说放在[.rel.text] ，对于数据段来说放在[.rel.data],它们都是重定位文件的一个section。</p>
<p>对于每一条记录都对应于如下的一个数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">        Elf32_Addr r_offset;</span><br><span class="line">        uint32_t   r_info;</span><br><span class="line">        int32_t    r_addend;</span><br><span class="line">&#125; Elf32_Rela;</span><br></pre></td></tr></table></figure>


<h4 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h4><p>1、多个目标文件的合并:</p>
<center>
    <img src="../images/elf_obj_file_merge.png" width="500"/>
</center>

<p>2、对代码段，数据段以及各符号进行地址分配<br>3、根据 [relocation entries] 重新计算代码和数据段中的假地址。</p>
<h4 id="三、动态链接"><a href="#三、动态链接" class="headerlink" title="三、动态链接"></a>三、动态链接</h4><h5 id="1、静态链接的缺点"><a href="#1、静态链接的缺点" class="headerlink" title="1、静态链接的缺点"></a>1、静态链接的缺点</h5><ul>
<li>静态链接将使一些公用代码如libc库产生冗余，浪费内存和磁盘空间</li>
<li>如果模块化开发，一个模块更新就得重新链接</li>
</ul>
<h5 id="2、动态链接的概念"><a href="#2、动态链接的概念" class="headerlink" title="2、动态链接的概念"></a>2、动态链接的概念</h5><p>相较于静态链接在编译期进行链接操作，将链接过程推迟到运行时进行的过程叫动态链接。</p>
<h5 id="3、动态链接的实现"><a href="#3、动态链接的实现" class="headerlink" title="3、动态链接的实现"></a>3、动态链接的实现</h5><p>   3.1 地址无关代码<br>    由于在运行时，代码段是共享的，只能读不能写，所以需要将指令中那些需要修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每一个进程中拥有一个副本。</p>
<p>   3.2 全局偏移表（Global Offset Table）<br>    当链接过程发生在运行期时，外部的符号调用只有在运行时装载模块后才能确定模块被装载的地址，以及模块内符号的确切地址。所以ELF提供了一个全局偏移表（GOT）来记录这些外部模块的符号引用。当模块被装载时，会更新此表的内容。</p>
<h4 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h4><p>1.<a href="https://people.cs.pitt.edu/~xianeizhang/notes/Linking.html#symbol">Linking</a><br>2.<a href="https://stac47.github.io/c/relocation/elf/tutorial/2018/03/01/understanding-relocation-elf.html">understanding-relocation-elf</a><br>3.<a href="http://stffrdhrn.github.io/hardware/embedded/openrisc/2019/11/29/relocs.html">ELF Binaries and Relocation Entries</a><br>4.<a href="http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/">static-linking-dynamic-linking</a><br>5.<a href="https://blog.csdn.net/ayu_ag/article/details/78655300">ELF函数重定位问题</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件的结构</title>
    <url>/file-format-elf.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>代码是解决问题的工具。当通过编码方式解决一个问题时，通常有如下步骤：</p>
<ul>
<li>定义问题</li>
<li>设计解决方案</li>
<li>编码实现方案</li>
<li>测试程序</li>
</ul>
<p>编码实现通常是我们利用计算机高级语言书写的，符合一定逻辑的程序代码，这种含逻辑的代码计算机是无法理解的，它能理解的只是一条条由0和1组成的指令即机器语言。所以这就涉及从高级语言到机器语言的翻译和转换过程，处理这个过程的程序叫<strong>编译器</strong>。</p>
<p>编译器这个程序，很庞大很复杂，为了让它简洁，好控制，我们把它拆成四个部分：</p>
<ul>
<li>预处理器</li>
<li>编译器</li>
<li>汇编器</li>
<li>链接器</li>
</ul>
<p>每一个阶段基本上都是在为下一个阶段做准备，它的过程如下图所示：</p>
<center>
    <img src="../images/GCC_CompilationProcess.png" width="500"/>
</center>

<p>预处理器（Preprocessor）处理代码的过程叫预处理阶段，它所做的工作包括：</p>
<ul>
<li>#define宏定义展开</li>
<li>处理条件编译指令</li>
<li>处理#include指令</li>
<li>删除注释</li>
<li>添加行号</li>
<li>保留#pragma指令</li>
</ul>
<p>编译器（Compiler）处理代码的过程叫编译，它主要是将上一步的产物转换成汇编代码，它的工作内容包括：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>优化</li>
</ul>
<p>汇编器（Assembler）处理代码的过程叫汇编过程，它主要将汇编代码转换成二进制的机器码</p>
<ul>
<li>汇编码到机器码的翻译</li>
</ul>
<p>链接器（Linker）处理代码的过程叫链接过程，多个文件合并成一个文件</p>
<ul>
<li>空间与地址分配-相同部分合并</li>
<li>符号解析和重定位-合并后位置（偏移量）调整</li>
</ul>
<p>综上可知，目标文件是程序未链接前的一个中间文件。目标文件内容的存储方式符合ELF文件标准，所以他是一种特殊的ELF文件。</p>
<h4 id="二、文件结构解析"><a href="#二、文件结构解析" class="headerlink" title="二、文件结构解析"></a>二、文件结构解析</h4><p>目标文件其实是ELF文件的一种，常见的ELF文件还有.so和.oat文件等。ELF文件存在两种观察角度，分别是编译角度和运行角度。编译角度是指，在代码编译阶段的存储格式。运行角度是指，文件被加载进内存时的存储格式。<br>两个角度看到的结构略有差异。如图：</p>
<center>
    <img src="../images/elf_format_overview.jpeg" width="500"/>
</center>

<p>从图中可以得到这样一些信息：<br>1、Program Header Table对于编译视图是可选的，因为它只在程序被加载进内存时使用到。Section Header Table对于执行视图是可选的。<br>2、编译视图是以section为组织单位，执行视图是以segment为组织单位（多个section会被映射到同一个segment）。</p>
<p>下面介绍一些重要的结构。</p>
<h5 id="ELF-Header-文件的总体结构"><a href="#ELF-Header-文件的总体结构" class="headerlink" title="ELF Header-文件的总体结构"></a>ELF Header-文件的总体结构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define EI_NIDENT 16</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    unsigned char e_ident[EI_NIDENT];</span><br><span class="line">    Elf32_Half e_type;               /* 此elf文件的类型见下表  */</span><br><span class="line">    Elf32_Half e_machine;            /* CPU平台架构  */</span><br><span class="line">    Elf32_Word e_version;            /* 此文件的版本  */</span><br><span class="line">    Elf32_Addr e_entry;              /* 加载完该程序后的执行入口  */</span><br><span class="line">    Elf32_Off e_phoff;               /* program header table在文件中的偏移量  */</span><br><span class="line">    Elf32_Off e_shoff;               /* section header table在此文件中的偏移量 */</span><br><span class="line">    Elf32_Word e_flags;              /* processor-specific flags associated with the file */</span><br><span class="line">    Elf32_Half e_ehsize;             /* the ELF header&#x27;s size in bytes. */</span><br><span class="line">    Elf32_Half e_phentsize;          /* program-header-table数组中一个元素的大小 */</span><br><span class="line">    Elf32_Half e_phnum;              /* program-header-table数组元素的个数 */</span><br><span class="line">    Elf32_Half e_shentsize;          /* section header table数组中一个元素的大小 */</span><br><span class="line">    Elf32_Half e_shnum;              /* section header table包含的元素个数 */</span><br><span class="line">    Elf32_Half e_shstrndx;           /* the section header table index of the entry associated with the section name string table. */</span><br><span class="line"> &#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>文件类型</th>
<th>类型描述</th>
</tr>
</thead>
<tbody><tr>
<td>ET_NONE</td>
<td>未知类型。这个标记表明文件类型不确定，或者还未定义。</td>
</tr>
<tr>
<td>ET_REL</td>
<td>重定位文件。 ELF 类型标记为 relocatable 意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位 目标文件通常是还未被链接到可执行程序的一段位置独立的代码 （position independent code）。 在编译完代码之后通常可以看到一 个.o 格式的文件， 这种文件包含了创建可执行文件所需要的代码 和数据。</td>
</tr>
<tr>
<td>ET_EXEC</td>
<td>可执行文件。ELF 类型为 executable，表明这个文件被标 记为可执行文件。这种类型的文件也称为程序，是一个进程开始执 行的入口。</td>
</tr>
<tr>
<td>ET_DYN</td>
<td>共享目标文件。ELF 类型为 dynamic，意味着该文件被标记 为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在 程序运行时被装载并链接到程序的进程镜像中。</td>
</tr>
<tr>
<td>ET_CORE</td>
<td>核心文件。在程序崩溃或者进程传递了一个 SIGSEGV 信 号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以 使用 GDB 读取这类文件来辅助调试并查找程序崩溃的原因。</td>
</tr>
</tbody></table>
<blockquote>
<p>file /bin/bash     //executable<br>file /xxx/xx.so   //shared object</p>
</blockquote>
<h5 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h5><p>程序装载时，根据此结构的信息对文件进行分段（segment）。描述了磁盘上可执行文件的内存布局以及如何映射到内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">   uint32_t   p_type;   /* 此元素描述的是哪种segment，以及如何解析  */</span><br><span class="line">   Elf32_Off  p_offset; /* segment首字节在文件中的偏移值  */</span><br><span class="line">   Elf32_Addr p_vaddr;  /* 应该加载到内存中的哪个虚拟地址中  */</span><br><span class="line">   Elf32_Addr p_paddr;  /* 相关的物理地址，BSD中为0  */</span><br><span class="line">   uint32_t   p_filesz; /* 文件的字节数  */</span><br><span class="line">   uint32_t   p_memsz;  /* 加载到内存中的字节数  */</span><br><span class="line">   uint32_t   p_flags;  /* segment类型标志位  */</span><br><span class="line">   uint32_t   p_align;  /* 内存对齐  */</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>p_flags</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_X</td>
<td>An executable segment.</td>
</tr>
<tr>
<td>PF_W</td>
<td>A writable segment.</td>
</tr>
<tr>
<td>PF_R</td>
<td>A readable segment.</td>
</tr>
</tbody></table>
<h5 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h5><p>用于定位文件中所有的section，主要用于链接和调试，没有Section Header Table程序仍然可以正常运行，因为它没有对内存布局进行描述，它是一个元素为Elf32_Shdr的数组结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	Elf32_Word sh_name;      /* Section name (string tbl index)   */</span><br><span class="line">	Elf32_Word sh_type;      /* Section type                      */</span><br><span class="line">	Elf32_Word sh_flags;     /* Section flags                     */</span><br><span class="line">	Elf32_Addr sh_addr;      /* Section virtual addr at execution */</span><br><span class="line">	Elf32_Off sh_offset;     /* Section file offset               */</span><br><span class="line">	Elf32_Word sh_size;      /* Section size in bytes             */</span><br><span class="line">	Elf32_Word sh_link;      /* Link to another section           */</span><br><span class="line">	Elf32_Word sh_info;      /* Additional section information    */</span><br><span class="line">	Elf32_Word sh_addralign; /* Section alignment                 */</span><br><span class="line">	Elf32_Word sh_entsize;   /* Entry size if section holds table */</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Section type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SHT_NULL</td>
<td>This value marks the section header as inactive. It does not have an associated section.  Other members of the section header have undefined values.</td>
</tr>
<tr>
<td>SHT_PROGBITS</td>
<td>This section holds information defined by the program, whose format and meaning are determined solely by the program.</td>
</tr>
<tr>
<td>SHT_SYMTAB</td>
<td>This section holds a symbol table.  Typically, SHT_SYMTAB provides symbols for link editing, though it may also be used for dynamic linking.  As a complete symbol table, it may contain many symbols unnecessary for dynamic linking.  An object file can also contain a SHT_DYNSYM section.</td>
</tr>
<tr>
<td>SHT_STRTAB</td>
<td>This section holds a string table.  An object file may have multiple string table sections.</td>
</tr>
<tr>
<td>SHT_RELA</td>
<td>This section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files.  An object may have multiple relocation sections.</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td>This section holds a symbol hash table.  An object participating in dynamic linking must contain a symbol hash table.  An object file may have only one hash table.</td>
</tr>
<tr>
<td>SHT_DYNAMIC</td>
<td>This section holds information for dynamic linking. An object file may have only one dynamic section.</td>
</tr>
<tr>
<td>SHT_NOTE</td>
<td>This section holds notes (ElfN_Nhdr).</td>
</tr>
<tr>
<td>SHT_NOBITS</td>
<td>A section of this type occupies no space in the  file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</td>
</tr>
<tr>
<td>SHT_REL</td>
<td>This section holds relocation offsets without explicit addends, such as type Elf32_Rel for the 32-bit class of object files.  An object file may have multiple relocation sections.</td>
</tr>
<tr>
<td>SHT_SHLIB</td>
<td>This section is reserved but has unspecified semantics.</td>
</tr>
<tr>
<td>SHT_DYNSYM</td>
<td>This section holds a minimal set of dynamic linking symbols.  An object file can also contain a SHT_SYMTAB section.</td>
</tr>
<tr>
<td>SHT_LOPROC, SHT_HIPROC</td>
<td>Values in the inclusive range [SHT_LOPROC, SHT_HIPROC] are reserved for processor-specific semantics.</td>
</tr>
<tr>
<td>SHT_LOUSER</td>
<td>This value specifies the lower bound of the range of indices reserved for application programs.</td>
</tr>
<tr>
<td>SHT_HIUSER</td>
<td>This value specifies the upper bound of the range of indices reserved for application programs. Section types between SHT_LOUSER and SHT_HIUSER may be used by the application, without conflicting with current or future system-defined section types.</td>
</tr>
</tbody></table>
<h5 id="字符串表和符号表（String-and-symbol-tables）"><a href="#字符串表和符号表（String-and-symbol-tables）" class="headerlink" title="字符串表和符号表（String and symbol tables）"></a>字符串表和符号表（String and symbol tables）</h5><p>存放scetion的名字，以及符号信息。其他结构通过index访问此结构中的字符串信息。符号表保存了用于定位符号引用的信息。它是以下结构的数组：</p>
<center>
    <img src="../images/elf_string_table.jpeg" width="500"/>
</center>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">       uint32_t      st_name;</span><br><span class="line">       Elf32_Addr    st_value;</span><br><span class="line">       uint32_t      st_size;</span><br><span class="line">       unsigned char st_info;</span><br><span class="line">       unsigned char st_other;</span><br><span class="line">       uint16_t      st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>


<h5 id="Relocation-entries-Rel-amp-Rela"><a href="#Relocation-entries-Rel-amp-Rela" class="headerlink" title="Relocation entries (Rel &amp; Rela)"></a>Relocation entries (Rel &amp; Rela)</h5><p>重定位是连接符号引用（函数的名字）和符号定义（函数的定义、函数的实现）的过程。重定位文件必须包含如何修改section内容的信息，来让执行文件或共享目标文件正确的调用外部函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">        Elf32_Addr      r_offset;</span><br><span class="line">        Elf32_Word      r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">        Elf32_Addr      r_offset;</span><br><span class="line">        Elf32_Word      r_info;</span><br><span class="line">        Elf32_Sword     r_addend;</span><br><span class="line">&#125; Elf32_Rela;</span><br></pre></td></tr></table></figure>
<p>r_offset：<br>对于重定位文件来说，此值表示从section的开始到被修改值在section中的偏移量。<br>对于执行文件和共享库文件来说，此值表示需要被重定位的虚拟地址。</p>
<p>r_info：<br>符号表的index和重定位的类型。</p>
<p>r_addend：<br>用于计算重定位字段的值。</p>
<h5 id="Dynamic-tags（Dyn）"><a href="#Dynamic-tags（Dyn）" class="headerlink" title="Dynamic tags（Dyn）"></a>Dynamic tags（Dyn）</h5><p><code>.dynamic</code>这个section存储一些包含动态链接信息的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">        Elf32_Sword    d_tag;</span><br><span class="line">        union &#123;</span><br><span class="line">            Elf32_Word d_val;</span><br><span class="line">            Elf32_Addr d_ptr;</span><br><span class="line">        &#125; d_un;</span><br><span class="line"> &#125; Elf32_Dyn;</span><br><span class="line">           </span><br><span class="line">extern Elf64_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure>

<h4 id="一些图示"><a href="#一些图示" class="headerlink" title="一些图示"></a>一些图示</h4><center>
    <img src="../images/file/elf_file_format-overview.jpeg" width="500"/>
</center>

<center>
    <img src="../images/file/elf-64-bit-overview.png" width="500"/>
</center>

<h4 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h4><p><a href="https://www.man7.org/linux/man-pages/man5/elf.5.html">Linux manual page</a><br><a href="https://www.codetd.com/article/489055">The structure of an ARM ELF image</a><br><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">Compiling, Linking and Building</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter状态管理之BloC</title>
    <url>/flutter-state-bloc.html</url>
    <content><![CDATA[<hr>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>Bloc = Business Logic Component</p>
<center>
    <img src="../images/flutter/bloc_architecture.png" width="60%"/>
</center>


<h4 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h4><p>BloC本身是一个独立的package、flutter-bloc基于BloC和Provider实现，其结构如下图所示：</p>
<center>
    <img src="../images/flutter/flutter_bloc.png" width="100%"/>
</center>

<h4 id="三、-实现"><a href="#三、-实现" class="headerlink" title="三、 实现"></a>三、 实现</h4><h5 id="3-1-BloC是基于dart的Stream-API实现的发布订阅模式。"><a href="#3-1-BloC是基于dart的Stream-API实现的发布订阅模式。" class="headerlink" title="3.1 BloC是基于dart的Stream API实现的发布订阅模式。"></a>3.1 BloC是基于dart的Stream API实现的发布订阅模式。</h5><ul>
<li>通过on方法订阅事件并提供处理函数，收到Event再将Event转换成State返回给Bloc</li>
<li>通过add方法发布事件</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bloc</span>&lt;<span class="title">Event</span>, <span class="title">State</span>&gt; <span class="keyword">extends</span> <span class="title">BlocBase</span>&lt;<span class="title">State</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlocEventSink</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//所有的订阅者</span></span><br><span class="line">     <span class="keyword">final</span> _subscriptions = &lt;StreamSubscription&lt;<span class="built_in">dynamic</span>&gt;&gt;[];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">final</span> _eventController = StreamController&lt;Event&gt;.broadcast();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//添加订阅者</span></span><br><span class="line">     <span class="keyword">void</span> <span class="keyword">on</span>&lt;E <span class="keyword">extends</span> Event&gt;(</span><br><span class="line">       EventHandler&lt;E, State&gt; handler, &#123;</span><br><span class="line">       EventTransformer&lt;E&gt;? transformer,</span><br><span class="line">     &#125;) &#123;</span><br><span class="line">        <span class="comment">//这里开始了listen</span></span><br><span class="line">        <span class="keyword">final</span> subscription = xxx.listen(<span class="keyword">null</span>);</span><br><span class="line">        _subscriptions.add(subscription);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@override</span></span><br><span class="line">     <span class="keyword">void</span> add(Event event) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         onEvent(event);</span><br><span class="line">         _eventController.add(event);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">         onError(error, stackTrace);</span><br><span class="line">         <span class="keyword">rethrow</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>
    <img src="../images/flutter/flutter-bloc-inner.png" width="50%"/>
</center>


<h5 id="3-1-事件和状态之间的转换"><a href="#3-1-事件和状态之间的转换" class="headerlink" title="3.1 事件和状态之间的转换"></a>3.1 事件和状态之间的转换</h5><ul>
<li>转换逻辑有业务层通过on()注入</li>
<li>内部的核心是_Emitter以及 <em>_eventController</em> 和 <em>_stateController</em></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">dynamic</span> event) &#123;</span><br><span class="line">       <span class="keyword">void</span> onEmit(State state) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isClosed) <span class="keyword">return</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.state == state &amp;&amp; _emitted) <span class="keyword">return</span>;</span><br><span class="line">         onTransition(Transition(</span><br><span class="line">           currentState: <span class="keyword">this</span>.state,</span><br><span class="line">           event: event <span class="keyword">as</span> E,</span><br><span class="line">           nextState: state,</span><br><span class="line">         ));</span><br><span class="line">         emit(state);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> emitter = _Emitter(onEmit);</span><br><span class="line">       <span class="keyword">final</span> controller = StreamController&lt;E&gt;.broadcast(</span><br><span class="line">         <span class="keyword">sync</span>: <span class="keyword">true</span>,</span><br><span class="line">         onCancel: emitter.cancel,</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">void</span> handleEvent() <span class="keyword">async</span> &#123;</span><br><span class="line">         <span class="keyword">void</span> onDone() &#123;</span><br><span class="line">           emitter.complete();</span><br><span class="line">           _emitters.remove(emitter);</span><br><span class="line">           <span class="keyword">if</span> (!controller.isClosed) controller.close();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           _emitters.add(emitter);</span><br><span class="line">           <span class="comment">//交给外部实现转换事件和状态</span></span><br><span class="line">           <span class="keyword">await</span> handler(event <span class="keyword">as</span> E, emitter);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">           onError(error, stackTrace);</span><br><span class="line">           <span class="keyword">rethrow</span>;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           onDone();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       handleEvent();</span><br><span class="line">       <span class="keyword">return</span> controller.stream;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<h4 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h4><p>主要参考和debug了bloc仓库里面examples中login的例子：<br><a href="https://github.com/felangel/bloc/tree/master/examples/flutter_login">这里</a></p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter状态管理之Provider</title>
    <url>/flutter-state-provider.html</url>
    <content><![CDATA[<hr>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>官方提供的一个简单的状态管理库。</p>
<p>关键点：</p>
<ul>
<li>提取状态:状态变量和UI分离</li>
<li>访问状态:将UI和状态建立联系</li>
<li>使用状态:读取状态变量</li>
</ul>
<center>
    <img src="../images/ui-equals-function-of-state.png" width="100%"/>
</center>

<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>1、InheritedWidget</p>
<center>
    <img src="../images/flutter/flutter-inheritedwidget.png" width="100%"/>
</center>

<p>关键点：</p>
<ul>
<li>Element持有Widget对象</li>
<li>Element也是一个BuildContext对象</li>
<li>Element里面持有所有的<code>InheritedElement</code></li>
</ul>
<p>所以：通过BuildContext对象可以拿到所需的Widget对象，然后访问里面的数据。</p>
<p>父节点存放数据</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedShareWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> data;<span class="comment">//用于共享的数据</span></span><br><span class="line">  InheritedShareWidget(&#123;<span class="keyword">this</span>.data, Widget child&#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义便捷方法，方便子控件获取共享数据</span></span><br><span class="line">  <span class="keyword">static</span> InheritedShareWidget of(BuildContext context) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">///<span class="markdown">当子控件依赖使用了我们的数据源时，数据变动会触发子控件中的 didChangeDependencies 方法</span></span></span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;InheritedShareWidget&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">///<span class="markdown">（前提：子控件使用了数据源）子控件中的 didChangeDependencies 方法不会被触发</span></span></span><br><span class="line">    <span class="comment">// return context.getElementForInheritedWidgetOfExactType&lt;InheritedShareWidget&gt;().widget;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> InheritedShareWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.data != <span class="keyword">this</span>.data;<span class="comment">//返回true时，才会通知子控件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子节点获取数据：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestShareChildWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TestShareChildWidget(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TestShareChildWidgetState createState() =&gt; _TestShareChildWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestShareChildWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TestShareChildWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">如build 方法中没有使用 InheritedShareWidget 的数据，那么它的didChangeDependencies()将不会被调用</span></span></span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;enter didChangeDependencies&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;enter child build&quot;</span>);</span><br><span class="line">    <span class="comment">//获取Inherited的共享数据：</span></span><br><span class="line">    <span class="keyword">final</span> data = InheritedShareWidget.of(context).data.toString();</span><br><span class="line">    <span class="keyword">return</span> Text(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子节点嵌套：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestInheritedWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TestInheritedWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: InheritedShareWidget(</span><br><span class="line">        data: count,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: [</span><br><span class="line">            TestShareChildWidget(),</span><br><span class="line">            RaisedButton(</span><br><span class="line">                child: Text(<span class="string">&#x27;add&#x27;</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  setState(() &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">          ],),),);&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>2、InheritedProvider</p>
<center>
    <img src="../images/flutter/flutter-inheritedprovider.jpg" width="100%"/>
</center>

<p>关键点：</p>
<ul>
<li>通过<code>InheritedProvider</code>及其子类（如：ChangeNotifierProvider）来包裹其他Widget（child），其实是将child放入了<code>_InheritedProviderScope</code></li>
<li><code>_InheritedProviderScope</code>是一个<code>InheritedWidget</code>所以，<code>InheritedProvider</code>及其子类将会持有child对象，及其数据。</li>
</ul>
<h4 id="Provider的基本使用"><a href="#Provider的基本使用" class="headerlink" title="Provider的基本使用"></a>Provider的基本使用</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">///<span class="markdown">这是状态</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name = <span class="string">&quot;ChangeNotifierProvider&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> changName(&#123;<span class="keyword">required</span> <span class="built_in">String</span> newName&#125;) &#123;</span><br><span class="line">    name = newName;</span><br><span class="line">    notifyListeners();<span class="comment">//1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MainApp(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ChangeNotifierProvider&lt;Person&gt;(<span class="comment">///<span class="markdown">状态和UI之间建立联系</span></span></span><br><span class="line">      create: (ctx) =&gt; Person(),</span><br><span class="line">      child: <span class="keyword">const</span> MaterialApp(</span><br><span class="line">        home: ChangeNotifierProviderDemo(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeNotifierProviderDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ChangeNotifierProviderDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: <span class="keyword">const</span> Text(<span class="string">&quot;ChangeNotifierProvider&quot;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">          children: [</span><br><span class="line">            Consumer&lt;Person&gt;(<span class="comment">///<span class="markdown">使用状态</span></span></span><br><span class="line">              builder: (ctx, person, child) =&gt; Text(person.name),</span><br><span class="line">            ),</span><br><span class="line">            Consumer&lt;Person&gt;(</span><br><span class="line">              builder: (ctx, person, child) &#123;</span><br><span class="line">                <span class="keyword">return</span> ElevatedButton(</span><br><span class="line">                  onPressed: () =&gt; person.changName(newName: <span class="string">&quot;ChangeNotifierProvider更新了&quot;</span>),</span><br><span class="line">                  child: <span class="keyword">const</span> Text(<span class="string">&quot;点击更新&quot;</span>),</span><br><span class="line">                );&#125;,),],),),);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Provider的类结构"><a href="#Provider的类结构" class="headerlink" title="Provider的类结构"></a>Provider的类结构</h4><center>
    <img src="../images/flutter/flutter_provider.png" width="100%"/>
</center>


<p>3.1 InheritedProvider的子类只是具体功能的实现，基础逻辑封装在InheritedProvider中<br>3.2 InheritedProvider将职责转嫁给_InheritedProviderScope而_InheritedProviderScope是一个InheritedWidget</p>
<h4 id="如何实现监听"><a href="#如何实现监听" class="headerlink" title="如何实现监听"></a>如何实现监听</h4><p>1、数据实现了ChangeNotifier，变更后调用notifyListeners(),触发回调。</p>
<p>2、ChangeNotifierProvider继承自ListenableProvider，ListenableProvider构建时开启监听：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> VoidCallback _startListening(</span><br><span class="line">  InheritedContext e,</span><br><span class="line">  Listenable? value,</span><br><span class="line">) &#123;</span><br><span class="line">  value?.addListener(e.markNeedsNotifyDependents);</span><br><span class="line">  <span class="keyword">return</span> () =&gt; value?.removeListener(e.markNeedsNotifyDependents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class InheritedContext extends BuildContext{<br>    void markNeedsNotifyDependents();<br>}</p>
<p>3、markNeedsNotifyDependents是<code>InheritedContext</code>中的方法，其实现类是<code>_InheritedProviderScopeElement</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> markNeedsNotifyDependents() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isNotifyDependentsEnabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    markNeedsBuild();</span><br><span class="line">    _shouldNotifyDependents = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>4、markNeedsBuild是Element的方法：标记需要重新构建</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    owner!.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h4><p>Provider的<code>Selector</code>提供了缓存Widget的功能，当Widget没有变化时，将直接返回缓存，否则重新build。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Selector0State</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SingleChildState</span>&lt;<span class="title">Selector0</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  T? value;</span><br><span class="line">  Widget? cache;<span class="comment">//这是缓存</span></span><br><span class="line">  Widget? oldWidget;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildWithChild(BuildContext context, Widget? child) &#123;</span><br><span class="line">    <span class="keyword">final</span> selected = widget.selector(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> shouldInvalidateCache = oldWidget != widget ||</span><br><span class="line">        (widget._shouldRebuild != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            widget._shouldRebuild!(value <span class="keyword">as</span> T, selected)) ||</span><br><span class="line">        (widget._shouldRebuild == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !<span class="keyword">const</span> DeepCollectionEquality().equals(value, selected));</span><br><span class="line">    <span class="keyword">if</span> (shouldInvalidateCache) &#123;<span class="comment">//需要重新构建</span></span><br><span class="line">      value = selected;</span><br><span class="line">      oldWidget = widget;</span><br><span class="line">      cache = widget.builder(</span><br><span class="line">        context,</span><br><span class="line">        selected,</span><br><span class="line">        child,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.add(DiagnosticsProperty&lt;T&gt;(<span class="string">&#x27;value&#x27;</span>, value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.cn/post/7067356022272163847#heading-16">https://juejin.cn/post/7067356022272163847#heading-16</a></p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Widget之Row、Column</title>
    <url>/flutter-widget-row.html</url>
    <content><![CDATA[<h4 id="Row和Column分别在横向和纵向对子Widget进行布局。"><a href="#Row和Column分别在横向和纵向对子Widget进行布局。" class="headerlink" title="Row和Column分别在横向和纵向对子Widget进行布局。"></a>Row和Column分别在横向和纵向对子Widget进行布局。</h4><ul>
<li>对于Row来讲，横向是主轴，纵向是交叉轴。</li>
<li>对于Column来讲，横向是交叉轴，纵向是主轴。</li>
</ul>
<p>针对主轴和交叉轴，不同大小的子Widget该如何对齐呢？Flutter提供了下列属性：</p>
<h4 id="MainAxisAlignment：主轴对齐方式"><a href="#MainAxisAlignment：主轴对齐方式" class="headerlink" title="MainAxisAlignment：主轴对齐方式"></a>MainAxisAlignment：主轴对齐方式</h4><table>
<thead>
<tr>
<th>属性值</th>
<th>解释</th>
<th>图示</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>靠近主轴的开始</td>
<td><center><img src="../images/flutter/flutter_row_start.png"/></center></td>
</tr>
<tr>
<td>end</td>
<td>靠近主轴的末尾</td>
<td><center><img src="../images/flutter/flutter_row_end.png"/></center></td>
</tr>
<tr>
<td>center</td>
<td>靠近主轴中间</td>
<td><center><img src="../images/flutter/flutter_row_center.png"/></center></td>
</tr>
<tr>
<td>spaceBetween</td>
<td>剩余空间在孩子中间平分</td>
<td><center><img src="../images/flutter/flutter_row_space_between.png"/></center></td>
</tr>
<tr>
<td>spaceAround</td>
<td>剩余空间围绕孩子平分</td>
<td><center><img src="../images/flutter/flutter_row_space_around.png"/></center></td>
</tr>
<tr>
<td>spaceEvenly</td>
<td>剩余空间在孩子之间均等分配</td>
<td><center><img src="../images/flutter/flutter_row_space_evenly.png"/></center></td>
</tr>
</tbody></table>
<h4 id="CrossAxisAlignment-交叉轴对齐方式"><a href="#CrossAxisAlignment-交叉轴对齐方式" class="headerlink" title="CrossAxisAlignment:交叉轴对齐方式"></a>CrossAxisAlignment:交叉轴对齐方式</h4><table>
<thead>
<tr>
<th>属性值</th>
<th>解释</th>
<th>图示</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>左对齐(Column)或上对齐(Row)</td>
<td><center><img src="../images/flutter/cross_axis_start.jpeg" width="50%"/></center></td>
</tr>
<tr>
<td>end</td>
<td>右对齐(Column)或下对齐(Row)</td>
<td><center><img src="../images/flutter/cross_axis_end.jpeg" width="50%"/></center></td>
</tr>
<tr>
<td>center</td>
<td>中间对齐</td>
<td><center><img src="../images/flutter/cross_axis_center.jpeg" width="50%"/></center></td>
</tr>
<tr>
<td>stretch</td>
<td>拉伸</td>
<td><center><img src="../images/flutter/cross_axis_stretch.jpeg" width="50%"/></center></td>
</tr>
<tr>
<td>baseline</td>
<td>基线对齐,需要配合textBaseline属性使用</td>
<td><center><img src="../images/flutter/cross_axis_baseline.jpg" width="50%"/></center></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Java synchronized</title>
    <url>/java-multithreading-synchronized.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>synchronized作为Java内建的关键字和锁机制，理解和使用它是必要的也是有难度的。个人认为深入理解此关键字在于以下几个方面：</p>
<ul>
<li>基础层面：正确理解对象锁和类锁，并熟练使用</li>
<li>能力提升：<ul>
<li>了解对象的内存布局，观察锁如何影响对象的内存布局</li>
<li>了解锁优化，锁升级及其过程</li>
</ul>
</li>
<li>更上一层楼：OpenJDK源码走读</li>
</ul>
<p>本文只是记录和翻译了一些英文文档的内容，作为笔记以后翻阅。详细内容可看原文。</p>
<h4 id="二、对象锁和类锁"><a href="#二、对象锁和类锁" class="headerlink" title="二、对象锁和类锁"></a>二、对象锁和类锁</h4><p>1.1 对象锁：修饰代码块和实例方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//此代码块锁住当前对象</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>1.2 类锁:修饰代码块和静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClazzLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ClazzLock.class) &#123;<span class="comment">//此代码块锁住class类</span></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 静态方法属于类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、锁优化"><a href="#三、锁优化" class="headerlink" title="三、锁优化"></a>三、锁优化</h4><p>依据一：数据显示，许多锁有局部性特征，也就是说很多锁的锁定和释放都发生在特定的线程上。<br>依据二：数据显示，大部分Java对象不存在竞争。</p>
<ul>
<li>适应性自旋-Adaptive Spinning</li>
<li>锁消除-Lock Elimination</li>
<li>锁粗化-Lock Coarsening</li>
<li>轻量级锁-Lightweight Locking</li>
<li>偏向锁-Biased Locking</li>
</ul>
<h5 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h5><p>当我们开发了一个多线程环境下的模块时，其他人可能把它用在单线程环境下，此时加锁逻辑就是多余的。即使使用轻量级锁，每次获取锁都执行CAS原子指令也是一种性能损耗。使用偏向锁，线程首次获取锁时记录偏向于它自己,当有其他线程获取锁时，偏向锁要撤销，使用其他锁机制，如轻量级锁。</p>
<p>lock-field中有一个bit用于记录是否偏向状态，初始状态下是处于偏向锁状态，但没有设置偏向的线程ID。当线程首次获取锁时，发现没有指定偏向的线程，则使用CAS设置偏向线程，来避免竞态条件。</p>
<h5 id="3-2-轻量级锁（Thin-Lock）"><a href="#3-2-轻量级锁（Thin-Lock）" class="headerlink" title="3.2 轻量级锁（Thin Lock）"></a>3.2 轻量级锁（Thin Lock）</h5><p>相对于每次对象锁定都获取monitor结构的重量级锁而言，轻量级锁只是使用CAS原子指令修改lock-field（锁信息字段），因此轻量级锁不支持wait和notify。当发生锁竞争时，轻量级锁膨胀，同时分配monitor结构，lock-field更新成monitor的指针。</p>
<p>Java的锁是可重入的，所以需要记录当前锁的重入次数和锁的持有者。</p>
<ul>
<li>记录方式一：<br>最直接的方式是把lock-field分成两部分，一个记录锁的持有者，一个记录锁重入次数。由于lock-field字段长度固定，所以重入次数被限制了。重入次数达到上限只能升级为重量级锁。</li>
</ul>
<ul>
<li>记录方式二：<br>当线程需要获取锁时，在获取锁的线程栈中保存lock-records记录。线程获取的所有锁记录都将保存在这个集合中，它的顺序和获取锁的顺序一致。</li>
</ul>
<p>轻量级锁的变种和提升包含 <em>tasuki-lock</em> 和 <em>meta-lock</em> 其算法思想是一致的，差异在于实现细节，</p>
<p>1、轻量级锁的加锁过程</p>
<p>在代码进入同步块的时，如果同步对象锁状态为无锁（锁标志位为“01”，偏向锁位为“0”）虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方称之为 Displaced Mark Word）。然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。<br>否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。<br>而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p>
<center>
    <img src="../images/java-thin-lock-recorder.jpg" width="500"/>
</center>

<pre><code>                 图2.1 轻量级锁CAS操作前/后堆栈与对象的状态
</code></pre>
<p>2、轻量级锁的解锁过程：</p>
<p>（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</p>
<p>（2）如果替换成功，整个同步过程就完成了。</p>
<p>（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</p>
<h5 id="3-3-锁消除"><a href="#3-3-锁消除" class="headerlink" title="3.3 锁消除"></a>3.3 锁消除</h5><p>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        contactString(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">contactString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().append(s1).append(s2).append(s3).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，可以将锁消除。</p>
<h5 id="3-4-锁粗化"><a href="#3-4-锁粗化" class="headerlink" title="3.4 锁粗化"></a>3.4 锁粗化</h5><p>虚拟机对连续的加锁操作（synchronized append）进行范围扩展（粗化）到整个操作序列的外部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1,String s2, String s3)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBUffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h4><p>1.Evaluating and improving biased locking in the HotSpot virtual machine<br>2.<a href="https://www.cnblogs.com/paddix/p/5405678.html">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a><br>3.<a href="https://www.cnblogs.com/zhai1997/p/13546652.html">锁：锁优化（synchronized 锁升级过程、锁消除、锁粗化）</a><br>4.<a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">Synchronization</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的内存布局</title>
    <url>/java-object-layout.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>很多时候我们都有一个疑问：一个对象在内存中占用多大的空间呢？</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/java -jar jol-cli.jar internals java.lang.Object</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">Instantiated the sample instance via default constructor.</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      0     4        (object header)              05 00 00 00 # Mark word</span><br><span class="line">      4     4        (object header)              00 00 00 00 # Mark word</span><br><span class="line">      8     4        (object header)              00 10 00 00 # (not mark word)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>通过OpenJDK的Java-Object-Layout我们看到<code>java.lang.Object</code>的一个实例占用16 bytes。</p>
<p>同样的<code>java.lang.Boolean</code>类型占用的字节数：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">java.lang.Boolean object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12           (object header)                           N/A</span><br><span class="line">     12     1   boolean Boolean.value                             N/A</span><br><span class="line">     13     3           (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 3 bytes external = 3 bytes total</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER: 12 bytes]  12 </span><br><span class="line">[value:   1 byte ]  13</span><br><span class="line">[padding: 3 bytes]  16</span><br></pre></td></tr></table></figure>

<p>其实一个对象通常由三块组成，分别是：对象头、实例数据和对齐填充。</p>
<h4 id="二、对象头（object-header）"><a href="#二、对象头（object-header）" class="headerlink" title="二、对象头（object header）"></a>二、对象头（object header）</h4><p>在前面通过JOL打印输出的关于java.lang.Object信息中，我们看到object header占用12字节，但是输出并没有包含详细的结构信息，我们可以通过<a href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/oop.hpp#l52">Hotspot的源码</a>了解到对象头包含两个部分：<strong>mark word</strong>和<strong>class word</strong>。</p>
<h5 id="2-1-mark-word："><a href="#2-1-mark-word：" class="headerlink" title="2.1 mark word："></a>2.1 <a href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/markWord.hpp#l33">mark word</a>：</h5><p>mark word在32位和64位机分别占32位和64位，当其中锁标志位的值不同时，它前面的bit存储不同的含义。</p>
<ul>
<li>存储对象的gc年龄信息</li>
<li>存储Hashcode</li>
<li>存储锁信息</li>
</ul>
<center>
    <img src="../images/mark-word-64bit.png" width="600"/>
</center>

<h5 id="2-2-class-word"><a href="#2-2-class-word" class="headerlink" title="2.2 class word:"></a>2.2 class word:</h5><p>代码运行的时候，对象只是一串字节，我们可以通过class-word获取一些对象的元信息，它存储指向方法区中表示对象类型的指针，比如以下使用场景：</p>
<ul>
<li>运行时类型检查</li>
<li>决定对象大小</li>
<li>计算接口调用的目标类</li>
</ul>
<h5 id="2-3-数组长度："><a href="#2-3-数组长度：" class="headerlink" title="2.3 数组长度："></a>2.3 数组长度：</h5><p>如果是数组类型，对象头会额外存储数组的长度信息。</p>
<ul>
<li>快速计算对象的大小</li>
<li>数组边界检查</li>
</ul>
<h4 id="三、实例数据和对齐填充"><a href="#三、实例数据和对齐填充" class="headerlink" title="三、实例数据和对齐填充"></a>三、实例数据和对齐填充</h4><p>实例数据即我们在代码中声明的变量等信息，它的存储受到一些规则的约束以及虚拟机参数的控制。</p>
<h5 id="3-1-没有属性的类的内存布局"><a href="#3-1-没有属性的类的内存布局" class="headerlink" title="3.1 没有属性的类的内存布局"></a>3.1 没有属性的类的内存布局</h5><blockquote>
<p>规则一：每个对象都是八字节对齐。</p>
</blockquote>
<p>从前面Object的输出中，我们看到，当一个对象只有头部信息时占用16byte，刚好是8的整数倍。</p>
<h5 id="3-2-Object子类的内存布局"><a href="#3-2-Object子类的内存布局" class="headerlink" title="3.2 Object子类的内存布局"></a>3.2 Object子类的内存布局</h5><p>跟在对象头后面的类属性按照它们的大小在内存中排序，例如：int是4字节、long是8字节。采用字节对齐可以提高性能，因为从内存读取4字节到4字节的寄存器性能更好。</p>
<p>为了节约内存，Sun的虚拟机在分配对象字段的时候和它们声明的顺序不同，有如下顺序规则：</p>
<p>1、double和long类型<br>2、int和float<br>3、short和char<br>4、boolean和byte<br>5、reference</p>
<p>为什么可以优化内存呢？我们看一下这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">boolean</span> d;</span><br><span class="line">    <span class="keyword">long</span> e;</span><br><span class="line">    Object f;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的对象布局如下：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  8 bytes]  8</span><br><span class="line">[a:       1 byte ]  9</span><br><span class="line">[padding: 3 bytes] 12</span><br><span class="line">[c:       4 bytes] 16</span><br><span class="line">[d:       1 byte ] 17</span><br><span class="line">[padding: 7 bytes] 24</span><br><span class="line">[e:       8 bytes] 32</span><br><span class="line">[f:       4 bytes] 36</span><br><span class="line">[padding: 4 bytes] 40</span><br></pre></td></tr></table></figure>
<p>总共使用了40字节内存，其中14个用于内存对齐而浪费掉。如果重排顺序则：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  8 bytes]  8</span><br><span class="line">[e:       8 bytes] 16</span><br><span class="line">[c:       4 bytes] 20</span><br><span class="line">[a:       1 byte ] 21</span><br><span class="line">[d:       1 byte ] 22</span><br><span class="line">[padding: 2 bytes] 24</span><br><span class="line">[f:       4 bytes] 28</span><br><span class="line">[padding: 4 bytes] 32</span><br></pre></td></tr></table></figure>

<p>经过优化后只有6个字节用于对齐填充，总内存也只有32byte。</p>
<h5 id="3-3-子类的内存布局"><a href="#3-3-子类的内存布局" class="headerlink" title="3.3 子类的内存布局"></a>3.3 子类的内存布局</h5><blockquote>
<p>规则三：继承结构中属于不同类的字段不混合在一起。父类优先，子类其次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> a;</span><br><span class="line">   <span class="keyword">int</span> b;</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B类的布局如下：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  8 bytes]  8</span><br><span class="line">[a:       8 bytes] 16</span><br><span class="line">[b:       4 bytes] 20</span><br><span class="line">[c:       4 bytes] 24</span><br><span class="line">[d:       8 bytes] 32</span><br></pre></td></tr></table></figure>

<p>如果父类的字段不符合4字节对齐。</p>
<blockquote>
<p>规则四：父类的最后一个字段和子类第一个字段之间必须4字节对齐。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">byte</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">   <span class="keyword">byte</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  8 bytes]  8</span><br><span class="line">[a:       1 byte ]  9</span><br><span class="line">[padding: 3 bytes] 12</span><br><span class="line">[b:       1 byte ] 13</span><br><span class="line">[padding: 3 bytes] 16</span><br></pre></td></tr></table></figure>
<p>a后面的3个字节就是为了使其4字节对齐。这3个字节只能浪费不能给B使用。</p>
<p>最后一个规则可以用于节约一些内存空间：当子类的第一个属性是long或者double类型且父类没有以8字节边界结束。</p>
<blockquote>
<p>规则五：子类的第一个字段是doubel或long且父类没有以8字节边界结束，JVM打破2的规则，先存储int、short、byte、reference来填补空缺。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> b;</span><br><span class="line">  <span class="keyword">short</span> c;  </span><br><span class="line">  <span class="keyword">byte</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局如下：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  8 bytes]  8</span><br><span class="line">[a:       1 byte ]  9</span><br><span class="line">[padding: 3 bytes] 12</span><br><span class="line">[c:       2 bytes] 14</span><br><span class="line">[d:       1 byte ] 15</span><br><span class="line">[padding: 1 byte ] 16</span><br><span class="line">[b:       8 bytes] 24</span><br></pre></td></tr></table></figure>

<p>在字节12的位置，A类结束了。JVM打破2的规则放入short和byte类型，节约了4字节中的3个字节，否则将浪费掉。</p>
<h5 id="3-4-数组的内存布局"><a href="#3-4-数组的内存布局" class="headerlink" title="3.4 数组的内存布局"></a>3.4 数组的内存布局</h5><p>数组类型有一个额外的头部字段保存数组的长度，接下来是数组的元素，数组作为普通对象也是8字节对齐的。</p>
<p>这是byte[3]的布局：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  12 bytes] 12</span><br><span class="line">[[0]:      1 byte ] 13</span><br><span class="line">[[1]:      1 byte ] 14</span><br><span class="line">[[2]:      1 byte ] 15</span><br><span class="line">[padding:  1 byte ] 16</span><br></pre></td></tr></table></figure>

<p>这是long[3]的布局:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">[HEADER:  12 bytes] 12</span><br><span class="line">[padding:  4 bytes] 16</span><br><span class="line">[[0]:      8 bytes] 24</span><br><span class="line">[[1]:      8 bytes] 32</span><br><span class="line">[[2]:      8 bytes] 40</span><br></pre></td></tr></table></figure>

<h5 id="3-5-内部类的内存布局"><a href="#3-5-内部类的内存布局" class="headerlink" title="3.5 内部类的内存布局"></a>3.5 内部类的内存布局</h5><p>非静态内部类有一个额外的隐藏字段，持有外部类的引用。这个字段是一个常规的引用,它符合对象在内存布局的规则。内部类因此有4字节额外的开销。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>用Kotlin协程解决深度递归问题</title>
    <url>/kotlin-coroutine-deep-recursion.html</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;协程一般用于异步编程。在解决异步编程问题方面，Kotlin编译器在对协程的设计和实现是通用的。我们可以借助协程优雅的解决深度递归问题。</p>
<h4 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h4><p>定义以下二叉树的结点，并构造一棵只含十万个左结点的树，进行深度遍历，求树的深度：  </p>
<center>
    <img src="../images/tree_only_left.png" width="500"/>
</center>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>(<span class="keyword">val</span> left: Tree?, <span class="keyword">val</span> right: Tree?)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造二叉树：以叶子结点开始，重复构造父结点，并把当前结点作为父结点的左子树</span></span><br><span class="line"><span class="keyword">val</span> n = <span class="number">100_000</span></span><br><span class="line"><span class="keyword">val</span> deepTree = generateSequence(Tree(<span class="literal">null</span>, <span class="literal">null</span>)) &#123; prev -&gt;</span><br><span class="line">    Tree(prev, <span class="literal">null</span>) </span><br><span class="line">&#125;.take(n).last()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h4><h5 id="2-1-解决方案一："><a href="#2-1-解决方案一：" class="headerlink" title="2.1 解决方案一："></a>2.1 解决方案一：</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">depth</span><span class="params">(t: <span class="type">Tree</span>?)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="number">0</span> <span class="keyword">else</span> maxOf(</span><br><span class="line">        depth(t.left), <span class="comment">// recursive call one</span></span><br><span class="line">        depth(t.right) <span class="comment">// recursive call two</span></span><br><span class="line">    ) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>分析：<br>对树进行递归是最简洁直接的解决方案。而递归将保存函数的调用栈用于后续状态恢复，线程的调用栈是有大小限制的，此处将抛出<code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code>错误。</p>
<h5 id="2-2-解决方案二："><a href="#2-2-解决方案二：" class="headerlink" title="2.2 解决方案二："></a>2.2 解决方案二：</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">depth</span><span class="params">(t: <span class="type">Tree</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Frame</span></span>(<span class="keyword">val</span> node: Tree, <span class="keyword">var</span> state: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">var</span> depth: <span class="built_in">Int</span> = <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">val</span> stack = ArrayList&lt;Frame&gt;()</span><br><span class="line">      <span class="keyword">val</span> root = Frame(t)</span><br><span class="line">      stack.add(root)</span><br><span class="line">      <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">          <span class="keyword">val</span> frame = stack.last()</span><br><span class="line">          <span class="keyword">when</span> (frame.state++) &#123;</span><br><span class="line">              <span class="number">0</span> -&gt; frame.node.left?.let &#123; l -&gt; stack.add(Frame(l)) &#125;</span><br><span class="line">              <span class="number">1</span> -&gt; frame.node.right?.let &#123; r -&gt; stack.add(Frame(r)) &#125;</span><br><span class="line">              <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                  stack.removeLast()</span><br><span class="line">                  stack.lastOrNull()?.let &#123; p -&gt; </span><br><span class="line">                      p.depth = maxOf(p.depth, frame.depth + <span class="number">1</span>) </span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root.depth</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>分析：<br>基于解决方案一，我们考虑将调用栈状态的保存转移到内存空间更大的堆区，并加入了状态机和<code>while</code>循环。在此例中，程序开始时将全部走状态0，将所有的左节点加入stack。然后全部走状态2(因为没有右结点)，由下到上计算每一个结点的深度。最后返回根节点的深度。</p>
<h5 id="2-3-解决方案三："><a href="#2-3-解决方案三：" class="headerlink" title="2.3 解决方案三："></a>2.3 解决方案三：</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> depth = DeepRecursiveFunction&lt;Tree?, <span class="built_in">Int</span>&gt; &#123; t -&gt;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="number">0</span> <span class="keyword">else</span> maxOf(</span><br><span class="line">            callRecursive(t.left),</span><br><span class="line">            callRecursive(t.right)</span><br><span class="line">        ) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析：<br>方案二中的状态机就是Kotlin挂起函数的实现原理。所以我们也可以利用Kotlin的挂起函数实现深度遍历。那么方案三是如何实现的呢？我们分析三个方面：  </p>
<ul>
<li>如何调用</li>
<li>如何进入循环</li>
<li>如何保存状态</li>
</ul>
<p>2.3.1 调用<br><code>DeepRecursiveFunction</code>类声明了<code>invoke</code>操作符，调用<code>depth</code>函数就是调用下面👇🏻的操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">&quot;1.4&quot;</span>)</span></span><br><span class="line"><span class="meta">@ExperimentalStdlibApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> DeepRecursiveFunction<span class="type">&lt;T, R&gt;</span>.<span class="title">invoke</span><span class="params">(value: <span class="type">T</span>)</span></span>: R =</span><br><span class="line">    DeepRecursiveScopeImpl&lt;T, R&gt;(block, value).runCallLoop()</span><br></pre></td></tr></table></figure>

<p>2.3.2 循环<br>调用<code>DeepRecursiveFunction</code>后直接进入<code>runCallLoop()</code>循环，result的默认值为UNDEFINED_RESULT，所以会启动我们的递归业务逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">runCallLoop</span><span class="params">()</span></span>: R &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">// Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes</span></span><br><span class="line">           <span class="keyword">val</span> result = <span class="keyword">this</span>.result</span><br><span class="line">           <span class="keyword">val</span> cont = <span class="keyword">this</span>.cont</span><br><span class="line">               ?: <span class="keyword">return</span> (result <span class="keyword">as</span> Result&lt;R&gt;).getOrThrow() <span class="comment">// done -- final result</span></span><br><span class="line">           <span class="comment">// The order of comparison is important here for that case of rogue class with broken equals</span></span><br><span class="line">           <span class="keyword">if</span> (UNDEFINED_RESULT == result) &#123;</span><br><span class="line">               <span class="comment">// call &quot;function&quot; with &quot;value&quot; using &quot;cont&quot; as completion</span></span><br><span class="line">               <span class="keyword">val</span> r = <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// This is block.startCoroutine(this, value, cont)</span></span><br><span class="line">                   function.startCoroutineUninterceptedOrReturn(<span class="keyword">this</span>, value, cont)</span><br><span class="line">               &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                   cont.resumeWithException(e)</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// If the function returns without suspension -- calls its continuation immediately</span></span><br><span class="line">               <span class="keyword">if</span> (r !== COROUTINE_SUSPENDED)</span><br><span class="line">                   cont.resume(r <span class="keyword">as</span> R)</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// we returned from a crossFunctionCompletion trampoline -- call resume here</span></span><br><span class="line">               <span class="keyword">this</span>.result = UNDEFINED_RESULT <span class="comment">// reset result back</span></span><br><span class="line">               cont.resumeWith(result)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>2.3.3 状态保存<br>每次调用<code>callRecursive</code>时将保存当前的值和cont（continuation），注意这里cont对象每次都不是同一个对象。当进行挂起恢复时，拿到旧的continuation进行回调。</p>
<center>
    <img src="../images/kotlin_coroutine_resume.jpeg" width="500"/>
</center>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">callRecursive</span><span class="params">(value: <span class="type">T</span>)</span></span>: R = </span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; cont -&gt;</span><br><span class="line">        <span class="keyword">this</span>.cont = cont</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://elizarov.medium.com/deep-recursion-with-coroutines-7c53e15993e3">Deep recursion with coroutines</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin Flow的工作原理</title>
    <url>/kotlin-lang-flow-under-the-hood.html</url>
    <content><![CDATA[<hr>
<p>我们有一个会被重复调用的lambda表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: () -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        print(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f() <span class="comment">// ABC</span></span><br><span class="line">    f() <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们给这个lambda加个参数：<code>(String) -&gt; Unit</code> ,因为参数是个函数，为了能调用到函数，我们把它叫做<code>emit</code>吧：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: ((String) -&gt; <span class="built_in">Unit</span>) -&gt; <span class="built_in">Unit</span> = &#123; emit -&gt; <span class="comment">// 1</span></span><br><span class="line">        emit(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">    f &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加的参数看起来有点乱🤔，稍微修改一下，抽出来吧：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: (FlowCollector) -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        it.emit(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        it.emit(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        it.emit(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">    f &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好像能把<code>it</code>的调用逻辑去掉，这样更简洁：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: FlowCollector.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        emit(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">    f &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用lambda表达式不是很方便。如果把它抽成接口🤔</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> builder: FlowCollector.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        emit(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> flow: Flow = <span class="keyword">object</span> : Flow &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>)</span></span> &#123;</span><br><span class="line">            collector.builder()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flow.collect &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">    flow.collect &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽成可以重复调用的构建器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flow</span><span class="params">(builder: <span class="type">FlowCollector</span>.() -&gt; <span class="type">Unit</span>)</span></span> = <span class="keyword">object</span> : Flow &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>)</span></span> &#123;</span><br><span class="line">        collector.builder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: Flow = flow &#123;</span><br><span class="line">        emit(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f.collect &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">    f.collect &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型化参数更通用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> FlowCollector<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flow</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(builder: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span> = <span class="keyword">object</span> : Flow&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        collector.builder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">        emit(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    f.collect &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">    f.collect &#123; print(it) &#125; <span class="comment">// ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://kt.academy/article/how-flow-works">参考</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin Flow 基础</title>
    <url>/kotlin-lang-flow.html</url>
    <content><![CDATA[<h4 id="一、什么是Flow"><a href="#一、什么是Flow" class="headerlink" title="一、什么是Flow"></a>一、什么是Flow</h4><h5 id="1、如何通过同步和异步方式返回多个值？"><a href="#1、如何通过同步和异步方式返回多个值？" class="headerlink" title="1、如何通过同步和异步方式返回多个值？"></a>1、如何通过同步和异步方式返回多个值？</h5><p>1.1 同步方式返回多个值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.2 同步方式<strong>依次</strong>返回多个值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123; <span class="comment">// sequence builder</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>) <span class="comment">// pretend we are computing it</span></span><br><span class="line">        yield(i) <span class="comment">// yield next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(<span class="string">&quot;time = <span class="subst">$&#123;System.currentTimeMillis()&#125;</span> ,<span class="variable">$value</span>&quot;</span>) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>1.3 异步方式返回多个值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// pretend we are doing something asynchronous here</span></span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().forEach &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.4 如何通过异步的方式<strong>依次</strong>返回多个值呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// flow builder</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Launch a concurrent coroutine to check if the main thread is blocked</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m not blocked <span class="variable">$k</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Collect the flow</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过flow，我们可以实现异步的数据流。</strong></p>
<h5 id="2、Flow是冷数据流"><a href="#2、Flow是冷数据流" class="headerlink" title="2、Flow是冷数据流"></a>2、Flow是冷数据流</h5><p>冷数据流：每次调用<code>collect</code>函数时都会触发执行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    println(<span class="string">&quot;Flow started&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    println(<span class="string">&quot;Calling simple function...&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> flow = simple()</span><br><span class="line">    println(<span class="string">&quot;Calling collect...&quot;</span>)</span><br><span class="line">    flow.collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">    println(<span class="string">&quot;Calling collect again...&quot;</span>)</span><br><span class="line">    flow.collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、Flow的取消"><a href="#3、Flow的取消" class="headerlink" title="3、Flow的取消"></a>3、Flow的取消</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)          </span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">250</span>) &#123; <span class="comment">// Timeout after 250ms </span></span><br><span class="line">        simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4、如何构建Flow？"><a href="#4、如何构建Flow？" class="headerlink" title="4、如何构建Flow？"></a>4、如何构建Flow？</h5><ul>
<li><code>flow&#123; ... &#125;</code></li>
<li><code>flowOf</code></li>
<li><code>.asFlow()</code></li>
</ul>
<h5 id="5、Flow操作符"><a href="#5、Flow操作符" class="headerlink" title="5、Flow操作符"></a>5、Flow操作符</h5><p>5.1 中间操作符</p>
<ul>
<li>map</li>
<li>filter</li>
<li>transform</li>
<li>take</li>
</ul>
<p>5.2 终止操作符</p>
<ul>
<li>collect</li>
<li>toList / toSet</li>
<li>first / single</li>
<li>reduce / fold</li>
</ul>
<p>5.3 <code>buffer</code>当流的处理速度慢于发射速度时，通过buffer提前缓存可以提高效率： </p>
<p>优化前：耗时1200ms</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple().collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后：耗时1000ms</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .buffer() <span class="comment">// buffer emissions, don&#x27;t wait</span></span><br><span class="line">        .collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>5.4 <code>conflate</code>当生产速度大于消费速度，忽略未来得及处理的值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .conflate() <span class="comment">// conflate emissions, don&#x27;t process each one</span></span><br><span class="line">        .collect &#123; value -&gt; </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">            println(value) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//Collected in 758 ms</span></span><br></pre></td></tr></table></figure>

<p>5.5 <code>collectLatest</code> 如果消费者很慢，取消它，新值过来时再重新启动。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collectLatest &#123; value -&gt; <span class="comment">// cancel &amp; restart on the latest value</span></span><br><span class="line">            println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">            delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">            println(<span class="string">&quot;Done <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">        &#125; </span><br><span class="line">&#125;   </span><br><span class="line">println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//Collecting 1</span></span><br><span class="line"><span class="comment">//Collecting 2</span></span><br><span class="line"><span class="comment">//Collecting 3</span></span><br><span class="line"><span class="comment">//Done 3</span></span><br><span class="line"><span class="comment">//Collected in 741 ms</span></span><br></pre></td></tr></table></figure>

<p>5.6 多个flow合并：zip / combine  </p>
<p>使用<code>zip</code>操作符</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow() <span class="comment">// numbers 1..3</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>) <span class="comment">// strings </span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string</span></span><br><span class="line">    .collect &#123; println(it) &#125; <span class="comment">// collect and print</span></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//1 -&gt; one</span></span><br><span class="line"><span class="comment">//2 -&gt; two</span></span><br><span class="line"><span class="comment">//3 -&gt; three</span></span><br></pre></td></tr></table></figure>

<p>当两个flow不同步时：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//速度不同步时，使用zip，到达同步点才输出</span></span><br><span class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms</span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">nums.zip(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string with &quot;zip&quot;</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//1 -&gt; one at 428 ms from start</span></span><br><span class="line"><span class="comment">//2 -&gt; two at 828 ms from start</span></span><br><span class="line"><span class="comment">//3 -&gt; three at 1230 ms from start</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">////速度不同步时，使用combine，有值到达即输出，无视同步</span></span><br><span class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms          </span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">nums.combine(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string with &quot;combine&quot;</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//1 -&gt; one at 452 ms from start</span></span><br><span class="line"><span class="comment">//2 -&gt; one at 651 ms from start</span></span><br><span class="line"><span class="comment">//2 -&gt; two at 854 ms from start</span></span><br><span class="line"><span class="comment">//3 -&gt; two at 952 ms from start</span></span><br><span class="line"><span class="comment">//3 -&gt; three at 1256 ms from start</span></span><br></pre></td></tr></table></figure>


<p>参考文档：<br><a href="https://kotlinlang.org/docs/flow.html"> 1.官方文档</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Kotlin-48：为参数包含函数的方法内联</title>
    <url>/kotlin-lang-inline-func-param.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>你可能注意到了几乎所有的Kotlin标准库里面的高阶函数都是inline类型的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transform: (<span class="type">T</span>) -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> mapTo(</span><br><span class="line">        ArrayList&lt;R&gt;(collectionSizeOrDefault(<span class="number">10</span>)),</span><br><span class="line">        transform</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> filterTo(ArrayList&lt;T&gt;(), predicate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些函数的调用在编译时会被展开到调用处。如下所示:<code>repeat</code>函数会被它本身的函数体替换掉。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repeat(<span class="number">10</span>) &#123;</span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓</span></span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span>) &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般的函数调用通常是：跳进函数体，执行代码，然后跳出函数体，回到调用点。而用函数体替换函数调用是一种完全不同的方式，这种方式有以下一些优点：</p>
<ul>
<li>类型参数具体化</li>
<li>参数包含函数的方法内联后执行更快</li>
<li>不允许非本地的return语句</li>
</ul>
<p>使用inline标识符也会有一些缺点，下面👇🏻我们一起来看一下它的优缺点：</p>
<h5 id="一、类型参数具体化："><a href="#一、类型参数具体化：" class="headerlink" title="一、类型参数具体化："></a>一、类型参数具体化：</h5><p>早期的Java版本不支持泛型，在2004年的J2SE-5.0才支持。由于泛型会在编译期间被擦除，所以在字节码层面是不存在的。例如：<code>List&lt;Int&gt;</code> 编译后成为 <code>List</code> ，所以我们只需要检查一个对象是否是List实例，而不用检查它是否是一个<code>List&lt;Int&gt;</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">any <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt; <span class="comment">// Error</span></span><br><span class="line">any <span class="keyword">is</span> List&lt;*&gt; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<center>
    <img src="../images/kotlin_type_check.png" width="500"/>
</center>

<p>由于这个原因，我们不能操作类型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printTypeName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(T::<span class="keyword">class</span>.simpleName) <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过内联函数我们可以突破这种限制。由于函数调用被函数体替换，通过使用<code>reified</code>修饰符，泛型被真实的类型参数替换。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">printTypeName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(T::<span class="keyword">class</span>.simpleName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line">printTypeName&lt;<span class="built_in">Int</span>&gt;()    <span class="comment">//→print(Int::class.simpleName) // Int</span></span><br><span class="line">printTypeName&lt;<span class="built_in">Char</span>&gt;()   <span class="comment">//→print(Char::class.simpleName)// Char</span></span><br><span class="line">printTypeName&lt;String&gt;() <span class="comment">//→print(String::class.simpleName)// String</span></span><br></pre></td></tr></table></figure>

<p><code>reified</code>是一个非常有用的修饰符，例如标准库里面的<code>filterIsInstance</code>用来过滤某一种类型的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> employees: List&lt;Any&gt; =</span><br><span class="line">    listOf(Worker(), Manager(), Worker())</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> workers: List&lt;Worker&gt; =</span><br><span class="line">    employees.filterIsInstance&lt;Worker&gt;()</span><br></pre></td></tr></table></figure>

<p>它经常被用在我们自己写的代码库或工具类中。下面的例子是使用Gson库实现的通用函数，它能帮助我们简化依赖注入和模块申明。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Any&gt;</span> String.<span class="title">fromJsonOrNull</span><span class="params">()</span></span>: T? =</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        gson.fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: JsonSyntaxException) &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line"><span class="keyword">val</span> user: User? = userAsText.fromJsonOrNull()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin module declaration</span></span><br><span class="line"><span class="keyword">val</span> myModule = module &#123;</span><br><span class="line">    single &#123; Controller(<span class="keyword">get</span>()) &#125; <span class="comment">// get is reified</span></span><br><span class="line">    single &#123; BusinessService() &#125; <span class="comment">// get is reified</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Koin injection</span></span><br><span class="line"><span class="keyword">val</span> service: BusinessService <span class="keyword">by</span> inject()</span><br><span class="line"><span class="comment">// inject is reified</span></span><br></pre></td></tr></table></figure>

<h5 id="二、函数类型的参数内联后执行更快"><a href="#二、函数类型的参数内联后执行更快" class="headerlink" title="二、函数类型的参数内联后执行更快"></a>二、函数类型的参数内联后执行更快</h5><p>更确切的讲，短小的函数内联会更快，它无需跳转执行和跟踪调用栈。这也是为什么标准库里面很多小函数都是inline类型的原因。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(message: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.print(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当方法没有函数类型的参数时，没必要内联且IntelliJ会给出以下提示⚠️：</p>
<center>
    <img src="../images/kotlin_intelij_waring_inline.jpeg" width="500"/>
</center>


<p>要理解其中的原因，我们首先需要理解将函数作为对象进行操作的问题是什么。这些类型的对象(使用函数字面量创建)需要以某种方式保存。在Kotlin/JVM上，需要使用JVM匿名类或普通类创建一些对象。因此，下面的lambda表达式:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lambda: () -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会被编译为一个类。或JVM匿名类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">Function0&lt;Unit&gt; lambda = <span class="keyword">new</span> Function0&lt;Unit&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Unit <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者被编译成一个普通的类，被定义在一个单独的文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">// Additional class in separate file</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>$<span class="title">lambda</span> <span class="keyword">implements</span> <span class="title">Function0</span> &lt; <span class="title">Unit</span> &gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Unit <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line">Function0 lambda = <span class="keyword">new</span> Test$lambda();</span><br></pre></td></tr></table></figure>

<p>这两种方式没有特别大的区别。</p>
<p>我们注意到，这个函数类型被转换成Function0类型。在Kotlin中，无参类型会被编译器转换成Function0，同理单参数，两参数转换成Function1, Function2,Function3等</p>
<ul>
<li>()-&gt;Unit 编译成 Function0<Unit></li>
<li>()-&gt;Int 编译成 Function0<Int></li>
<li>(Int)-&gt;Int 编译成 Function1&lt;Int, Int&gt;</li>
<li>(Int, Int)-&gt;Int 编译成 Function2&lt;Int, Int, Int&gt;</li>
</ul>
<p>这些所有的接口都是Kotlin编译器生成的。你不能在Kotlin里显示的使用他们，因为它们是按需生成的，而应该使用函数类型。知道函数类型只是接口为你开启了很多的可能性。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnClickListener</span> : <span class="type"></span></span>() -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如在<em>高效Kotlin-47</em>中所述：避免不必要的对象创建，把函数体包装成对象拖慢代码。这就是为什么下面的代码中，第一个更快。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">repeatNoinline</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种差异是显而易见的，但在现实生活中的例子中很少有显著差异。我们把测试用例设计一下，放大这种差异：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nothingInline</span><span class="params">(blackhole: <span class="type">Blackhole</span>)</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">100_000_000</span>) &#123;</span><br><span class="line">        blackhole.consume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nothingNoninline</span><span class="params">(blackhole: <span class="type">Blackhole</span>)</span></span> &#123;</span><br><span class="line">    noinlineRepeat(<span class="number">100_000_000</span>) &#123;</span><br><span class="line">        blackhole.consume(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个在我们电脑平均运行189ms。第二个平均447ms。这种差距体现在：第一个例子迭代调用空函数。第二个例子迭代调用对象，这个对象调用一个空函数。这里使用了额外的对象。</p>
<p>看一个更典型的例子。我们有5000个产品，计算我们购买物品的价格：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">users.filter &#123; it.bought &#125;.sumByDouble &#123; it.price &#125;</span><br></pre></td></tr></table></figure>

<p>在我的机器上平均耗时38ms。如果filter和sumByDouble不内联耗时多少呢？平均42ms！看起来不多，但每次调用也有10%的差异。</p>
<p>内联和非内联函数最大的区别在于，当我们在函数字面量里捕获变量时。变量被使用时需要被包装成对象。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l = <span class="number">1L</span></span><br><span class="line">noinlineRepeat(<span class="number">100_000_000</span>) &#123;</span><br><span class="line">    l += it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个本地变量不能直接在非内联lambda中使用。这就是为什么要被包装成引用对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = Ref.LongRef()</span><br><span class="line">a.element = <span class="number">1L</span></span><br><span class="line">noinlineRepeat(<span class="number">100_000_000</span>) &#123;</span><br><span class="line">    a.element = a.element + it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别很大是因为，通常这个对象会被使用很多次，上面代码中的a变量使用了两次。因此，额外的对象调用2*100_000_000。再看一下这个例子👇🏻：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="comment">// On average 30 ms</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nothingInline</span><span class="params">(blackhole: <span class="type">Blackhole</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0L</span></span><br><span class="line">    repeat(<span class="number">100_000_000</span>) &#123;</span><br><span class="line">        l += it</span><br><span class="line">    &#125;</span><br><span class="line">    blackhole.consume(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="comment">// On average 274 ms</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nothingNoninline</span><span class="params">(blackhole: <span class="type">Blackhole</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0L</span></span><br><span class="line">    noinlineRepeat(<span class="number">100_000_000</span>) &#123;</span><br><span class="line">        l += it</span><br><span class="line">    &#125;</span><br><span class="line">    blackhole.consume(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个在我电脑运行30ms，第二个274ms。差距的原因是，函数是一个对象，本地变量需要被包装。小的影响累计放大了。大多数情况下，我们不知道有函数类型参数的方法被如何使用，当我们定义这种函数时，最好内联一下。这也是标准库经常这么写的原因。</p>
<h5 id="三、不允许非本地返回"><a href="#三、不允许非本地返回" class="headerlink" title="三、不允许非本地返回"></a>三、不允许非本地返回</h5><p>前面定义的<code>repeatNoninline</code>像是一个控制结构，拿它和if语句或for循环对比一下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    print(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeatNoninline(<span class="number">10</span>) &#123;</span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显的区别是，内部不能返回</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeatNoinline(<span class="number">10</span>) &#123;</span><br><span class="line">        print(it)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// ERROR: Not allowed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是函数字面量编译的结果。当我们的代码处于另外一个类时，不能从main函数返回。但是，当使用内联时，就没限制。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        print(it)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得益于此，函数可以看起来更像控制结构：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSomeMoney</span><span class="params">()</span></span>: Money? &#123;</span><br><span class="line">    repeat(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> money = searchForMoney()</span><br><span class="line">        <span class="keyword">if</span> (money != <span class="literal">null</span>) <span class="keyword">return</span> money</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="四、内联修饰符的缺陷"><a href="#四、内联修饰符的缺陷" class="headerlink" title="四、内联修饰符的缺陷"></a>四、内联修饰符的缺陷</h5><p>inline很有用，但不应该随处使用。有些情况下不建议使用。再来看看最重要的限制。</p>
<ul>
<li>内联函数不能递归，否则调用展开将无限循环。周期性循环尤其危险，因为Intellij不报错：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">c</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内联函数不能使用可见性约束的元素</li>
</ul>
<p>在<code>public inline fun</code>中不能使用private 、internal修饰的函数或属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> reader = Reader() <span class="comment">// Error</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是为什么它不能用于隐藏实现，并且很少在类中使用。</p>
<ul>
<li>内联函数使代码膨胀</li>
</ul>
<p>定义一个打印3的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">printThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用三次：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">threePrintThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printThree()</span><br><span class="line">    printThree()</span><br><span class="line">    printThree()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又定义下面函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">threeThreePrintThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    threePrintThree()</span><br><span class="line">    threePrintThree()</span><br><span class="line">    threePrintThree()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">threeThreeThreePrintThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    threeThreePrintThree()</span><br><span class="line">    threeThreePrintThree()</span><br><span class="line">    threeThreePrintThree()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下它们的编译结果，前两个还能看：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">printThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">threePrintThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后两个：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">threeThreePrintThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">threeThreeThreePrintThree</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)    </span><br><span class="line"> ...</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子展示了内联函数的弊端：过度使用时代码膨胀严重。</p>
<h5 id="五、crossinline-和noinline"><a href="#五、crossinline-和noinline" class="headerlink" title="五、crossinline 和noinline"></a>五、crossinline 和noinline</h5><p>有时候我们想内联一个函数，由于某些原因，不能内联全部的函数类型参数。这种情况下我们使用下面的修饰符：</p>
<p>crossinline：用于内联函数的参数，表示此参数内联范围扩大。对内联函数内部的lambda生效：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(postAction:()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    runOnUiThread &#123; </span><br><span class="line">        postAction()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>noinline：用于内联函数的参数，表示此参数不能被内联。可以局部性关闭内联。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestNewToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    hasToken: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">crossinline</span> onRefresh: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> onGenerate: () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">        httpCall(<span class="string">&quot;get-token&quot;</span>, onGenerate) <span class="comment">// We must use </span></span><br><span class="line">        <span class="comment">// noinline to pass function as an argument to a</span></span><br><span class="line">        <span class="comment">// function that is not inlined</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        httpCall(<span class="string">&quot;refresh-token&quot;</span>) &#123;</span><br><span class="line">            onRefresh() <span class="comment">// We must use crossinline to </span></span><br><span class="line">            <span class="comment">// inline function in a context where </span></span><br><span class="line">            <span class="comment">// non-local return is not allowed</span></span><br><span class="line">            onGenerate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">httpCall</span><span class="params">(url: <span class="type">String</span>, callback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能记住这两个修饰符最好，记不住也没事，IntelliJ会有提示：</p>
<h5 id="六、总结："><a href="#六、总结：" class="headerlink" title="六、总结："></a>六、总结：</h5><p>使用inline的主要场景是：</p>
<ul>
<li>经常被使用的函数</li>
<li>具体化的类型参数，像：<code>filterIsInstance</code></li>
<li>定义带有函数类型的参数的顶层函数。尤其是辅助函数，如集合处理（map、filter）、作用域函数（also、apply、let）、顶层工具函数（repeat、run、with）</li>
</ul>
<p>我们很少用inline定义API，注意内联函数调用内联函数的情景。记住代码膨胀。</p>
<p>参考：<br><a href="https://kt.academy/article/ek-inline-functions">Effective Kotlin Item 48: Use inline modifier for functions with parameters of functional types</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的JVM注解</title>
    <url>/kotlin-lang-jvm-annotation.html</url>
    <content><![CDATA[<p>Kotlin提供了一些注解可以帮助开发者更好地兼容Java。下面探索一下Kotlin中JVM注解的使用，以及在Java中使用Kotlin类时注解对我们的影响。</p>
<h4 id="1、-JvmName"><a href="#1、-JvmName" class="headerlink" title="1、@JvmName"></a>1、@JvmName</h4><p>用于文件、函数、属性、getter和setter。</p>
<h5 id="1-1-给文件添加-JvmName注解"><a href="#1-1-给文件添加-JvmName注解" class="headerlink" title="1.1 给文件添加@JvmName注解"></a>1.1 给文件添加@JvmName注解</h5><p>默认情况下，一个Kotlin文件中的<strong>function</strong>和<strong>properties</strong>会被编译成<em>filenameKt.class</em>，其中的<strong>class</strong>会被编译成classname.class:</p>
<table>
    <tr>
        <td><img src="../images/kotlin-annotation-jvmname-1.jpeg" width="100%"/></td>
        <td><img src="../images/kotlin-annotation-jvmname-2.jpeg" width="100%"/></td>
    </tr>
</table>

<h5 id="1-2-给函数名添加-JvmName注解"><a href="#1-2-给函数名添加-JvmName注解" class="headerlink" title="1.2 给函数名添加@JvmName注解"></a>1.2 给函数名添加@JvmName注解</h5><center>
    <img src="../images/kotlin-annotation-jvmname-3.jpeg" width="500"/>
</center>

<h5 id="1-3-给getter和setting添加-JvmName"><a href="#1-3-给getter和setting添加-JvmName" class="headerlink" title="1.3 给getter和setting添加@JvmName"></a>1.3 给getter和setting添加@JvmName</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;getContent&quot;</span>)</span><br><span class="line"><span class="meta">@set:JvmName</span>(<span class="string">&quot;setContent&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、-JvmDefault"><a href="#2、-JvmDefault" class="headerlink" title="2、@JvmDefault"></a>2、@JvmDefault</h4><p>和Java8一样，Kotlin的接口也支持默认方法实现。即使针对Java7及以下版本，他也能正常编译，因为Kotlin使用静态内部类实现默认方法。</p>
<center>
    <img src="../images/kotlin-annotation-jvmdefault-1.jpeg" width="500"/>
</center>

<p>当在Java中实现此接口时，需要复写对应的方法，否则将报错。</p>
<center>
    <img src="../images/kotlin-annotation-jvmdefault-2.jpeg" width="100%"/>
</center>

<p>如果我们希望它在Java8中不报错，可以使用@JvmDefault注解标识方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JvmDefault</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">()</span></span> = <span class="string">&quot;document&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、-JvmStatic"><a href="#3、-JvmStatic" class="headerlink" title="3、@JvmStatic"></a>3、@JvmStatic</h4><p>针对<code>object class</code> 或<code>companion object</code>使用此注解,可以避免Java访问时的INSTANCE调用</p>
<table>
    <tr>
        <td><img src="../images/kotlin-annotation-jvmstatic-1.jpeg" width="100%"/></td>
        <td><img src="../images/kotlin-annotation-jvmstatic-2.jpeg" width="100%"/></td>
    </tr>
</table>

<h4 id="4、-JvmOverloads"><a href="#4、-JvmOverloads" class="headerlink" title="4、@JvmOverloads"></a>4、@JvmOverloads</h4><p>Kotlin的默认参数可以帮助我们减少函数重载，简化方法调用参数。在Java中调用含默认参数的Kotlin函数时，需要提供全部参数。</p>
<table>
    <tr>
        <td><img src="../images/kotlin-annotation-jvmoverloads-1.jpeg" width="100%"/></td>
        <td><img src="../images/kotlin-annotation-jvmoverloads-2.jpeg" width="100%"/></td>
    </tr>
</table>

<h4 id="5、-Throws"><a href="#5、-Throws" class="headerlink" title="5、@Throws"></a>5、@Throws</h4><p>Kotlin没有受检测异常，try-catch是非必须的。如果希望在Java调用中检测到异常，可以使用@Throws注解</p>
<center>
    <img src="../images/kotlin-annotation-jvmthrows.jpeg" width="100%"/>
</center>

<h4 id="6、-JvmWildcard-amp-JvmSuppressWildcard"><a href="#6、-JvmWildcard-amp-JvmSuppressWildcard" class="headerlink" title="6、@JvmWildcard &amp; @JvmSuppressWildcard"></a>6、@JvmWildcard &amp; @JvmSuppressWildcard</h4><p>略</p>
<h4 id="7、-JvmMultifileClass"><a href="#7、-JvmMultifileClass" class="headerlink" title="7、@JvmMultifileClass"></a>7、@JvmMultifileClass</h4><p>当在多个文件中定义的顶层函数或属性想要合并到一个编译的class中时，可以使用此注解。</p>
<center>
    <img src="../images/kotlin-annotation-jvmmultifileclass.jpeg" width="500"/>
</center>


<h4 id="8、-JvmPackageName"><a href="#8、-JvmPackageName" class="headerlink" title="8、@JvmPackageName"></a>8、@JvmPackageName</h4><p>和@JvmName一样，此注解可以修改包名，但是他被标记为internal，只能在kotlin库内部使用，这里不做过多介绍。</p>
<h4 id="9、注解一览"><a href="#9、注解一览" class="headerlink" title="9、注解一览"></a>9、注解一览</h4><center>
    <img src="../images/kotlin-annotation-overview.png" width="100%"/>
</center>

<h4 id="参考"><a href="#参考" class="headerlink" title="[参考]"></a>[参考]</h4><p><a href="https://www.baeldung.com/kotlin/jvm-annotations">1.Guide to JVM Platform Annotations in Kotlin</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin之JvmStatic和override冲突问题</title>
    <url>/kotlin-lang-jvmstatic-with-interface.html</url>
    <content><![CDATA[<h4 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h4><p>   为了方便Java代码调用Kotlin的object类，我们通常会对object类的方法添加<code>@JvmStatic</code>注解。</p>
<table>
    <tr>
        <td><img src="../images/kotlin-annotation-jvmstatic-1.jpeg" width="100%"/></td>
        <td><img src="../images/kotlin-annotation-jvmstatic-2.jpeg" width="100%"/></td>
    </tr>
</table>

<p>然而、当object类实现某个接口时，对应的方法却不能添加@JvmStatic注解。</p>
<center>
    <img src="../images/kotlin-annotation-jvmstatic-error.jpg" width="70%"/>
</center>


<h4 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h4><pre><code>要想解决上述问题，只需要将object类的实现做一些转换：
</code></pre>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Play2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">companion</span> <span class="keyword">object</span> : Play2 &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、思考"><a href="#三、思考" class="headerlink" title="三、思考"></a>三、思考</h4><blockquote>
<p>为什么第一种方式会报错，而第二种方式没问题呢？</p>
</blockquote>
<p>通过反编译查看Java代码我们发现：object类的方法会被直接编译成Java的static方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="title">implements</span> <span class="title">Play</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> static void play() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Singleton() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Singleton var0 = new Singleton();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而companion object则会被编译成<strong>静态内部类</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Singleton2.Companion Companion = new Singleton2.Companion((DefaultConstructorMarker)<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="keyword">public</span> static void play() &#123;</span><br><span class="line">      Companion.play();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> <span class="title">implements</span> <span class="title">Play2</span> </span>&#123;</span><br><span class="line">      <span class="meta">@JvmStatic</span></span><br><span class="line">      <span class="keyword">public</span> void play() &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Companion() &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="keyword">public</span> Companion(DefaultConstructorMarker $constructor_marker) &#123;</span><br><span class="line">         <span class="keyword">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于static方法是不能重写（override）的，所以同一个关键字不能作用于一个函数。而通过静态内部类的方式，在类的层次增加静态能力，从而消除了方法的static关键字。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://youtrack.jetbrains.com/issue/KT-21342">issue-KT-21342</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Kotlin-51：使用Sequence优化集合操作</title>
    <url>/kotlin-lang-sequence.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>你可能对 <code>Iterable</code> 和 <code>Sequence</code> 傻傻分不清。看一下他们的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sequence</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>好像只有名字不一样-_-||，但他们却有着本质的区别。<code>Sequence</code>属于懒加载，中间操作符不会触发计算，仅仅是对前一个Sequence的装饰，只有在遇到toList()或count()这些终止操作符时才会执行真正的计算工作。而Iterable每一步都返回一个新的集合。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> filterTo(ArrayList&lt;T&gt;(), predicate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Sequence<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Sequence&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> FilteringSequence(<span class="keyword">this</span>, <span class="literal">true</span>, predicate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图中filter操作符不做任何计算操作，只是返回一个装饰器对象，在遇到toList()操作符才执行计算。</p>
<center>
    <img src="../images/kotlin_sequence_operation.jpeg" width="500"/>
</center>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> seq = sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> filtered = seq.filter &#123; print(<span class="string">&quot;f<span class="variable">$it</span> &quot;</span>); it % <span class="number">2</span> == <span class="number">1</span> &#125;</span><br><span class="line">println(filtered)  <span class="comment">// FilteringSequence@...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> asList = filtered.toList()</span><br><span class="line"><span class="comment">// f1 f2 f3</span></span><br><span class="line">println(asList) <span class="comment">// [1, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> listFiltered = list</span><br><span class="line">    .filter &#123; print(<span class="string">&quot;f<span class="variable">$it</span> &quot;</span>); it % <span class="number">2</span> == <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// f1 f2 f3</span></span><br><span class="line">println(listFiltered) <span class="comment">// [1, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="二、优势"><a href="#二、优势" class="headerlink" title="二、优势"></a>二、优势</h4><p>Sequence的惰性执行有以下几个优点：</p>
<ul>
<li>保证操作的顺序性</li>
<li>保证操作执行次数最少化</li>
<li>他们可以是无限的</li>
<li>无需每一步创建新的集合</li>
</ul>
<p>下面依次讨论一下这些优点</p>
<h5 id="一、顺序性很重要"><a href="#一、顺序性很重要" class="headerlink" title="一、顺序性很重要"></a>一、顺序性很重要</h5><table>
    <tr>
        <td>使用Sequence处理数据时，每个元素依次执行所有操作符。这是一种元素接元素的处理方式。</td>
        <td>使用Iterable处理数据时，每个操作符依次执行所有数据。这是一种步骤接步骤的处理方式。</td>
    </tr>
     <tr>
            <td>
            <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">sequenceOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .filter &#123; </span><br><span class="line">        print(<span class="string">&quot;F<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it % <span class="number">2</span> == <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; </span><br><span class="line">        print(<span class="string">&quot;M<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it * <span class="number">2</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .forEach &#123; </span><br><span class="line">        print(<span class="string">&quot;E<span class="variable">$it</span>, &quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Prints: F1, M1, E2, F2, F3, M3, E6, </span></span><br></pre></td></tr></table></figure>
            </td>
            <td>
            <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .filter &#123; </span><br><span class="line">        print(<span class="string">&quot;F<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it % <span class="number">2</span> == <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; </span><br><span class="line">        print(<span class="string">&quot;M<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it * <span class="number">2</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .forEach &#123; </span><br><span class="line">        print(<span class="string">&quot;E<span class="variable">$it</span>, &quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Prints: F1, F2, F3, M1, M3, E2, E6,</span></span><br></pre></td></tr></table></figure>
            </td>
        </tr>
</table>


<center>
    <img src="../images/kotlin_sequence_order.jpeg" width="500"/>
</center>

<p>如果我们不用集合处理函数，而是用循环和条件语句，这和sequence一样，也是一种元素接元素的处理方式。这也为我们提供了一种编译器底层优化的思路：sequence操作可以被优化成循环和条件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (e <span class="keyword">in</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">    print(<span class="string">&quot;F<span class="variable">$e</span>, &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (e % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;M<span class="variable">$e</span>, &quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> mapped = e * <span class="number">2</span></span><br><span class="line">        print(<span class="string">&quot;E<span class="variable">$mapped</span>, &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints: F1, M1, E2, F2, F3, M3, E6,</span></span><br></pre></td></tr></table></figure>


<h5 id="二、Sequence执行最少的操作"><a href="#二、Sequence执行最少的操作" class="headerlink" title="二、Sequence执行最少的操作"></a>二、Sequence执行最少的操作</h5><p>我们没必要每一步都处理整个集合。假如我们有一百万个数据，我们只需要前十个，没必要处理十个之后的数据。所以sequence可以执行最少的操作。</p>
<center>
    <img src="../images/kotlin_sequence_min_op.jpeg" width="500"/>
</center>

<p>看下面的例子：</p>
<table>
     <tr>
            <td>
            <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.</span><span class="number">.10</span>).asSequence()</span><br><span class="line">    .filter &#123; </span><br><span class="line">        print(<span class="string">&quot;F<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it % <span class="number">2</span> == <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; </span><br><span class="line">        print(<span class="string">&quot;M<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it * <span class="number">2</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .find &#123; </span><br><span class="line">        it &gt; <span class="number">5</span> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Prints: F1, M1, F2, F3, M3,</span></span><br></pre></td></tr></table></figure>
            </td>
            <td>
            <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.</span><span class="number">.10</span>)</span><br><span class="line">    .filter &#123; </span><br><span class="line">        print(<span class="string">&quot;F<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it % <span class="number">2</span> == <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; </span><br><span class="line">        print(<span class="string">&quot;M<span class="variable">$it</span>, &quot;</span>); </span><br><span class="line">        it * <span class="number">2</span> </span><br><span class="line">    &#125;</span><br><span class="line">    .find &#123; </span><br><span class="line">        it &gt; <span class="number">5</span> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Prints: </span></span><br><span class="line"><span class="comment">//F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, </span></span><br><span class="line"><span class="comment">// M1, M3, M5, M7, M9,         </span></span><br></pre></td></tr></table></figure>
            </td>
        </tr>
</table>

<p>这个例子中，有很多个操作符，最后的终止操作符不需要处理所有的数据，因此sequence性能更好。类似的操作符还有：<code>first</code>, <code>find</code>, <code>take</code>, <code>any</code>, <code>all</code>, <code>none</code> 或 <code>indexOf</code>。</p>
<h5 id="三、Sequence是无限的"><a href="#三、Sequence是无限的" class="headerlink" title="三、Sequence是无限的"></a>三、Sequence是无限的</h5><p>由于Sequence按需处理，我们可以定义无限序列。一种常用的方式是使用sequence生成器 <code>generateSequence</code> 或 <code>sequence</code> 。</p>
<p><code>generateSequence</code>需要传如第一个值，以及如何产生下一个值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">generateSequence(<span class="number">1</span>) &#123; it + <span class="number">1</span> &#125;</span><br><span class="line">    .map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .forEach &#123; print(<span class="string">&quot;<span class="variable">$it</span>, &quot;</span>) &#125;</span><br><span class="line"><span class="comment">// Prints: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,</span></span><br></pre></td></tr></table></figure>

<p><code>sequence</code> 则使用挂起函数按需生成数据。只要我们需要数据他就执行，一直到调用yield方法。然后挂起直到下次再向他请求数据。下面是一个无限生成斐波那契数列的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fibonacci: Sequence&lt;BigDecimal&gt; = sequence &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="number">1.</span>toBigDecimal()</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="number">1.</span>toBigDecimal()</span><br><span class="line">    yield(prev)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        yield(current)</span><br><span class="line">        <span class="keyword">val</span> temp = prev</span><br><span class="line">        prev = current</span><br><span class="line">        current += temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(fibonacci.take(<span class="number">10</span>).toList())</span><br><span class="line">    <span class="comment">// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用无限序列需要限制元素的数量，否则将无限的运行下去。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">print(fibonacci.toList()) <span class="comment">// Runs forever</span></span><br></pre></td></tr></table></figure>

<p>为了不让它无限循环的运行，我们可以使用<code>take</code>限制元素数量，或者使用first、find、indexOf等。在不限制数量的情况下，不要使用any、all、none。</p>
<h5 id="四、sequence每一步不产生新集合"><a href="#四、sequence每一步不产生新集合" class="headerlink" title="四、sequence每一步不产生新集合"></a>四、sequence每一步不产生新集合</h5><p>标准的集合处理函数每一步都返回新的集合，当我们处理大量数据时会分配很多临时内存。</p>
<table>
     <tr>
         <td>
            <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">num</span><br><span class="line">   .filter &#123;<span class="comment">// 1                   </span></span><br><span class="line">       it % <span class="number">10</span> == <span class="number">0</span> </span><br><span class="line">   &#125; </span><br><span class="line">   .map &#123;<span class="comment">// 2      </span></span><br><span class="line">       it * <span class="number">2</span> </span><br><span class="line">   &#125; </span><br><span class="line">   .sum()</span><br><span class="line"><span class="comment">// In total, 2 collections </span></span><br><span class="line"><span class="comment">// created under the hood</span></span><br></pre></td></tr></table></figure>
         </td>
         <td>
            <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">num.asSequence()</span><br><span class="line">   .filter &#123;<span class="comment">//0 </span></span><br><span class="line">      it % <span class="number">10</span> == <span class="number">0</span> </span><br><span class="line">   &#125;</span><br><span class="line">   .map &#123;<span class="comment">//0</span></span><br><span class="line">      it * <span class="number">2</span> </span><br><span class="line">   &#125;</span><br><span class="line">   .sum()</span><br><span class="line"><span class="comment">// No collections created</span></span><br></pre></td></tr></table></figure>
         </td>
     </tr>
</table>

<p>一个极端又常见的例子：文件读取。文件可能是几个G，每执行一个操作符都分配这么多内存是一种极大的浪费。下面例子是读取大小1.53G的芝加哥犯罪记录中包含毒品交易信息的记录数量，其中readLines 返回 List<String>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD SOLUTION, DO NOT USE COLLECTIONS FOR </span></span><br><span class="line"><span class="comment">// POSSIBLY BIG FILES</span></span><br><span class="line">File(<span class="string">&quot;ChicagoCrimes.csv&quot;</span>)</span><br><span class="line">    .readLines()</span><br><span class="line">    .drop(<span class="number">1</span>) <span class="comment">// Drop descriptions of the columns</span></span><br><span class="line">    .mapNotNull &#123; it.split(<span class="string">&quot;,&quot;</span>).getOrNull(<span class="number">6</span>) &#125;</span><br><span class="line">    <span class="comment">// Find description</span></span><br><span class="line">    .filter &#123; <span class="string">&quot;CANNABIS&quot;</span> <span class="keyword">in</span> it &#125;</span><br><span class="line">    .count()</span><br><span class="line">    .let(::println)</span><br></pre></td></tr></table></figure>
<p>这段程序在我电脑上的运行结果是：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">OutOfMemoryError.n&gt; Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>我们创建了一个集合，中间三个操作符产生集合，一个四个集合。其中三个包含文件的主要主要数据记录，一共消耗4.59G。正确的实现应该使用sequence，我们使用<code>useLines</code>函数，每次只操作一行记录。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">File(<span class="string">&quot;ChicagoCrimes.csv&quot;</span>).useLines &#123; lines -&gt;</span><br><span class="line"><span class="comment">// The type of `lines` is Sequence&lt;String&gt;</span></span><br><span class="line">    lines.drop(<span class="number">1</span>) <span class="comment">// Drop descriptions of the columns</span></span><br><span class="line">        .mapNotNull &#123; it.split(<span class="string">&quot;,&quot;</span>).getOrNull(<span class="number">6</span>) &#125;</span><br><span class="line">        <span class="comment">// Find description</span></span><br><span class="line">        .filter &#123; <span class="string">&quot;CANNABIS&quot;</span> <span class="keyword">in</span> it &#125;</span><br><span class="line">        .count()</span><br><span class="line">        .let &#123; println(it) &#125; <span class="comment">// 318185</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样运行这段代码，只耗时8.3s。为了比较一下这两种方法的效率，我做了另外一个实验：删除数据中不必要的列以减少文件大小，得到<code>CrimeData.csv</code>只有728MB，然后做相同的操作。使用Collection处理函数，耗时13s，使用sequence函数，耗时4.5s。正如实验数据，使用sequence处理大文件不仅节约内存，而且提升性能。</p>
<p>事实上，在每个步骤中，我们创建一个新的集合本身也是一种成本，当我们处理包含大量元素的集合时，这种成本就会显现出来。差别并不大——主要是因为在许多步骤中创建的集合都是用预期的大小初始化的，所以当我们添加元素时，我们只需要将它们放在下一个位置。尽管即使是廉价的集合复制也比完全不复制要昂贵，这也是为什么我们应该更喜欢对具有<em>多个处理步骤</em>的<em>大集合</em>使用Sequence的主要原因。</p>
<blockquote>
<p>大集合：元素多（含数万个元素的整数列表）、元素大（超长字符串）</p>
<p>多个处理步骤：处理集合时使用很多操作符。</p>
</blockquote>
<p>如果对比下面两个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">singleStepListProcessing</span><span class="params">()</span></span>: List&lt;Product&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> productsList.filter &#123; it.bought &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">singleStepSequenceProcessing</span><span class="params">()</span></span>: List&lt;Product&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> productsList.asSequence()</span><br><span class="line">        .filter &#123; it.bought &#125;</span><br><span class="line">        .toList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现，在性能上区别不大（实际上，简单的list处理更快，因为它的filter函数是内联的）。但是，当你使用多个操作符，先filter再map，在大集合上性能问题就行显现出来。为了看到区别，我们比较一下2个操作符和3个操作符处理5000个数据的情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoStepListProcessing</span><span class="params">()</span></span>: List&lt;<span class="built_in">Double</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> productsList</span><br><span class="line">        .filter &#123; it.bought &#125;</span><br><span class="line">        .map &#123; it.price &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoStepSequenceProcessing</span><span class="params">()</span></span>: List&lt;<span class="built_in">Double</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> productsList.asSequence()</span><br><span class="line">        .filter &#123; it.bought &#125;</span><br><span class="line">        .map &#123; it.price &#125;</span><br><span class="line">        .toList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">threeStepListProcessing</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> productsList</span><br><span class="line">        .filter &#123; it.bought &#125;</span><br><span class="line">        .map &#123; it.price &#125;</span><br><span class="line">        .average()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">threeStepSequenceProcessing</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> productsList.asSequence()</span><br><span class="line">        .filter &#123; it.bought &#125;</span><br><span class="line">        .map &#123; it.price &#125;</span><br><span class="line">        .average()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是在MacBook Pro(Retina, 15-inch, Late 2013)处理5000个元素的平均结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">twoStepListProcessing                        81 095 ns</span><br><span class="line">twoStepSequenceProcessing                    55 685 ns</span><br><span class="line">twoStepListProcessingAndAcumulate            83 307 ns</span><br><span class="line">twoStepSequenceProcessingAndAcumulate         6 928 ns</span><br></pre></td></tr></table></figure>

<p>很难预测我们能提升但是性能，根据我的观察，在一个包含多个步骤的典型集合处理中，对于至少几千个元素，我们可以预期大约20-40%的性能提升。</p>
<h5 id="五、sequence什么时候没那么快？"><a href="#五、sequence什么时候没那么快？" class="headerlink" title="五、sequence什么时候没那么快？"></a>五、sequence什么时候没那么快？</h5><p>有些情况我们要处理整个集合，sequence并不能给我们带来什么收益。如<code>sorted</code>（当前来讲它是唯一一个例子）。sorted的最优实现：积攒Sequence并放入List，然后使用Java的sort函数。缺点是，与<code>Collection.sort</code>相比，积攒过程会消耗额外的时间。</p>
<p>Sequence是否应该支持<code>sorted</code>函数是有争议的，因为当一个序列的方法需要所有元素才能完成计算时，后续操作只是部分延迟，并且它不支持无限序列。之所以添加sorted操作只是因为它很常用，好用。Kotlin开发者需要了解它的缺陷，尤其是它不能用于无限序列。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span> &#125;.take(<span class="number">10</span>).sorted().toList()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span> &#125;.sorted().take(<span class="number">10</span>).toList()</span><br><span class="line"><span class="comment">// Infinite time. Does not return.</span></span><br></pre></td></tr></table></figure>

<p>在Collection上使用sorted比在Sequence上更快只是少数特例。当我们只使用很少操作符函数和单个sorted函数时，还是建议使用sequence来处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">productsList.asSequence()</span><br><span class="line">    .filter &#123; it.bought &#125;</span><br><span class="line">    .map &#123; it.price &#125;</span><br><span class="line">    .sorted()</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .sum()</span><br></pre></td></tr></table></figure>

<h5 id="六、看看Java的Stream操作"><a href="#六、看看Java的Stream操作" class="headerlink" title="六、看看Java的Stream操作"></a>六、看看Java的Stream操作</h5><p>Java 8新增了集合处理流的特性，看起来和Kotlin的序列很像。</p>
<table>
     <tr>
         <td>
            <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">productsList.asSequence()</span><br><span class="line">    .filter &#123; it.bought &#125;</span><br><span class="line">    .map &#123; it.price &#125;</span><br><span class="line">    .average()</span><br></pre></td></tr></table></figure>
         </td>
         <td>
            <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">productsList.stream()</span><br><span class="line">    .filter &#123; it.bought &#125;</span><br><span class="line">    .mapToDouble &#123; it.price &#125;</span><br><span class="line">    .average()</span><br><span class="line">    .orElse(<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
         </td>
     </tr>
</table>

<p>Java 8的Stream也是惰性的在最后一个操作符触发计算。与Kotlin sequence的区别主要是：</p>
<ul>
<li>Kotlin sequence包含更多的处理函数（被定义为拓展函数），使用简单: <code>toList()</code> vs <code>collect(Collectors.toList())</code></li>
<li>Java stream可以开启并行模式，在多核处理器上会有很大的性能提升。</li>
<li>Kotlin sequence可以用于Kotlin/JVM、Kotlin/JS、Kotlin/Native模块中。Java stream只能用于Kotlin/JVM，且JVM版本至少是8</li>
</ul>
<p>总之，我们不用Java stream并行模式时很难将谁的性能更好，我建议少用Java stream，只有在处理重量级计算问题中使用并行模式可以显著带来收益的情况下使用，其他情况用Kotlin标准函数能带来清晰的代码结构和多平台支持。</p>
<h5 id="七、调试Sequence"><a href="#七、调试Sequence" class="headerlink" title="七、调试Sequence"></a>七、调试Sequence</h5><p>Kotlin Sequence和Java Stream都支持debug每一步操作。Java需要使用”Java Stream Debugger”插件，Kotlin则需要”Kotlin Sequence Debugger”插件，现在已经被集成在了Kotlin插件中了。</p>
<center>
    <img src="../images/kotlin_sequence_debug.jpeg" width="500"/>
</center>


<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>集合和序列非常相似，都支持相同的处理函数。但他们也有很大的区别。Sequence处理是困难的，因为我们要保持原集合不变，执行相应转换后再放回原集合。Sequence是惰性的，带来很多优点：</p>
<ul>
<li>保证操作的顺序性</li>
<li>保证操作执行次数最少化</li>
<li>他们可以是无限的</li>
<li>无需每一步创建新的集合</li>
</ul>
<p>基于这些优点，对于包含多个处理步骤的包含大对象或元素很多的集合来说使用Sequence更好。Sequence也包含调试器，能帮助我们可视化的分析元素处理过程。Sequence不是为了取代传统的集合处理方式，使用前应该分析清楚自己的目的和原因才能带来性能的提升以及更少的内存问题。</p>
<h4 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h4><p><a href="https://kt.academy/article/ek-sequence">Effective Kotlin Item 51: Prefer Sequence for big collections with more than one processing step</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Kotlin-35：用DSL创建复杂对象</title>
    <url>/kotlin-lang-use-dsl.html</url>
    <content><![CDATA[<h4 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h4><p>利用Kotlin的语言特性可以创建可配置的领域语言-DSL（Domain Specific Language）。这种DSL用于表示复杂对象和对象继承结构很有用，它能隐藏模板代码和复杂性，让使用者更好的表达自己的意图。</p>
<p>例如，用Kotlin DSL的方式表示HTML的结构：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    div &#123;</span><br><span class="line">        a(<span class="string">&quot;https://kotlinlang.org&quot;</span>) &#123;</span><br><span class="line">            target = ATarget.blank</span><br><span class="line">            +<span class="string">&quot;Main site&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    +<span class="string">&quot;Some content&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他平台的视图也可以使用DSL来定义。下面是Android上使用Anko库定义的界面：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">    <span class="keyword">val</span> name = editText()</span><br><span class="line">    button(<span class="string">&quot;Say Hello&quot;</span>) &#123;</span><br><span class="line">        onClick &#123; toast(<span class="string">&quot;Hello, <span class="subst">$&#123;name.text&#125;</span>!&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，使用TornadorFX库定义的桌面应用如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> : <span class="type">View</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> root = hbox &#123;</span><br><span class="line">        label(<span class="string">&quot;Hello world&quot;</span>) &#123;</span><br><span class="line">            addClass(heading)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        textfield &#123;</span><br><span class="line">            promptText = <span class="string">&quot;Enter your name&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DSL通常也被用于定义数据和配置。下面是Ktor定义的API：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Routing.<span class="title">api</span><span class="params">()</span></span> &#123;</span><br><span class="line">    route(<span class="string">&quot;news&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> newsData = NewsUseCase.getAcceptedNews()</span><br><span class="line">            call.respond(newsData)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span>(<span class="string">&quot;propositions&quot;</span>) &#123;</span><br><span class="line">            requireSecret()</span><br><span class="line">            <span class="keyword">val</span> newsData = NewsUseCase.getPropositions()</span><br><span class="line">            call.respond(newsData)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在Kotlin Test中定义的测试用例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> : <span class="type">StringSpec</span></span>(&#123;</span><br><span class="line">    <span class="string">&quot;length should return size of string&quot;</span> &#123;</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>.length shouldBe <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;startsWith should test for a prefix&quot;</span> &#123;</span><br><span class="line">        <span class="string">&quot;world&quot;</span> should startWith(<span class="string">&quot;wor&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们甚至可以使用Gradle DSL定义Gradle配置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `java-library`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api(<span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;junit:junit:4.12&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    implementation &#123;</span><br><span class="line">        resolutionStrategy.failOnVersionConflict()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java.srcDir(<span class="string">&quot;src/core/java&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_11</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_11</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks &#123;</span><br><span class="line">    test &#123;</span><br><span class="line">        testLogging.showExceptions = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DSL简化了层次结构和复杂对象的创建。在DSL构建块中，你可以使用Kotlin语法和代码提示。也许你用过Kotlin DSL，但你更应该学会如何定义它。</p>
<h4 id="二、定义自己的DSL"><a href="#二、定义自己的DSL" class="headerlink" title="二、定义自己的DSL"></a>二、定义自己的DSL</h4><p>在理解如何定义DSL前，先明白带接收者的函数类型。首先什么是函数类型呢？它是一个能被当成函数使用的对象。例如：<code>filter</code>函数，参数predicate决定集合是否包含此元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = arrayListOf&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (elem <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate(elem)) &#123;</span><br><span class="line">            list.add(elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数类型的例子：  </p>
<ul>
<li>()-&gt;Unit - 无参函数，返回Unit</li>
<li>(Int)-&gt;Unit - 单参Int函数，返回Unit</li>
<li>(Int)-&gt;Int - 单参Int函数，返回Int</li>
<li>(Int, Int)-&gt;Int - 双参Int函数，返回Int。</li>
<li>(Int)-&gt;()-&gt;Unit - 单参Int函数，返回无参函数。 </li>
<li>(()-&gt;Unit)-&gt;Unit - 参数为函数的函数，返回Unit</li>
</ul>
<p>创建函数类型实例的方式有：  </p>
<ul>
<li>使用lambda表达式</li>
<li>使用匿名函数</li>
<li>使用函数引用</li>
</ul>
<p>例如，下面的函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br></pre></td></tr></table></figure>
<p>同样可以声明成这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> plus1: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; a, b -&gt; a + b &#125;</span><br><span class="line"><span class="keyword">val</span> plus2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = <span class="function"><span class="title">fun</span><span class="params">(a, b)</span></span> = a + b</span><br><span class="line"><span class="keyword">val</span> plus3: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = ::plus</span><br></pre></td></tr></table></figure>

<p>上面的例子中，由于指明了属性的类型，所以lambda和匿名函数中的参数能被推导出来。换一种方式说：如果指定参数类型，函数类型可以被推导。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> plus4 = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt; a + b &#125;</span><br><span class="line"><span class="keyword">val</span> plus5 = <span class="function"><span class="title">fun</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br></pre></td></tr></table></figure>

<p>函数类型以对象来表达函数，匿名函数也是一个普通函数只是没名字而已。lambda则是匿名函数的简短书写方式。</p>
<p>我们可以使用函数类型去表示函数，那拓展函数呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">myPlus</span><span class="params">(other: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + other</span><br></pre></td></tr></table></figure>

<p>之前提到匿名函数只是没名字而已，匿名拓展函数也一样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">myPlus</span><span class="params">(other: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + other</span><br></pre></td></tr></table></figure>

<p>那此函数的类型是什么呢？一种表示拓展函数的特殊类型，叫：带接收者的函数类型。它看起来和普通函数很像，只是在参数之前额外的指定了接收者的类型，他们之间用一个点分割开来。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myPlus: <span class="built_in">Int</span>.(<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> =</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span> + other</span><br></pre></td></tr></table></figure>

<p>这种函数能通过lambda表达式定义，尤其是一个带接收者的lambda表达式，因为作用域内部的this关键字引用了拓展接收者。（此例中是一个Int类型的实例）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myPlus: <span class="built_in">Int</span>.(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123; <span class="keyword">this</span> + it &#125;</span><br></pre></td></tr></table></figure>

<p>用匿名拓展函数或带接收者的lambda表达式创建的对象能被三种方式调用：</p>
<ul>
<li>像对象一样使用<code>invoke</code>方法调用</li>
<li>像非拓展函数一样</li>
<li>和普通的拓展函数一样</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">myPlus.invoke(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">myPlus(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1.</span>myPlus(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>带接收者的函数类型最大的特点是，它改变了<code>this</code>的指向。这种特点如何使用呢？假设一个类需要依次设置属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> text: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dialog = Dialog()</span><br><span class="line">    dialog.title = <span class="string">&quot;My dialog&quot;</span></span><br><span class="line">    dialog.text = <span class="string">&quot;Some text&quot;</span></span><br><span class="line">    dialog.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复引用此dialog很不方便，如果我们使用带接收者的lambda，this就指向dialog，我们可以省略this，因为接收者能够隐式调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> text: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dialog = Dialog()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">init</span>: Dialog.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        title = <span class="string">&quot;My dialog&quot;</span></span><br><span class="line">        text = <span class="string">&quot;Some text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>.invoke(dialog)</span><br><span class="line">    dialog.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个思路，你可以定义一个包含创建此dialog对象所需的所有公共部分的逻辑，只把需要变化的属性的设置给调用者。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> text: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showDialog</span><span class="params">(<span class="keyword">init</span>: <span class="type">Dialog</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dialog = Dialog()</span><br><span class="line">    <span class="keyword">init</span>.invoke(dialog)</span><br><span class="line">    dialog.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    showDialog &#123;</span><br><span class="line">        title = <span class="string">&quot;My dialog&quot;</span></span><br><span class="line">        text = <span class="string">&quot;Some text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是最简单的DSL例子。因为大部分这些构建函数都是重复的，已经被抽取到一个apply函数内，能被直接使用，不用再定义DSL构建器去设置属性了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">this</span>.block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dialog().apply &#123;</span><br><span class="line">    title = <span class="string">&quot;My dialog&quot;</span></span><br><span class="line">    text = <span class="string">&quot;Some text&quot;</span></span><br><span class="line">&#125;.show()</span><br></pre></td></tr></table></figure>

<p>对于DSL来说，带接收者的函数类型是最基本的构建块。我们一起来写一个简单的DSL用于创建下面的HTML表格：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createTable</span><span class="params">()</span></span>: TableBuilder = table &#123;</span><br><span class="line">    tr &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>) &#123;</span><br><span class="line">            td &#123;</span><br><span class="line">                +<span class="string">&quot;This is column <span class="variable">$i</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DSL开头我们定义了table函数。由于是最外层定义，所以它没用接收者。在table的内部可以使用tr，所以tr函数只能用于table内部。同理，td只能用于tr内部。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">table</span><span class="params">(<span class="keyword">init</span>: <span class="type">TableBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span>: TableBuilder &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tr</span><span class="params">(<span class="keyword">init</span>: <span class="type">TrBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">td</span><span class="params">(<span class="keyword">init</span>: <span class="type">TdBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TdBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">unaryPlus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        text += <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们定义好了DSL。为了让它运行，每一步我们都需要创建一个builder并用参数里面的函数初始化它（下面例子中的<code>init</code>）。builder将包含所有init函数指定的数据。这些数据是我们需要的。我们可以直接返回这个构建器也可以返回另一个包含这些数据的新对象。此例中我们直接返回构建器。下面是<code>table</code>函数的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">table</span><span class="params">(<span class="keyword">init</span>: <span class="type">TableBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span>: TableBuilder &#123;</span><br><span class="line">    <span class="keyword">val</span> tableBuilder = TableBuilder()</span><br><span class="line">    <span class="keyword">init</span>.invoke(tableBuilder)</span><br><span class="line">    <span class="keyword">return</span> tableBuilder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用apply函数简化函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">table</span><span class="params">(<span class="keyword">init</span>: <span class="type">TableBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span> =</span><br><span class="line">    TableBuilder().apply(<span class="keyword">init</span>)</span><br></pre></td></tr></table></figure>

<p>其他函数也使用apply简化：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> trs = listOf&lt;TrBuilder&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tr</span><span class="params">(<span class="keyword">init</span>: <span class="type">TrBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        trs = trs + TrBuilder().apply(<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tds = listOf&lt;TdBuilder&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">td</span><span class="params">(<span class="keyword">init</span>: <span class="type">TdBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        tds = tds + TdBuilder().apply(<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="三、何时使用？"><a href="#三、何时使用？" class="headerlink" title="三、何时使用？"></a>三、何时使用？</h4><p>DSL给了我们一种定义信息的方式。它能用于表达你所想表达的东西。但是对于用户而言这些信息之后如何使用不是很清晰。在Anko、TornadoFX或HTML DSL中，我们相信视图会根据我们的定义形式被构建，但很难跟踪准确跟踪如何构建。一些复杂的使用方式很难发现。用法也会让那些不习惯的人感到困惑。更不用说维护了。它们的定义方式可能是一种成本——在开发人员困惑和性能方面都是如此。当我们可以使用其他更简单的特性时，dsl就太过了。虽然当我们需要表达下面的内容时，它们真的很有用:</p>
<ul>
<li>复杂的数据结构</li>
<li>继承结构</li>
<li>大量数据</li>
</ul>
<p>描述事物不止DSL方式，还可以用builder、或只用构造器代替。dsl是关于此类结构的模板代码消除。当您看到可重复的样板代码，并且没有更简单的Kotlin特性可以提供帮助时，您应该考虑使用DSL。</p>
<h4 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h4><p>DSL是语言中的一种特殊形式。它可以非常简单地创建复杂的对象，甚至整个对象层次结构，如HTML代码或复杂的配置文件。另一方面，DSL实现可能会让新开发人员感到困惑或困难。它们也很难定义。这就是为什么只有当它们提供真正的价值时才应该使用它们的原因。例如，用于创建一个真正复杂的对象，或者可能用于复杂的对象层次结构。这就是为什么最好在库中而不是在项目中定义它们的原因。制作一个好的DSL并不容易，但是一个定义良好的DSL可以让我们的项目做得更好。</p>
<p>参考：<br><a href="https://kt.academy/article/ek-dsl">Effective Kotlin Item 35: Consider defining a DSL for complex object creation</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Kotlin-56：考虑使用可变集合</title>
    <url>/kotlin-lang-use-mutable-collection.html</url>
    <content><![CDATA[<p>与不可变集合相比，使用可变集合最大的优点是性能更快。向不可变集合添加元素需要新建集合再拷贝所有元素，下面是kotlin标准库现在的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">plus</span><span class="params">(element: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> Collection) <span class="keyword">return</span> <span class="keyword">this</span>.plus(element)</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    result.addAll(<span class="keyword">this</span>)</span><br><span class="line">    result.add(element)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当集合很大时，拷贝操作就比较耗性能了。所以对于需要添加元素的集合使用可变集合性能更好。我们知道，不可变集合是线程安全的。但是对于不需要同步的局部变量来说则不适用。这也是为什么对于局部处理，使用可变集合通常更有意义。这个事实可以在标准库中反映出来，在标准库中，所有的集合处理函数都是使用可变集合内部实现的:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transform: (<span class="type">T</span>) -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> size =</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> Collection&lt;*&gt;) <span class="keyword">this</span>.size <span class="keyword">else</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> destination = ArrayList&lt;R&gt;(size)</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不是不可变集合：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is not how map is implemented</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transform: (<span class="type">T</span>) -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> destination = listOf&lt;R&gt;()</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">        destination += transform(item)</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>总结：<br>如果是增加元素，可变集合是很快的，而不可变集合则给我们给多的控制，知道集合是如何变化的。但对于本地作用域来讲，我们不需要这种控制，所以使用可变集合更好。尤其在一些工具类，插入操作可能很频繁。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 两数相加</title>
    <url>/leetcode-list-add.html</url>
    <content><![CDATA[<h3 id="Leetode-2-两数相加"><a href="#Leetode-2-两数相加" class="headerlink" title="Leetode-2 两数相加"></a>Leetode-2 两数相加</h3><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<span id="more"></span>

<center>
    <img src="../images/add_two_6.jpeg" width="400" alt="初始状态"/>
</center>

<br>

<h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><h5 id="当两个链表长度相等时，我们只需要不断的相加，再移动两个指针，直至链表末尾。"><a href="#当两个链表长度相等时，我们只需要不断的相加，再移动两个指针，直至链表末尾。" class="headerlink" title="当两个链表长度相等时，我们只需要不断的相加，再移动两个指针，直至链表末尾。"></a>当两个链表长度相等时，我们只需要不断的相加，再移动两个指针，直至链表末尾。</h5><center>
    <img src="../images/add_two_7.jpeg" width="400"/>
</center>


<h5 id="当两个链表长度不等时，前半部分走链表相等逻辑，后半部分其实是一个单链表和进位相加的逻辑。"><a href="#当两个链表长度不等时，前半部分走链表相等逻辑，后半部分其实是一个单链表和进位相加的逻辑。" class="headerlink" title="当两个链表长度不等时，前半部分走链表相等逻辑，后半部分其实是一个单链表和进位相加的逻辑。"></a>当两个链表长度不等时，前半部分走链表相等逻辑，后半部分其实是一个单链表和进位相加的逻辑。</h5><center>
    <img src="../images/add_two_8.jpeg" width="400"/>
</center>


<center>
    <img src="../images/ad_two_9.jpeg" width="400"/>
</center>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个链表相加</span></span><br><span class="line"><span class="comment">     * 复用一个链表的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l1 第一个链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l2 第二个链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> carry = <span class="keyword">false</span>;<span class="comment">//进位</span></span><br><span class="line">        ListNode l1Prev = <span class="keyword">null</span>, l2Prev = <span class="keyword">null</span>, result = l1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个链表都有值，相加直到一个链表末尾</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> add = l1.val + l2.val + (carry ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            l1.val = add % <span class="number">10</span> ;</span><br><span class="line">            carry = add &gt; <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">            l1Prev = l1;</span><br><span class="line">            l2Prev = l2;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有一个链表已经走到头，</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addSingleList(l1Prev, l2, carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addSingleList(l2Prev, l1, carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span> &amp;&amp; carry)&#123;</span><br><span class="line">            l1Prev.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单链表和进位相加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addSingleList</span><span class="params">(ListNode l1, ListNode l2, <span class="keyword">boolean</span> carry)</span> </span>&#123;</span><br><span class="line">        l1.next = l2;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> add = l2.val + (carry ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            l2.val = add % <span class="number">10</span>;</span><br><span class="line">            carry = add &gt; <span class="number">9</span>;</span><br><span class="line">            l1 = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            l1.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 反转单链表</title>
    <url>/leetcode-reverse-list.html</url>
    <content><![CDATA[<h3 id="LeetCode-206-反转单链表"><a href="#LeetCode-206-反转单链表" class="headerlink" title="LeetCode-206 反转单链表"></a>LeetCode-206 反转单链表</h3><blockquote>
<p>给你单链表的头结点 head，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<p>问题分析：</p>
<p>这是初始状态的链表</p>
<center>
    <img src="../images/revert_list_0.png" width="400"/>
</center>
由于反转链表后 **head** 结点将指向空（null），我们可以假设存在这么一个为空的结点prev。  

<p>尝试一次反转后，我们发现，后续结点信息丢失了！我们不得不声明一个新的变量保存原链表的信息。</p>
<center>
    <img src="../images/revert_list_7.png" width="400"/>
</center>

<p>所以，我们一共需要三个指针来记录转换过程  </p>
<ul>
<li>prev、 head 用于交换</li>
<li>next 用于记录  </li>
</ul>
<p>分析到这里，我们再回到初始状态  ：</p>
<center>
    <img src="../images/revert_list_4.png" width="400"/>
</center>

<p>接下来我们进行第一次反转，<strong>head.next</strong> 指向虚拟的空结点，且后续链表信息没有丢失。</p>
<center>
    <img src="../images/revert_list_5.png" width="400"/>
</center>

<p>三个指针一起往后移动一个单位。我们发现此时链表又回到了最初的状态。</p>
<center>
    <img src="../images/revert_list_6.png" width="400"/>
</center>


<p>至此，我们可以尝试写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseIteratively</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改变指针方向，对第一个节点来说，他的前一个节点是null</span></span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="comment">//向前移动两个指针</span></span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>思考：<br>你能使用递归的方式改写上述代码逻辑吗？</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>无等级CSP中的死锁</title>
    <url>/model-csp-deadlocks.html</url>
    <content><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>本文是 Roman Elizarov 关于CSP中产生死锁问题的讨论，解释了其中的原因，并逐步给出了一种解决方案。部分翻译不恰当的可参考<a href="https://elizarov.medium.com/deadlocks-in-non-hierarchical-csp-e5910d137cc">原文</a></p>
<h4 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h4><p>众所周知，使用锁保护共享可变状态可能会导致死锁，但很少有人知道，使用无共享可变状态的CSP或actor模型也会导致死锁，尽管它们并不使用锁。它的死锁以另一种方式表现：通信死锁。</p>
<p>要知道，死锁的正式定义并没有直接与锁联系在一起。当每个进程都在循环等待下一个进程时，这组进程(线程/协程/参与者)就处于死锁状态。后面我们会看个例子，这里先道个歉，之前没强调这个问题。</p>
<h4 id="The-stage"><a href="#The-stage" class="headerlink" title="The stage"></a>The stage</h4><p>在2018年的KotlinConf我发表了题为”Kotlin协程实践”的演讲，其中讲到了对于构建可信赖软件来说结构性并发是重要的，且介绍了CSP的一些高级概念。其中一个部分有点问题。如果你按照演讲中一字不差的写完代码会导致一个死锁。不知何故，我掉进了这个陷阱，以为它对我来说是安全的，但不是。让我们来分析一下</p>
<p>首先来讲，如果应用被组织成数据处理管道，消息进入系统，被不同的协程顺序处理，最后被送出系统，那么这种CSP风格的架构，包括actor模式，都是安全的。更广泛地说，只要代码具有协程的层次结构(或有向无环图)，上游协程只向下游发送消息，且每个协程在同一个地方接收传过来的消息并向下游传递响应消息，代码就不会出现死锁。</p>
<center>
    <img src="../images/deadlock-dga.png" width="500"/>
</center>


<p>然而在我的演讲中，我草拟了一个数据处理循环的架构，下载器协程向任务池发送<code>locations</code>，并从任务池获取结果：</p>
<center>
    <img src="../images/deadlock-csp-downloader.png" width="500"/>
</center>

<p>我演讲中的例子的架构基于3个channel：<code>references</code>、<code>locations</code>、<code>contents</code>。下载协程包含以下逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123;                                   </span><br><span class="line">        references.onReceive &#123; ref -&gt;                <span class="comment">// (1)</span></span><br><span class="line">            <span class="keyword">val</span> loc = ref.resolveLocation()</span><br><span class="line">            ... </span><br><span class="line">            locations.send(loc)                      <span class="comment">// (2)</span></span><br><span class="line">        &#125;</span><br><span class="line">        contents.onReceive &#123; (loc, content) -&gt; ... &#125; <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Downloader从<code>references</code>通道(1)接收，解析对位置的引用并将它们发送到<code>locations</code>通道(2)。它还通过从<code>contents</code>通道(3)接收来自workers的结果来更新其状态。另外，works有以下代码:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (loc <span class="keyword">in</span> locations) &#123;                             <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">val</span> content = downloadContent(loc)         </span><br><span class="line">    contents.send(LocContent(loc, content))          <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>locations</code>通道接收消息（4），并发送下载后的内容去<code>contents</code>通道（5）</p>
<p>即使在两段通信的代码中也很难遵循逻辑，但在CSP中有一种方便的方法来可视化它。我们可以用通信有限状态机(CFSM)表示我们的系统。这些状态相当于挂起点和向通信的转变过程:</p>
<center>
    <img src="../images/deadlock-csp-cfsm.png" width="500"/>
</center>

<p>为了简洁起见，上图中通道名简写。receive -&gt; rcv、send -&gt; snd 。下载器主循环中的<code>select</code>语句相当于D0状态，它能接收来自<code>references</code>通道的消息(1)或者来自<code>contents</code>通道的消息(3)，当接收到来自<code>references</code>消息，切换到状态D1，等待发送消息去<code>locations</code>通道，如图中：(2)l.snd</p>
<h4 id="Deadlock-Demo"><a href="#Deadlock-Demo" class="headerlink" title="Deadlock Demo"></a>Deadlock <a href="https://github.com/elizarov/DeadlocksInCSP">Demo</a></h4><p>我用模拟数据类的方式完善了演讲中的代码，加入了<code>delay(10)</code>的<code>downloadContent</code>方法。main函数则持续发送请求给下载器的<code>references</code>通道，它有4个workers且带3秒超时限制。此项目可以完整的运行,正常情况下3s应该处理1000次请求。</p>
<p>当你运行该项目时，你会发现只处理了4次请求（和我们定义的worker数量一样）就挂起了，直到3s超时。此外，它没有任何随机性，因为它是在单线程的runBlocking上下文中运行的。</p>
<p>为了说服你（还有我自己），这是CSP内在的行为而不是Kotlin实现的bug，我用Go语言实现了一遍。Go语言内建的死锁检测器立即给出了提示：<em>all goroutines are asleep — deadlock</em> ，到底发生了什么呢？</p>
<p>开始时所有的worker完成初始化处于W1状态，然后尝试发送回复下载器的消息去<code>contents</code>通道(5)，但它是一个对接通道，下载器不能立马收到。下载器处于D1正尝试发送消息去<code>locations</code>通道(2)，但由于worker都在尝试发送所以无法接收。死锁发生了，所有的协程都在等待。</p>
<center>
    <img src="../images/deadlock-csp-why.png" width="500"/>
</center>

<h4 id="Solutions-that-do-not-work"><a href="#Solutions-that-do-not-work" class="headerlink" title="Solutions that do not work"></a>Solutions that do not work</h4><p>问题好像出在<code>select</code>表达式。修复它很简单。相对于由下载器通过select处理来自<code>references</code>和<code>contents</code>的消息，我们可以使用actor模型作为协程重写下载器，它有独立的mailbox通道来处理发送过来的消息。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (msg <span class="keyword">in</span> mailbox) &#123;</span><br><span class="line">    <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">is</span> Reference -&gt; ...</span><br><span class="line">        <span class="keyword">is</span> LocContent -&gt; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，actor模型也不能避免死锁，这种方式和原来一样代码很快被挂起。他们的通讯状态机是相同的。</p>
<p>另一个可能被指责的是集合信道——没有缓冲区的信道，因为它们在另一端没有接收器的情况下会暂停发送。即使我们给<code>contents</code>和<code>locations</code>添加buffer也不能解决此问题，只是减少了问题出现的概率或延迟出现。buffer越大出现的概率越低，但无法完全避免死锁的发生，一旦buffer满了发送器还是会挂起并发生死锁。</p>
<h4 id="Unlimited-capacity-channels"><a href="#Unlimited-capacity-channels" class="headerlink" title="Unlimited-capacity channels"></a>Unlimited-capacity channels</h4><p>一种明确的避免死锁的解决方案是对被通讯死锁影响的channel中的至少一个使用不限大小的buffer，<a href="https://github.com/elizarov/DeadlocksInCSP/blob/master/src/DownloaderWithUnlimitedBuffer.kt#L49">这里</a> 的代码对<code>contents</code>通道使用了无限制buffer，似乎能正常工作。</p>
<p>然而，通过取消通道缓冲区的限制，我们丧失了CPS编程风格的利润丰厚的属性-自动背压传播.如果来自通道的消息的接收方比发送方慢，则发送方将挂起在全缓冲区上以自动减慢速度。有了无限容量的通道，就不会发生这种情况，管理背压的任务完全由应用程序开发人员承担。如果不能管理背压，系统最终可能会耗尽内存，在其缓冲区中收集越来越多的消息。</p>
<p>在我们的例子中，把<code>locations</code>通道设置成无限buffer会完全移除对传入引用的背压管理，因为即使所有的worker都处于忙碌状态，下载器也将发送所有的消息去<code>locations</code>通道。<br>把contents通道设置成无限buffer会更安全，因为它只影响下载内容的最终处理。然而，在无限容量的情况下，我们面临的风险是，下载器会被传入的<code>references</code>淹没，永远无法处理下载的内容。这使我们离最终解决方案更近一步。</p>
<h4 id="Solutions-that-do-work"><a href="#Solutions-that-do-work" class="headerlink" title="Solutions that do work"></a>Solutions that do work</h4><p>我们调整一下下载器协程中<code>select</code>表达式的顺序，以便先检查<code>contents</code>通道，也就是说<code>contents</code>通道的消息优先级高于<code>references</code>通道：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    contents.onReceive &#123; ... &#125;</span><br><span class="line">    references.onReceive &#123; </span><br><span class="line">        ... </span><br><span class="line">        locations.send(loc)                      <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它本身并没有解决这个问题(你可以在这里验证代码),但它给了一个有用的属性——<br>下载器只有在没有worker被挂起且worker准备发送消息去<code>contents</code>通道时，才发送消息去<code>locations</code>通道(2)。现在，提供至少一个buffer给<code>contents</code>通道就足够了，以确保至少有一个worker可以在(5)发送其内容，并在(4)再次开始从<code>locations</code>接收，从而允许下载程序继续进行:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> contents = Channel&lt;LocContent&gt;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/elizarov/DeadlocksInCSP/blob/master/src/DownloaderFixedPriority.kt">这里</a> 是能运行的代码。</p>
<p>注意，它是如何在3秒内处理比之前的无限渠道“解决方案”更多的下载的。此外，由于<code>contents</code>通道处理具有最高优先级，现在可以安全地拥有无限容量的<code>contents</code>通道。它在缓冲区中保存的消息永远不会超过工作人员的数量加1(为什么是加1 ?这是留给读者的练习)。</p>
<p>还有一种替代解决方案，它完全不使用缓冲通道，可以完美地与任何容量的通道一起工作。它加倍<code>select</code>，以避免在<code>locations.send(loc)</code>上挂起下载程序，将这个发送操作折叠为一个<code>select</code>。它实际上是CFSM模型中表示和分析的最简单的一个，但是我现在不会详细介绍它，把它留给将来的故事。你可以看一下<a href="https://github.com/elizarov/DeadlocksInCSP/blob/master/src/DownloaderFixedSelect.kt#L16">这里</a> 对应的代码并在playground中运行它。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通信循环(非DAG模式)可能并将导致通道容量有限的通信死锁，除非使用一些死锁预防策略。如果在应用程序中遇到死锁，在了解发生了什么之前，不要尝试使用缓冲通道解决它，否则可能会把问题掩盖起来。</p>
<p>请在本文的评论中分享更多解决这种特殊通信循环死锁的有效解决方案。Kotlin和其他CSP/actor运行时中的代码都是受欢迎的(请提供链接，不要将代码粘贴到评论中)。</p>
<h4 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h4><p>我要感谢Alexey Semin，他通过<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/797">这个</a> github-issue报告了这个问题，并感谢Alexander Gorynin在Kotlin Slack里联系了我。还要感谢Simon Wirtz和Sean McQuillan对本文草稿的有用评论。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>一周工作总结</title>
    <url>/my-work-of-this-week-01.html</url>
    <content><![CDATA[<h5 id="时间：2021-11-22-至-2021-11-26"><a href="#时间：2021-11-22-至-2021-11-26" class="headerlink" title="时间：2021-11-22 至 2021-11-26"></a>时间：2021-11-22 至 2021-11-26</h5><h6 id="2021-11-22-周一："><a href="#2021-11-22-周一：" class="headerlink" title="2021-11-22 周一："></a>2021-11-22 周一：</h6><ul>
<li>完成数据迁移逻辑<ul>
<li>内外置SD卡兼容</li>
<li>子主账号兼容</li>
<li>Android-11兼容</li>
</ul>
</li>
<li>文件恢复逻辑支持旧文件</li>
<li>优化文件恢复不产生新数据库记录</li>
</ul>
<h6 id="2021-11-23-周二："><a href="#2021-11-23-周二：" class="headerlink" title="2021-11-23 周二："></a>2021-11-23 周二：</h6><ul>
<li>各接口域名换新</li>
<li>调整各逻辑至迁移完成后执行</li>
</ul>
<h6 id="2021-11-24-周三："><a href="#2021-11-24-周三：" class="headerlink" title="2021-11-24 周三："></a>2021-11-24 周三：</h6><ul>
<li>崩溃日志上报地址</li>
<li>deeplink协议替换</li>
</ul>
<h6 id="2021-11-25-周四："><a href="#2021-11-25-周四：" class="headerlink" title="2021-11-25 周四："></a>2021-11-25 周四：</h6><ul>
<li>合并马甲包分支与云盘分支，合并数据库升级与数据迁移逻辑</li>
<li>替换应用名称</li>
</ul>
<h6 id="2021-11-26-周五："><a href="#2021-11-26-周五：" class="headerlink" title="2021-11-26 周五："></a>2021-11-26 周五：</h6><ul>
<li>马甲包去掉渠道和发达国家的特有逻辑，走常规逻辑</li>
<li>Facebook三方登录应用注册获取fb-app-id</li>
<li>清理不必要的打包产物</li>
<li>启用常量内联和R文件内联</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>本周工作围绕马甲包上线展开，工作琐碎且繁杂，需要思考细节避免遗漏和考虑不周。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>经济学的十大原理</title>
    <url>/principles-of-economics.html</url>
    <content><![CDATA[<h4 id="一、人们如何做出决策"><a href="#一、人们如何做出决策" class="headerlink" title="一、人们如何做出决策"></a>一、人们如何做出决策</h4><h5 id="1-1-人们面临权衡取舍"><a href="#1-1-人们面临权衡取舍" class="headerlink" title="1.1 人们面临权衡取舍"></a>1.1 人们面临权衡取舍</h5><p>选择一样东西就意味着你要放弃另外一样东西。认识到生活中的权衡是重要的，因为人们只有了解他们可以得到的选择，才能作出良好的决策。</p>
<h5 id="1-2-某种东西的成本是为了得到它而放弃的东西"><a href="#1-2-某种东西的成本是为了得到它而放弃的东西" class="headerlink" title="1.2 某种东西的成本是为了得到它而放弃的东西"></a>1.2 某种东西的成本是为了得到它而放弃的东西</h5><p>一种东西的机会成本是为了得到这种东西所放弃的东西</p>
<h5 id="1-3-理性人考虑边际量"><a href="#1-3-理性人考虑边际量" class="headerlink" title="1.3 理性人考虑边际量"></a>1.3 理性人考虑边际量</h5><p>生活中的许多决策涉及到对现有行动计划进行微小的增量调整。 经济学家把这些调整称为边际变动。<br>个人和企业通过考虑边际量将会作出更好的决策。只有一种行动的边际收益大于边际成本，一个理性决策者才 会采取这项行动。</p>
<h5 id="1-4-人们会对激励作出反应"><a href="#1-4-人们会对激励作出反应" class="headerlink" title="1.4 人们会对激励作出反应"></a>1.4 人们会对激励作出反应</h5><ul>
<li>由于理性人通过比较成本与收益🉐做出决策，所以他们会对激励做出反应。</li>
<li>在分析任何一种政策时，不仅应该考虑直接影响，而且还应该考 虑激励发生作用的间接影响。</li>
<li>如果政策改变了激励，它就将使人们改 变自己的行为。</li>
</ul>
<h4 id="二、人们如何相互影响"><a href="#二、人们如何相互影响" class="headerlink" title="二、人们如何相互影响"></a>二、人们如何相互影响</h4><h5 id="2-1-贸易能使每个人的状况变得更好"><a href="#2-1-贸易能使每个人的状况变得更好" class="headerlink" title="2.1 贸易能使每个人的状况变得更好"></a>2.1 贸易能使每个人的状况变得更好</h5><p>贸易使各国可以专 门从事自己最擅长活动，并享有很多的各种各样物品与劳务</p>
<h5 id="2-2-市场通常是组织经济活动的一种好方法"><a href="#2-2-市场通常是组织经济活动的一种好方法" class="headerlink" title="2.2 市场通常是组织经济活动的一种好方法"></a>2.2 市场通常是组织经济活动的一种好方法</h5><ul>
<li>在市场经济中，中央计划者的决策被千百万企业和家庭的决策所取代。</li>
<li>价格和利己引导人们决策</li>
<li>价格就是看不见的手用来指引经济活动的工具</li>
<li>当政府阻止价格根据供求状况自发调整时，他就限制了看不见的手🤚对组成经济的千百万家庭👪和企业的决策进行协调的能力</li>
</ul>
<h5 id="2-3-政府有时可以改善市场结果"><a href="#2-3-政府有时可以改善市场结果" class="headerlink" title="2.3 政府有时可以改善市场结果"></a>2.3 政府有时可以改善市场结果</h5><ul>
<li>只有在政府实施规则并维护对市场经济至关重要的制度时，看不见的手才能施展其魔力。</li>
<li>看不见的手🤚是强有力的，但并不是无所不能的。政府干预经济的原因有两类：促进效率和促进平等。</li>
</ul>
<h4 id="三、整体经济如何运行"><a href="#三、整体经济如何运行" class="headerlink" title="三、整体经济如何运行"></a>三、整体经济如何运行</h4><h5 id="3-1-一国的生活水平取决于它生产物品与服务的能力"><a href="#3-1-一国的生活水平取决于它生产物品与服务的能力" class="headerlink" title="3.1 一国的生活水平取决于它生产物品与服务的能力"></a>3.1 一国的生活水平取决于它生产物品与服务的能力</h5><p>生产率：每单位劳动投入所生产的物品与服务数量。</p>
<h5 id="3-2-当政府发行了过多货币时，物价上升"><a href="#3-2-当政府发行了过多货币时，物价上升" class="headerlink" title="3.2 当政府发行了过多货币时，物价上升"></a>3.2 当政府发行了过多货币时，物价上升</h5><h5 id="3-3-社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#3-3-社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="3.3 社会面临通货膨胀与失业之间的短期权衡取舍"></a>3.3 社会面临通货膨胀与失业之间的短期权衡取舍</h5><ul>
<li>货币的增加刺激社会的整体支出水平，从而增加对物品与服务的需求</li>
<li>需求的增加随着时间的推移，会引起企业提高物价，同时它也鼓励企业雇佣更多的工人👷，并生产更多的物品与服务</li>
<li>雇佣更多的工人👷意味着更少的失业。</li>
</ul>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>《异类-不一样的成功启示录》</title>
    <url>/%E3%80%8A%E5%BC%82%E7%B1%BB-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%88%90%E5%8A%9F%E5%90%AF%E7%A4%BA%E5%BD%95%E3%80%8B.html</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h6 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h6><table>
    <tr>
        <td><img src="../images/books/book-cover-yilei.jpg" width="100"/></td>
        <td>异类：不一样的成功启示录</td>
    </tr>
</table>

<h6 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h6><p>马尔科姆·格拉德威尔（Malcolm Gladwell）（1963年9月3日）毕业于多伦多大学的三一学院，主修历史学，是一位加拿大作家、记者和演讲者，以其畅销书和在《纽约客》杂志上的文章而闻名。他的作品通常探讨社会科学、心理学和行为经济学的主题，通过生动的故事和深刻的见解启发读者。</p>
<p>其他出版物：<br>《引爆点》（The Tipping Point, 2000）：探讨了如何通过少数关键因素引发大的变化，书中引入了“引爆点”的概念。<br>《决断两秒间》（Blink, 2005）：研究了人们在瞬间决策中的潜意识过程和直觉判断。<br>《异类》（Outliers, 2008）：探讨了成功背后的非凡因素，提出了“1万小时定律”等概念。<br>《大开眼界》（What the Dog Saw, 2009）：这本书是他在《纽约客》杂志上发表的文章的集合，涵盖了各种主题。<br>《大卫与歌利亚》（David and Goliath, 2013）：讨论了在人们认为不利的条件下如何取得成功。<br>《谈话的力量》（Talking to Strangers, 2019）：探讨了人们在与陌生人交流时常犯的错误及其后果</p>
<h4 id="第一部分：机遇"><a href="#第一部分：机遇" class="headerlink" title="第一部分：机遇"></a>第一部分：机遇</h4><h5 id="马太效应：英超球员的优势积累"><a href="#马太效应：英超球员的优势积累" class="headerlink" title="马太效应：英超球员的优势积累"></a>马太效应：英超球员的优势积累</h5><p>这一节分成六个部分：</p>
<ul>
<li>成功靠什么：成功靠的是个人意愿和能力优势，只能靠自己而不是他人的帮助。<strong>真的是这样吗？</strong></li>
<li>成功者之幸</li>
<li>生于年初：职业青年队绝大多 数球员的生日集中在1月、2月和3月</li>
<li>优势积累：一个1月1日出生的选手，是在跟许多年纪比其小的队友争夺晋级权。晋级后接受更好的训练。</li>
<li>我们要做怎样的改变：制度改革。<ul>
<li>领先优势造就了天才们辉煌的成就。</li>
<li>在社会学领域，所谓的成功就是“优势积累”的结果</li>
<li>很多制度甚至过早地将一部分人划入了失败者的行列，阻碍了这些人成才</li>
</ul>
</li>
<li>离绝对老大只剩三天：出生在1月4日，只差3天他就是同龄队员中绝对的老大了</li>
</ul>
<p>读书笔记：<strong>有意识的提前建立优势，并不断积累优势是成功的关键。</strong></p>
<h5 id="1万小时定律：生于1955年的乔布斯和比尔盖茨"><a href="#1万小时定律：生于1955年的乔布斯和比尔盖茨" class="headerlink" title="1万小时定律：生于1955年的乔布斯和比尔盖茨"></a>1万小时定律：生于1955年的乔布斯和比尔盖茨</h5><p>这一节分成六个部分：</p>
<ul>
<li>天才创始人：计算机科学家比尔·乔伊。</li>
<li>一万小时有多久：一万小时训练是成为优秀的必要条件。</li>
<li>安娜堡计算机中心的日日夜夜：<blockquote>
<p>现在， 让我们理一理比尔·乔伊的机遇链吧。<br>他有幸考入作为计算机学 科领跑者的密歇根大学；<br>有幸第一批使用分时系统，而不是键盘打孔机；<br>又恰巧密歇根大学的机房管理系统有漏洞， 他得以想学多长时间就学多长时间；<br>因为计算机中心24小时开放，他又得以夜以继日地学习；<br>他获得了充分的时间练习编程，所以当改造UNI;系统项目开始的时候，他顺理成章地进入了项目组。<br>比尔·乔伊的确聪明绝顶，他也热爱学习，这是他成功的一大因素。<br>但是，在他成为专家以前，他首先依靠运气获得了成为专家的机会。</p>
</blockquote>
</li>
<li>甲壳虫乐队的汉堡之行:正是在汉堡的超量训练才使甲壳虫乐队脱颖而出的。</li>
<li>1968年的电脑:比尔盖茨的机遇和更多使用电脑的机会。</li>
<li>时势造成功：机遇造就了成功。</li>
</ul>
<p>读书笔记：成功 = 时代机遇 + 努力</p>
<h5 id="智商和机遇：曼特人的谬误"><a href="#智商和机遇：曼特人的谬误" class="headerlink" title="智商和机遇：曼特人的谬误"></a>智商和机遇：曼特人的谬误</h5><p>这一节分成五个部分：</p>
<ul>
<li>全美最聪明的人：智商195的兰根参加《以一敌百》节目。</li>
<li>超常“特曼人”<blockquote>
<p>这些被挑选出来的天才少年，正式成为历史上最著名的心理学研究的研究对象，他们被统称为“特曼 人”。</p>
</blockquote>
</li>
<li>智商的门槛效应<blockquote>
<p>智商与成功只在一定程度上相互关联， 一旦某 人的智商超过120分，此时更高的智商并不意味着会同比转化成更多的现实优</p>
</blockquote>
</li>
<li>充满想象力的心灵:发散性思维测试要求你运用想象力，寻找尽量多的不同的可能性。</li>
<li>事与愿违的试验结果:特曼忽略了一个事实——智力在现实中的作用并 没有那么大。</li>
</ul>
<h5 id="社交与家庭：天才兰根的忧伤"><a href="#社交与家庭：天才兰根的忧伤" class="headerlink" title="社交与家庭：天才兰根的忧伤"></a>社交与家庭：天才兰根的忧伤</h5><p>这一节分成六个部分：</p>
<ul>
<li>令人心碎的天才命运：天才兰根家庭环境不好，即使是天才，最后结局也很一般。</li>
<li>另一位天才的命运：天才奥本海默，家庭环境好，结局成功。</li>
<li>实践智力从哪来：两个天才的结局为何如此不同？实践智力不同！</li>
<li>协同培养的典范：奥本海默是协同培养的典范。</li>
<li>协同培养与自然成长</li>
<li>如何避免悲剧重演</li>
</ul>
<blockquote>
<p>家境富裕的父母总是让孩子一刻也不能闲着， 让孩子穿梭于各项活动之 间，并听取孩子对老师、教练或是队友的评价<br>而穷人家孩子的生活中完全没有这种紧张的时间安排， 他们的活动不会 是每周两次足球训练，而是和亲戚或者邻居家的孩子在外面玩耍。</p>
</blockquote>
<p>读书笔记：家庭教育很重要，让孩子高效利用时间深度参与到有意义的社会活动中，鼓励孩子表达自己的想法，挑战权威，敢于表现自己。</p>
<h5 id="最佳时代：乔-弗洛姆的律师生涯"><a href="#最佳时代：乔-弗洛姆的律师生涯" class="headerlink" title="最佳时代：乔-弗洛姆的律师生涯"></a>最佳时代：乔-弗洛姆的律师生涯</h5><p>这一节分为七个部分：</p>
<ul>
<li>律师事务所之翘楚：贫穷的移民，被歧视的犹太人：乔-弗洛姆，从世达律师事务所的助理到合伙人，从几个人到几千人。<strong>这是时代造就了行业</strong>。</li>
<li>纽约移民区的故事：弗洛姆成长环境下的几个小故事。<ul>
<li>启示一：身为犹太人的重要性：<br>在那个年代，如果你的家庭背景、宗教信仰、社会地位不符合要 求， 即便你是从法学院毕业的， 你也只能去那些二流的、 刚起步的小事务所，或者自己创业。</li>
<li>启示二：生育潮低谷之幸<br>受20世纪30年代的经济大萧条和第二次世界大战（1939—1945年）的影响，不同阶段出生的人的命运截然不同。</li>
<li>启示三：服装厂与有意义的工作<br>路易斯·波吉尼特和瑞吉娜·波吉尼特夫妇移民美国后卖围裙成长起来的故事。</li>
</ul>
</li>
<li>一代新人胜旧人</li>
<li>成功不是随机事件</li>
</ul>
<p>读书笔记：受歧视的乔-弗洛姆进不了大公司只能进小公司，自己创业，处理那些别人不愿处理的案子。随着时代或政策的转变业务激增，二流律师摇身一变成为一流。弗洛姆并不 是克服了逆境，而是原先的逆境忽然之间变成了机遇。</p>
<h4 id="第二部分：文化传承"><a href="#第二部分：文化传承" class="headerlink" title="第二部分：文化传承"></a>第二部分：文化传承</h4><h5 id="文化差异：小镇哈伦"><a href="#文化差异：小镇哈伦" class="headerlink" title="文化差异：小镇哈伦"></a>文化差异：小镇哈伦</h5><p>这一节分为四部分：</p>
<ul>
<li>血染哈伦<br>哈伦县城两大家族矛盾和枪战。</li>
<li>荣誉文化<blockquote>
<p>“荣誉文化”植根于高地或富庶地区的边缘地带，如意大利的西西里岛 和西班牙的巴斯克山区。这种解释的逻辑是，当人们居住在多岩石的山坡地 带时，由于那里的土地很难耕种，人们大多会依靠放牧生活。游牧文明和耕 种文明大相径庭。<br>从事耕种的农民要想维持生计依靠的是人与人之间的合 作，而从事游牧的牧民所依靠的更多的是自己。农民不必担心他们的庄稼一 夜之间就被人全部偷走，除非盗贼有本事一个晚上就把地里的所有庄稼收割 完。但是牧民就有这样的担忧。<br>实际上，他们一直生活在牲口被偷，整个生 活被毁的恐惧之下。所以他们养成了好斗的性情：他们必须通过自己的言行 表明自己不是弱者，要对危及他们名誉的哪怕是最轻微的挑战予以最坚决的 反击——这就是“荣誉文化”的含义。在游牧文化所在的地方，荣誉感往往是当地男性的存在感与自我价值的中心。</p>
</blockquote>
</li>
<li>遗泽百世<br>心理学家做实验，发现：<blockquote>
<p>有些人的回应被其之前遭到的侮辱影响，有些人的则没有。志愿者的行为是否改变，并不取决于他们的情绪是否稳定，也不取决于他们是知识分子还是运动员， 同样也不取决于他们的相貌。 这其中的决定性因素——我想你一定已经 猜到了——是他们来自何方。</p>
</blockquote>
</li>
<li>文化传承的力量<blockquote>
<p>文化传承是事件背后更强大的力量， 它根深蒂固，影响长存。 经过数代 传承，即便塑造文化的经济、社会、人口等条件已经消失，这种文化也会一 直完好无损地留传下来。文化直接决定了我们看待世界的方法和行为模式，其作用如此巨大，以至于没有它，我们将无法认识世界。</p>
</blockquote>
</li>
</ul>
<h5 id="权力距离指数：韩国飞机失事率"><a href="#权力距离指数：韩国飞机失事率" class="headerlink" title="权力距离指数：韩国飞机失事率"></a>权力距离指数：韩国飞机失事率</h5><blockquote>
<p>权力距离是指人们对待比自己更高等级阶层的态度，特别是指对权威的重视和尊重的程度。</p>
</blockquote>
<ul>
<li>大韩航空801航班：大韩航空空难的故事。</li>
<li>祸不单行：大韩航空是如何从一家安全记录糟糕的公司转变成世界最好的航空公司之一的。</li>
<li>阿维安卡航空052航班：燃油耗尽导致的空难。</li>
<li>初探052航班坠毁：飞机本身操作难度大，机长多次误判，副机长缺乏和塔台的沟通</li>
<li>成功化解空中危机的案例：老人机上晕厥，需要紧急降落，机长决策各种情况，和同事沟通最后完美降落。<blockquote>
<p>这次降落要求拉特瓦特必须具备一定 的沟通素质。这里的沟通不仅意味着向机组下达降落指令，还意味着鼓励、 安抚、说服他人，与他人商讨，以及用清晰无误的语言与他人共享信息。</p>
</blockquote>
</li>
<li>再探052航班坠毁事件:沟通和表达存在问题。<blockquote>
<p>那晚与052航班通过话的另一个航空管制员形容克洛茨“语调冷淡……声音中丝毫听不出紧急之意”。</p>
</blockquote>
</li>
<li>严禁客套：与缓和性语气做斗争， 成为过去15年间商业航空业的主要战役</li>
<li>052航班的最后时刻：</li>
<li>三探052航班坠毁：</li>
<li>空难的深层原因：<ul>
<li>这次事故在很大程度上源于哥伦比亚人长久以来对权威的敬畏与服从</li>
<li>副机长只把自己定位为下属，既然是下属关键性的决定就不应由自己做出，这个决定应由机长做出。</li>
</ul>
</li>
<li>不断积累的小问题:具备飞机失事的3个典型前提：轻微的技术故障、坏天气、疲惫的飞行员</li>
<li>高权力距离指数之恶：(我觉得所谓的高权威，其实就是一种等级制度)<blockquote>
<p>高权力距离指数文化的这种对话方式，只有在聆听者有条件揣摩 对方话语的情况下才是适宜的。也就是说，双方得有足够的时间相互揣摩。 这种方式绝不应该在暴风雨的夜晚，在精疲力竭的机长准备把飞机降落在一 个下滑角指示灯有故障的机场时使用。</p>
</blockquote>
</li>
<li>卸下重担：</li>
</ul>
<p>读书笔记：客机失事的主要原因在于权利指数在副驾驶和主驾驶之间发挥着作用。这是一种文化特征，是一种上下级的阶级关系。我们应该对事不对人，客观辩证的处理问题，不屈服于权威。</p>
<h5 id="内在优势：亚洲人精神"><a href="#内在优势：亚洲人精神" class="headerlink" title="内在优势：亚洲人精神"></a>内在优势：亚洲人精神</h5><p>这一节分为6个部分：</p>
<ul>
<li>数字优势：亚洲人在数字方面有优势，一方面是因为他们对数字的发音更短，另一方面得益于族裔文化。</li>
<li>稻田中的辛劳：种植水稻的亚洲农民一年的工作时长约为3000小时。</li>
<li>稻田精神：努力工作的精神品质在亚洲人身上很常见。</li>
<li>斜率难题：一个计算直线的斜率的实验。</li>
<li>怎样做才算是勤奋：态度比能力更重要。 只要你有意愿，你就能驾驭数学。</li>
<li>劳有所得：哪个国家和地区的学 生更愿意花时间仔细回答冗长的问卷，哪个国家和地区的学生在TIMSS考试中的成绩就更好。</li>
</ul>
<p>读书笔记：亚洲人精神:吃苦耐劳，耐心，持之以恒。</p>
<h5 id="扭转风气：玛丽塔之幸"><a href="#扭转风气：玛丽塔之幸" class="headerlink" title="扭转风气：玛丽塔之幸"></a>扭转风气：玛丽塔之幸</h5><p>这一节分为6个部分：</p>
<ul>
<li>风气之先：KIPP项目代表了美国教育的新理念，它的成功并非依靠环境、师资或制度创新。</li>
<li>西方教育的传统：<ul>
<li>亚洲：水稻耕种次数越多收获越多 -&gt; 学习越努力收获越多</li>
<li>西方：小麦需要休耕让土地保持肥沃 -&gt; 过度学习会对学生个性生活习惯造成恶劣影响</li>
</ul>
</li>
<li>成绩到底差在哪儿：假期时间导致低收入家庭孩子成绩没长进，而高收入家庭孩子在假期做的事情更有意义。</li>
<li>对症下药：更多的学习时间，更慢的节奏，更多理解和思考。</li>
<li>挑战自我：KIPP学园的学生(玛丽塔)：多出50%-60%的时间学习，早上5点就起床，很晚才睡。</li>
<li>机遇之歌：玛丽塔需要的其实只有一样东西——机遇.(玛丽塔放弃一些自由时间，放弃一些个性，通过更多的学习时间和努力改变自己的命运，原本上不了大学，现在有机会了)<blockquote>
<p>“异类”是那些获得特殊机遇之人，是那些耐心等待，当机遇到来时就当仁不让地把握住的人。<br>对于加拿大的冰球运动 员来说，生于1月就是他们进入全明星队的机遇。<br>对于甲壳虫乐队来说，汉堡 之旅就是他们成名的机遇。<br>对于比尔·盖茨来说，他的特殊机遇就是生在正 确的年代，并在初中时代就获得电脑终端。<br>对于弗洛姆和沃切尔·利普顿· 罗森·卡茨律师行的创始人来说，机遇是多重的：他们出生于最佳年代，有着能给他们最勤勉激励的父母；他们拥有少数族裔身份，这种身份帮助他们在纽约其他传统律师事务所涉足公司并购官司以前，就已在这个领域实践了20年。<br>最后是大韩航空，直到公司帮助飞行员突破原有文化的禁锢，他们才最终扭转了局势。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《思考，快与慢》 第7章 字母B与数字13</title>
    <url>/%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B-%E7%AC%AC7%E7%AB%A0-%E5%AD%97%E6%AF%8DB%E4%B8%8E%E6%95%B0%E5%AD%9713.html</url>
    <content><![CDATA[<p>本章包含三节：</p>
<ul>
<li>是什么让你相信了那些荒谬之辞</li>
<li>光环效应与群体智慧</li>
<li>眼见为实的想法往往让我们仓促作出决定</li>
</ul>
<h4 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h4><center>
    <img src="../images/b_and_13.jpg" width="50%"/>
</center>

<blockquote>
<p>“同样的形状在字母的环境下就容易被看做是字母，在数字的环境下就容易被看做是数字”</p>
</blockquote>
<blockquote>
<p>“你过早地对它的“身份”下了结论，并且根本意识不到你已经赋予了某种歧义以解释。”</p>
</blockquote>
<blockquote>
<p>“你作了一个确切的选择，但自己却没有意识到自己这样做了”</p>
</blockquote>
<h4 id="是什么让你相信了那些荒谬之辞"><a href="#是什么让你相信了那些荒谬之辞" class="headerlink" title="是什么让你相信了那些荒谬之辞"></a>是什么让你相信了那些荒谬之辞</h4><blockquote>
<p>联想记忆的运作是导致“确认偏误”的原因之一</p>
</blockquote>
<p>“你试试他给出的例子：“白鱼吃糖果。”<br>你有可能意识到一个关于鱼和糖果的模糊印象，这个印象的产生过程，就是联想记忆自动搜索“鱼”和“糖果”这两个概念之间各种联系的过程，这一过程会使这种很荒唐的说法看起来竟有些道理了。</p>
<h4 id="光环效应与群体智慧"><a href="#光环效应与群体智慧" class="headerlink" title="光环效应与群体智慧"></a>光环效应与群体智慧</h4><p>“如果你赞同一个总统的政见，你可能也会喜爱他的声音及着装。喜爱（或讨厌）某个人就会喜爱（或讨厌）这个人的全部—包括你还没有观察到的方面—这种倾向就叫做光环效应”</p>
<p>Alan：聪明—勤奋—冲动—爱挑剔—固执—忌妒心强<br>Ben：忌妒心强—固执—爱挑剔—冲动—勤奋—聪明</p>
<p>“光环效应注重第一印象，而后续信息在很大程度上都被消解掉了”</p>
<h4 id="眼见为实的想法往往让我们仓促作出决定"><a href="#眼见为实的想法往往让我们仓促作出决定" class="headerlink" title="眼见为实的想法往往让我们仓促作出决定"></a>眼见为实的想法往往让我们仓促作出决定</h4><p>“所有受试者都充分了解了整个过程，那些只听到其中一方辩词的受试者能够很轻松地为另一方写出辩词。然而，片面的证据陈述对判断有着重大影响。<br>另外，只掌握一方证据的受试者比掌握了双方证据的受试者更有自信。”</p>
<p>“这正说明人们根据已有信息“勾勒出的故事的连贯性增强了他们的自信心。一个好故事最重要的是信息的前后一致性，而不是其完整性。<br>的确，你常会发现：知道得很少反而可以把已知的所有事物都囊括进连贯的思维模式中。</p>
<p>“眼见即为事实的理念有助于达成连贯性和认知放松的状态，从而使我们相信某个陈述是真实的。这一理念解释了我们能够快速思考的原因，解释了我们是如何弄清楚一个复杂领域中那些信息片段的含义的。很多时候，我们拼凑出的连贯情节与事实是无限接近的，完全可以用来支持理性活动”</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>《慢思考》</title>
    <url>/%E3%80%8A%E6%85%A2%E6%80%9D%E8%80%83%E3%80%8B.html</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h6 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h6><table>
    <tr>
        <td><img src="../images/books/slow-thinking.jpg" width="100"/></td>
        <td>慢思考：大脑超载时代的思考学</td>
    </tr>
</table>

<h4 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h4><p><a href="https://www.amazon.com/stores/author/B004N70U74/about">特奥·康普诺利（Teo Compagnoli）</a>教授是一位在医学、神经精神病学、心理治疗和商业咨询领域都颇有建树的专家。</p>
<ul>
<li>比利时的鲁汶天主教大学获得医学博士</li>
<li>荷兰的阿姆斯特丹大学获得博士</li>
</ul>
<p>其他出版物：</p>
<ul>
<li>《压力：朋友和敌人》</br></li>
</ul>
<h4 id="本书的结构"><a href="#本书的结构" class="headerlink" title="本书的结构"></a>本书的结构</h4><ol>
<li>第一部分：解释了大脑的工作机制</li>
<li>第二部分：忽视大脑的优势劣势就会给大脑套上无形的锁链</li>
<li>第三部分：解开大脑锁链的方案——慢思考</li>
</ol>
<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>人的大脑有三套负责认知决策的脑系统：</p>
<ul>
<li>反射脑：快速原始无意识处理问题</li>
<li>思考闹：慢而成熟消耗大量能量</li>
<li>存储闹：存储信息激发创意</li>
</ul>
<p>如何保持专注：</p>
<ul>
<li>第一，彻底离线：抽出固定的不受打扰的时间完成专注工作和对话</li>
<li>第二，批量处理：尽量减少切换次数</li>
<li>第三，恢复正常的睡眠模式</li>
<li>第四，科学应对负面压力</li>
</ul>
<h4 id="第一部分：神奇大脑一个简单而迷人的科学真相"><a href="#第一部分：神奇大脑一个简单而迷人的科学真相" class="headerlink" title="第一部分：神奇大脑一个简单而迷人的科学真相"></a>第一部分：神奇大脑一个简单而迷人的科学真相</h4><ul>
<li>第一章，关于大脑的惊人真相<br>  大脑里帮助我们处理数据的细胞总数共有1600亿个，大脑并不像机器一样由一个个独立部件组成，而是一套层层叠叠的复杂网络，他没有中枢决策器官。新细胞的产出会随着年龄的增长而减少但不会彻底停止。<br>  大脑能够与身体里的50万亿～100万亿个细胞进行直接的双向通信，这些细胞组成了我们的“身体脑”。<br>  身体脑通过三套系统影响全身所有细胞：<ul>
<li>反应极其迅速的神经系统</li>
<li>反应较慢的内分泌系统。</li>
<li>免疫系统。</li>
</ul>
</li>
<li>第二章，果壳里的三种脑<ul>
<li>慢而成熟的思考脑<ul>
<li>速度慢，需要专注，消耗大量能量，易疲劳，串行处理，制定远期目标并提前做出预判。</li>
</ul>
</li>
<li>快而原始的反射脑<ul>
<li>速度快，自发无意识，情感网络也属于反射脑的一部分。</li>
</ul>
</li>
<li>时刻等待空闲的存储脑<ul>
<li>信息分类存储，主要以联想方式保存信息，年龄增加信息检索时间增加，与思考脑保持平衡，其中一个激活另一个就休息。</li>
</ul>
</li>
</ul>
</li>
<li>第三章，思考脑：不能一心二用</li>
<li>第四章，反射脑：总喜欢抄捷径</li>
<li>第五章，存储闹：至关重要的放松</li>
<li>第六章，如何在扁平的世界深入思考</li>
</ul>
<h4 id="第二部分：脑锁链如何不自觉地摧毁自己的大脑"><a href="#第二部分：脑锁链如何不自觉地摧毁自己的大脑" class="headerlink" title="第二部分：脑锁链如何不自觉地摧毁自己的大脑"></a>第二部分：脑锁链如何不自觉地摧毁自己的大脑</h4><ul>
<li>第七章，1号锁链：随时在线<ul>
<li>现代技术让我们被短信邮件通知电话等外部事件所吸引，导致精力分散。</li>
<li>信息超载，信息的充沛消耗资源，消耗什么资源呢？接收者的注意力！</li>
<li>决策疲劳：经过一段时间持续的自我控制或是做出大量的小选择以后，人 的自控力、毅力、面对失败时的韧性都会有所衰退，拖延情况加剧， 数学计算的数量和质量下降，决策能力也会变差。</li>
</ul>
</li>
<li>第八章，2号锁链：多任务并行</li>
<li>第九章，3号锁链：低水平压力</li>
<li>第十章，4号锁链：睡眠不足</li>
<li>第十一章，离线思考为何如此困难<ul>
<li>深入阅读是思考不可或缺的前提</li>
<li>真正的对话对思考至关重要<ul>
<li>level1 = 闲聊：重点不在于内容，在于维护关系</li>
<li>level2 = 讨论：说明自己的主观看法、观点、意见、信念和价值判断</li>
<li>level3 = 真正对话：综合彼此看法创造出新意义并由此建立更稳固的关系。能够发起并引导真正的对话，这是智商和情商的重要元素。</li>
</ul>
</li>
<li>分散注意力的罪魁祸首<center>
<img src="../images/books/xinxi_and_sikao.jpg" width="400"/>
</center></li>
</ul>
</li>
</ul>
<h4 id="第三部分：慢思考如何解放你的大脑"><a href="#第三部分：慢思考如何解放你的大脑" class="headerlink" title="第三部分：慢思考如何解放你的大脑"></a>第三部分：慢思考如何解放你的大脑</h4><ul>
<li>第十二章，1号解锁秘诀：离线思考<ul>
<li>抽出固定的不受打扰的时间，来完成专注的工作和对话。状态最好的时间段（早上？晚上？）。</li>
<li>每周日晚抽出20分钟计划一周的工作，每天睡前抽10分钟安排第二天的工作，这样，睡觉时，存储脑会提前工作。</li>
<li>纸质阅读更利于理解、阅读速度更快、也更不容易疲劳</li>
</ul>
</li>
<li>第十三章，2号解锁秘诀：批量处理</li>
</ul>
<p>13.1 艾森豪威尔原理（事情的重要性、紧急性四象限）</p>
<center>
    <img src="../images/books/important_urgent_things.jpg" width="400"/>
</center>


<p>13.2 帕累托法则（20%的活动创造80%效益，要提高效率，你的找出那些高价值的活动来）</p>
<center>
    <img src="../images/books/paleituo.jpg" width="400"/>
</center>

<ul>
<li>递进帕累托法则（平方：4%的活动产生64%的价值，三次方）</li>
<li>快乐的帕累托法则（做积极有意义让你快乐的事情）</li>
</ul>
<p>13.3 批量处理：<br>13.4 合理安排每个人的任务：<br>13.5 从根源消除多任务：管理者在规划工作流程和项目时应该尽量避免多任务并行。<br>13.6 如何打败邮件怪兽：邮件会过度分散我们的专注力，要集中批量把它处理了。（这可能是外国人生活的一部分吧）</p>
<ul>
<li>第十四章，3号解锁秘诀：恢复正常的睡眠模式<ul>
<li>保证8小时睡眠</li>
<li>每天同样的时间就寝起床，包括周末（补觉应该早点上床而不是晚起）</li>
</ul>
</li>
<li>第十五章，4号解锁秘诀：科学应对负面压力<ul>
<li>短暂压力能刺激智力生产力，压力过大持续时间过长会摧毁你的智力生产力。</li>
<li>频繁任务切换导致的慢性压力会积压成大压力导致思考精疲力尽</li>
</ul>
</li>
</ul>
<center>
    <img src="../images/books/yali.jpg" width="400"/>
</center>

<ul>
<li>第十六章，ABC模式：如何把坏习惯变成好习惯</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这本书的中文名翻译，烂透了！原书名：《脑链：在高度互联的多任务世界中释放你的潜能》核心思想是让你提升大脑利用率，高效工作生活，琐碎工作集中处理，专注。<br>第一部分介绍大脑的工作机制，第二部分介绍了一些导致我们大脑效率低下的问题，第三部分介绍一些方法解决这些问题。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>《认知天性》</title>
    <url>/%E3%80%8A%E8%AE%A4%E7%9F%A5%E5%A4%A9%E6%80%A7%E3%80%8B.html</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h6 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h6><table>
    <tr>
        <td><img src="../images/books/renzhitianxing.jpg" width="100"/></td>
        <td>认知天性 : 让学习轻而易举的心理学规律</td>
    </tr>
</table>

<h6 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h6><p>三位作者：</p>
<ul>
<li>彼得·布朗（Peter C. Brown）<br>一位作家和独立出版人，专注于撰写历史、商业和心理学方面的书籍。他在《认知天性》中担任主要撰稿人，负责将科学家们的研究成果转化为易于理解和应用的内容</li>
<li>亨利·勒迪格（Henry L. Roediger III）<br>华盛顿大学心理与脑科学系的教授。他的研究主要集中在记忆和学习方面，尤其是记忆的提取和测试效应（testing effect）。勒迪格教授在认知心理学领域发表了大量的研究论文，并获得了多项荣誉和奖项。</li>
<li>马克·麦克丹尼尔（Mark A. McDaniel）<br>华盛顿大学心理与脑科学系的教授，专注于认知心理学和教育心理学。他的研究兴趣包括记忆、学习策略和如何在实际教育环境中应用这些策略。麦克丹尼尔教授也在认知心理学领域发表了许多重要的研究成果，并与勒迪格教授共同开展了大量的合作研究。</li>
</ul>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><ul>
<li>学习是挑战天性的必须课</li>
<li>学习的本质：知识链和记忆结</li>
<li>“后刻意练习”时代的到来</li>
<li>知识的“滚雪球”效应</li>
<li>打造适合自己的心智模型</li>
<li>选择适合自己的学习风格</li>
<li>终身学习者基本的基本</li>
<li>写给大家的学习策略</li>
</ul>
<h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><ul>
<li>1、学习是挑战天性的必须课<ul>
<li>天性懒惰孕育了认知规律和心智模型<ul>
<li>耗费心血的学习才是深层次的，效果也更持久。不花力气的学习就像在沙子上写字，今天写上，明天字就消失了。</li>
<li>与反复阅读这种复习方法相比，<strong>回想事实、概念或事件</strong>会更有效。这种方法被称为检索式练习。</li>
</ul>
</li>
<li>科学“照妖镜”下的学习方法<ul>
<li>背诵、不断重复、反复阅读、<strong>功利性记忆</strong>、集中练习等方式，看起来很刻苦，其实效果不好，很快被忘记。</li>
<li>对文字越熟悉、越流畅阅读，会造成一种掌握的假象。</li>
<li>当事关重大时，当抽象的事务被形象化时，当事情和个人息息相关时，你就会把学到的东西记得更牢。</li>
<li>轻易接受别人的观点，不给自己提问题，没有去想什么是自己不知道的</li>
</ul>
</li>
<li>知识多不等于学习能力强<ul>
<li>学习知识不能求快，要求扎实，循序渐进理解。</li>
</ul>
</li>
<li>考试是最有效的学习策略之一<ul>
<li>不要把考试当做衡量学习成果的标尺，而是记忆检索的练习，一种学习工具。</li>
<li>主动检索（考试）可以强化记忆，而且检索花费的心思越多，受益就越多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>读书笔记：不要无意识的重复，集中练习、把抽象形象化，找到知识与自己的关联。别太在意考试的成绩。</p>
<ul>
<li>2、学习的本质：知识链和记忆结<ul>
<li>知识最终将变成条件反射<ul>
<li>可以带来更好的学习效果：从记忆中检索知识或是早期的训练内容，把这些和新体验联系起来，借助观察和思考，预先演练你下次可能采取的不同做法。</li>
</ul>
</li>
<li>自我检查：给知识链打上记忆结<ul>
<li>重复检索能让记忆更清透，而且它把记忆这条绳子又缠了一圈，使其变得 更牢靠。</li>
</ul>
</li>
<li>只需一次自测：一周后回忆率28%跃迁为39%<ul>
<li>自测是一种检索式学习，可以强化记忆。</li>
</ul>
</li>
<li>如何成为一名主动学习者</li>
<li>为何学习越轻松效果越不好</li>
</ul>
</li>
</ul>
<p>读书笔记：不断回顾知识（考试）可以加深印象，减少遗忘。反思也是一种记忆检索。</p>
<ul>
<li>3、“后刻意练习”时代的到来<ul>
<li>频繁的集中练习只会产生短期记忆</li>
<li>间隔练习使知识存储得更牢固</li>
<li>穿插练习有助于长期记忆</li>
<li>多样化练习促进知识的活学活用</li>
<li>善用练习组合，带来成长性思维</li>
<li>知识是平面的，复合型知识是立体的</li>
<li>关于练习的几条普适性原则</li>
</ul>
</li>
</ul>
<p>读书笔记：这一部分的副标题是连贯深入的。</p>
<ul>
<li>4、知识的“滚雪球”效应<ul>
<li>学习的三个关键步骤<ul>
<li>编码</li>
<li>巩固</li>
<li>检索</li>
</ul>
</li>
<li>欲求新知，先忘旧事<ul>
<li>使用Mac电脑，要先忘记Windows电脑，因为Windows的操作习惯会干扰你的学习。忘掉的不是知识本身，而是检索的线索。</li>
</ul>
</li>
<li>越容易想起，越不容易记住</li>
<li>学习中必须要做哪些努力<ul>
<li>重新巩固记忆</li>
<li>打造心智模型：复杂理论或连续运动技能融合成有意义的整体。</li>
<li>举一反三</li>
<li>构建概念学习</li>
<li>学习迁移</li>
<li>做好学习的心理准备</li>
</ul>
</li>
<li>这些”良性干扰“能提升学习效果</li>
<li>化解因失败带来的焦虑感</li>
<li>创造性源于不设限的学习</li>
<li>别在无法克服的困难上浪费时间</li>
</ul>
</li>
</ul>
<p>读书笔记：</p>
<ul>
<li>5、打造适合自己的心智模型<ul>
<li>没头脑的机制1和爱自省的机制2<ul>
<li>指反射脑和逻辑脑（《思考快与慢》）</li>
</ul>
</li>
<li>学习时避免错觉和记忆扭曲</li>
<li>打造适合自己的心智模型</li>
<li>你无法从不擅长的事情里学到知识</li>
<li>实践和测验才能暴露学习漏洞</li>
</ul>
</li>
</ul>
<p>读书笔记：</p>
<ul>
<li>6、选择适合自己的学习风格<ul>
<li>主动学习能制造掌控感</li>
<li>你是分析型、创新型、还是实践型思维<ul>
<li>第一种智力区分模型：8种<ul>
<li>逻辑——数学智力：批判性思考，以及使用数字和抽象概念的能 力，诸如此类。</li>
<li>空间智力：三维判断，以及在脑海中具象化的能力。</li>
<li>语言智力：使用文字和语言的能力。</li>
<li>肢体动觉智力：行动敏捷和控制身体的能力。</li>
<li>音乐智力：对声音、旋律、音色，以及音乐的敏感性。</li>
<li>人际交往智力：“读懂”他人，以及与人有效协作的能力。</li>
<li>内省智力：理解自身，准确判断自身知识、能力、效率的能力。</li>
<li>自然观察智力：区分和关联周围自然环境的能力（例如园丁、猎人 或厨师特有的智力）。</li>
</ul>
</li>
<li>第二种智力区分模型：3种<ul>
<li>分析型智力 ：分析型智力是我们解决问题的能力，典型的例子就是解答测验中的问题</li>
<li>创新型智力 ：创新型智力是我们综合并应用现有的知识与技能，应对那些新的特殊情况的能力；</li>
<li>实践型智力 ：实践型智力是我们适应日常生活的能力——明白在具体环境下需要做什么并行动，也就是我们所说的“街头智慧”。</li>
</ul>
</li>
</ul>
</li>
<li>学不好的领域暴露了你的能力结构</li>
<li>用搭积木的方法构建知识</li>
<li>有人喜欢看说明书，有人喜欢动手试错</li>
</ul>
</li>
</ul>
<p>读书笔记：不同的文化与学习场景需要不同的智力类型。</p>
<ul>
<li>7、终身学习者基本的基本<ul>
<li>双胞胎的认知能力也会天差地别<br>大脑的结构与整体构造在很大程度上是由基因决定的，但神经网络的精细构造似乎也可以由经验来塑造，而且具备大幅修改的能力。</li>
<li>性格、求知欲和家庭条件对学习的影响<br>智商是基因🧬与环境共同作用的产物。<br>人类智商在持续升高，因为教育、文化（电视机兴起）、营养（脂肪酸、铁、维B）发生了极大的变化。<br>社会经济地位也会影响智商。早期教育可以提升贫困孩子的智商。</li>
<li>脑力训练可以提升学习自信<br>流体智力：指推理、发现关系、抽象 思维，以及在解决问题的同时头脑中保留信息的能力。<br>晶体智力：指积累的关于世界的知识，以及从过去的学习与经验中提炼出来的 程序或心智模型。</li>
<li>想要终身成长，请像专家一样思考<br>1、信念：你要相信智力水平不是固定的，而是在很大程度上掌握在自己手中。<br>2、面对失败的态度：那些将失败归咎于本身无能的人——说“我就是不够聪明”的人——会变得无助；而那些认为失败是努力不够或策略不对的人则会深入发掘，尝试不同的做法。<br>3、目标：有的学生以成绩为目标，而有的学生则以学习为目标。对于前一种人来说，他们努力是为了证明自己的能力。对于第二种人来说，他们努力则是为了学到新的知识或技能</li>
<li>学习执行力比学习技巧更重要：成为专家需要一万小时刻意练习。</li>
<li>掌握几个适合自己的记忆方法：记忆宫殿等记忆技巧</li>
</ul>
</li>
</ul>
<p>读书笔记：智商 = 基因 + 环境因素。我们可以通过改变环境因素提升我们的智商。</p>
<ul>
<li>8、写给大家的学习策略<ul>
<li>给学生的学习策略<ul>
<li>练习从记忆中检索新知识</li>
<li>有间隔的安排检索练习</li>
<li>学习时穿插安排不同类型问题</li>
</ul>
</li>
<li>给职场人士的学习策略</li>
<li>给教师的学习策略<ul>
<li>向学生解释学习的过程</li>
<li>教学生如何学习</li>
<li>在课堂上创造合意困难</li>
<li>保证透明度：让学生理解用意。</li>
</ul>
</li>
<li>给培训者的学习策略</li>
</ul>
</li>
</ul>
<h5 id="全书总结"><a href="#全书总结" class="headerlink" title="全书总结"></a>全书总结</h5><p>从作者的职业可以看出，一个出版人和两个教授合作出版的一本书。属于认知心理学范畴。主要介绍学习、认知、大脑相关实验和结论。</p>
<p>1、自己究竟有没有掌握一个知识点。考试（测验、自测）是一个很好的检验手段。不像学校里的考试，要以正确的心态看待考试，只是检测自己知识的掌握度，而不是要一较高下。</p>
<p>个人理解：<br>获取到新知识，停留在浅层记忆，会有迷惑性，以为自己懂了。实则过段时间就忘记了。我们应该间隔性的回忆知识，内化吸收，这样才能将知识灵活运用。</p>
]]></content>
  </entry>
  <entry>
    <title>《麻省理工深度思考法》</title>
    <url>/%E3%80%8A%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E6%B3%95%E3%80%8B.html</url>
    <content><![CDATA[<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h6 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h6><table>
    <tr>
        <td><img src="../images/books/masheng-thinking.jpg" width="100"/></td>
        <td>麻省理工深度思考法 : 从模型及动力机制来思考现象</td>
    </tr>
</table>

<h6 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h6><p>[日] 平井孝志（Takashi Hirai）,罗兰贝格管理咨询公司执行董事,东京大学理学硕士、麻省理工MBA博士。</p>
<p>其他出版物：</p>
<ul>
<li>《本質思考 : MIT菁英這樣找到問題根源，解決困境》、</li>
<li>《图像思考术 : 为什么聪明人会通过画图来思考？如何用一页纸解决生活和工作问题》</li>
</ul>
<h4 id="书本的结构"><a href="#书本的结构" class="headerlink" title="书本的结构"></a>书本的结构</h4><ol>
<li>九个思维定式（了解思维定式才能注意📢避免）</li>
<li>模型和动力机制</li>
<li>第一步：建立模型</li>
<li>第二步：解读动力机制</li>
<li>第三步：寻找改变模型的对策</li>
<li>第四步：从实践获得反馈</li>
<li>日常训练方法</li>
</ol>
<h5 id="九个思维定式"><a href="#九个思维定式" class="headerlink" title="九个思维定式"></a>九个思维定式</h5><ul>
<li>初级思维定式<ul>
<li>因果倒置——————（表面现象不是原因，究其现象的本质）</li>
<li>满足于普通解</li>
</ul>
</li>
<li>可能陷入两难的严峻定式<ul>
<li>依赖框架——————（框架是工具，不满足于工具的使用，而是借助框架思考）</li>
<li>范围适应——————（指着眼于事物分类以寻找解释）</li>
<li>思考止于关键词——————（要理解和思考一些高大上的关键词的含义，别以为你懂了）</li>
<li>执着于初步假设</li>
</ul>
</li>
<li>不能迈入思考大门的症状<ul>
<li>忘却思考的初衷——————（收集资料是为了使用资料，而不是目的）</li>
<li>偏重过程</li>
<li>失去独立思维——————（依赖他人，一味地”是啊”，”对啊”，”是这样吗？”）</li>
</ul>
</li>
</ul>
<h5 id="模型和动力机制"><a href="#模型和动力机制" class="headerlink" title="模型和动力机制"></a>模型和动力机制</h5><blockquote>
<p>“本质” = “模型” × “动力机制”</p>
</blockquote>
<blockquote>
<p>“模型是指产生某种现象的结构，包括构成要素及其相互关系。”</p>
</blockquote>
<blockquote>
<p>“所谓动力机制，是以长远目光观察模型产生的现象，以及今后将会产生怎样的结果及动向，即会出现怎样的模式。”</p>
</blockquote>
<center>
    <img src="../images/books/moxing-dongli.jpg" width="400"/>
</center>


<p>模型是什么？</p>
<ul>
<li>剥离细枝末节后的精简概念图或因果循环图</li>
</ul>
<p>动力机制是什么？</p>
<ul>
<li>模型随着时间流逝产生的运动及结果</li>
</ul>
<h5 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h5><ul>
<li>分析问题的因素，及其因果关系</li>
<li>用一张图绘制出因果循环图</li>
</ul>
<center>
    <img src="../images/books/yinguo-xunhuantu.jpg" width="400"/>
</center>

<p>建模要点①：5个要素：</p>
<ul>
<li>“输入源是指投入模型中的要素”</li>
<li>“输出点是指模型产生的成果”</li>
<li>“竞争关系是指在输入及输出等方面互相竞争的对象”</li>
<li>“合作关系是指在一起可以互补或协作的对象”</li>
<li>“影响者是指间接对模型整体产生重大影响的要素”</li>
</ul>
<p>建模要点②：层次结构</p>
<center>
    <img src="../images/books/model-level.jpg" width="400"/>
</center>

<p>建模要点③：注重因果，无视相关</p>
<center>
    <img src="../images/books/xiangguan-yinguo.jpg" width="400"/>
</center>

<h5 id="解读动力机制"><a href="#解读动力机制" class="headerlink" title="解读动力机制"></a>解读动力机制</h5><p>“动力机制的 6 种代表性模式”</p>
<center>
    <img src="../images/books/donglijizhi-moshi.jpg" width="400"/>
</center>

<ul>
<li><p>动力机制探究要点①：分开研究存量和流量</p>
</li>
<li><p>动力机制探究要点②：对事物进行非线性解读</p>
</li>
<li><p>动力机制探究要点③：探究作用与反作用</p>
</li>
<li><p>动力机制探究要点④：从各要素的视角进行深层次的思考</p>
</li>
<li><p>动力机制的解读方法①　探究拐点</p>
</li>
<li><p>动力机制的解读方法②　研究相变（相变使动力机制不再连续）</p>
</li>
<li><p>动力机制的解读方法③　锁定本源动力</p>
</li>
</ul>
<h5 id="寻找改变模型的对策-寻找解决问题的根本方法"><a href="#寻找改变模型的对策-寻找解决问题的根本方法" class="headerlink" title="寻找改变模型的对策(寻找解决问题的根本方法)"></a>寻找改变模型的对策(寻找解决问题的根本方法)</h5><ul>
<li>寻找对策的要点① 正确理解前提条件</li>
<li>寻找对策的要点② 原因不一定接近结果</li>
<li>寻找对策的要点③ 将思考范围扩展到受影响的方方面面（不断地问自己是否考虑到了所有可能有影响的因素）</li>
<li>寻找对策的要点④ 提升视角<ul>
<li>尝试偶尔放下眼前的问题（如果被眼前的问题占用太多注意力，就很难摸索出问题的整体脉络）</li>
</ul>
</li>
<li>寻找对策的要点⑤ 想一想“该如何思考”<ul>
<li>“首先思考的应该是思考顺序和判断标准”</li>
</ul>
</li>
</ul>
<h5 id="从实践获得反馈"><a href="#从实践获得反馈" class="headerlink" title="从实践获得反馈"></a>从实践获得反馈</h5><p>从实践中得到的反馈可以提高思考精确度，反复练习建立模型、解读动力机制、寻找改变模型的对策。</p>
<h5 id="日常训练方法"><a href="#日常训练方法" class="headerlink" title="日常训练方法"></a>日常训练方法</h5><p>略。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>全书的核心在第四第五章。其他部分可以快速跳读。</li>
<li>全书围绕1.建立模型、2.解读动力机制、3.改变模型，这三个步骤介绍了当我们遇到各种问题时，我们应该如何分析问题，找出问题的本质，然后从本质解决问题本身，而不是浮于表面。同时，脑海中要牢记一些思维定式，避免陷入思维定式当中。</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
</search>
