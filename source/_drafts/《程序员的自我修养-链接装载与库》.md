---
title: 《程序员的自我修养-链接装载与库》
tags:
---

#### 概述
##### 书籍简介
<table>
    <tr>
        <td><img src="../images/books/cxydzwxy.jpeg" width="100"/></td>
        <td>程序员的自我修养-链接装载与库</td>
    </tr>
</table>

##### 关于作者
本书由俞甲子、石凡、潘爱民三位作者合作完成。


#### 第一部分：简介
##### 第一章 温故而知新
  + 1.1 从Hello Word说起（引入问题：编译是什么样的、程序怎么存放的、运行内存是什么样的）
  + 1.2 万变不离其宗
  + 1.3 站得高望的远（计算机是分层设计的）
  + 1.4 操作系统是什么（1、管理硬件2、提供抽象接口。充分挖掘CPU、存储、IO潜力）
  + 1.5 内存不够怎么办（虚拟地址）
  + 1.6 众人拾柴火焰高（线程、线程模型：1对1、多对1、多对多）
  + 1.7 本章小结

#### 第二部分：静态编译
##### 第二章 编译和链接
+ GCC命令的背后：预编译->编译->汇编->链接
+ 编译器做了什么：词法分析->语法分析->语义分析->中间语言生成->目标代码生成与优化
+ 重定位：程序修改后重新计算指令目标地址的过程
+ 符号：一个表示函数或变量的起始地址
+ 链接：软件模块之间拼接的过程（拼接需要考虑模块间符号之间的引用）
+ 链接的过程：地址和空间分配->符号决议->重定位


##### 第三章 目标文件里有什么

| ELF文件类型 | 说明 | 实例 |
|:--------|:---|:---|
|    可重定位文件     |  包含代码和数据，可被链接  |  .o文件  |
|    可执行文件     |  -  |  /bin/bash  |
|    共享目标文件     |  -  |  so文件  |
|    核心转储文件     |  -  |    |

+ 目标文件的结构描述
  + 文件头
    + 魔术、ELF重定位类型、硬件平台等
  + 段表：各个段的信息
    + 段名、段长、在文件中的偏移、读写权限
  + 重定位表
    + .rel.text：针对代码段的重定位表
    + .rel.data：针对数据段的重定位表
  + 字符串表
    + .strtab:字符串表
    + .shstrtab:段表字符串表
  + 符号表
    + .symtab：符号表
  + 数据段
    + .data：已初始化的全局变量和局部静态变量
    + .bss：未初始化的全局变量和局部静态变量
  + 调试信息

##### 第四章 静态链接



#### 第三部分：装载和动态链接

3.1 静态链接的缺点
+ 磁盘和内存空间浪费：两个程序共用的Lib会在磁盘和内存存在2份。
+ 程序开发和发布：更新一小个模块就重新发布整个程序。或重新下载安装整个程序。

3.2 动态链接：运行时再进行程序的链接






.dynstr和.shstrtab的区别是什么

.dynstr和.shstrtab都是在ELF(Executable and Linkable Format)文件中的两种不同类型的字符串表。
.dynstr是动态字符串表，它包含了动态链接需要的字符串，包括符号名和需要引入的库名等。
.shstrtab是节头部字符串表，它包含了节区名，用于标识各个节区的名称。
所以，两者的主要区别在于它们存储的字符串的类型和用途不同。


.eh_frame在elf文件里面是什么意思  
.eh_frame是在ELF（Executable and Linkable Format）文件中的一个部分，它用于存储异常处理信息，提供了在C++或其他语言抛出异常时需要的信息。这些信息包括如何解占用的堆栈空间，以及在哪里找到相应的异常处理代码。这个部分是由编译器自动生成的，用于在运行时支持异常处理机制。



#### 第四部分：库与运行库
